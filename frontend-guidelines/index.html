
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>「译」前端编码最佳实践</title>
    <meta name="description" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="../favicon.ico">

    <link rel="stylesheet" type="text/css" href="../assets/css/screen.css?v=abcbb21028">
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic%7COpen+Sans:700,400">

    <link rel="canonical" href="http://localhost:2368/frontend-guidelines/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="http://localhost:2368/frontend-guidelines/amp/">
    
    <meta property="og:site_name" content="ZBL's Doodles">
    <meta property="og:type" content="article">
    <meta property="og:title" content="「译」前端编码最佳实践">
    <meta property="og:description" content="几天前从Github上看到了这篇前端编码最佳实践，Star数已破4K，觉得应该是篇不错的小指南，花了点时间将它稍作翻译，也当是复习复习 HTML&amp;amp;CSS&amp;amp;JS。  翻译时随手参照了《CSS设计指南》、《精通CSS-2ndEdition》、老道的《JavaScript语言精粹》、NZ大神的《JavaScript高级程序设计》，在学习了一些专有名词表达同时，也学到了许多有用的代码和思想。  不过原作者好像是CoffeeScript爱好者，且广泛使用了ES6特性，所以有些名词和表达我暂未理解透彻，还需斟酌。故现将原文译文参照排版，还待之后的更新。 HTML   语义化（Semantics） HTML5 provides us with lots of semantic elements aimed to describe precisely the content. Make sure you benefit from its rich vocabulary.">
    <meta property="og:url" content="http://localhost:2368/frontend-guidelines/">
    <meta property="article:published_time" content="2015-03-14T15:51:36.000Z">
    <meta property="article:modified_time" content="2015-03-14T16:08:39.000Z">
    <meta property="article:tag" content="JavaScript">
    <meta property="article:tag" content="CSS">
    <meta property="article:tag" content="HTML5">
    <meta property="article:tag" content="guidelines">
    <meta property="article:tag" content="translation">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="「译」前端编码最佳实践">
    <meta name="twitter:description" content="几天前从Github上看到了这篇前端编码最佳实践，Star数已破4K，觉得应该是篇不错的小指南，花了点时间将它稍作翻译，也当是复习复习 HTML&amp;amp;CSS&amp;amp;JS。  翻译时随手参照了《CSS设计指南》、《精通CSS-2ndEdition》、老道的《JavaScript语言精粹》、NZ大神的《JavaScript高级程序设计》，在学习了一些专有名词表达同时，也学到了许多有用的代码和思想。  不过原作者好像是CoffeeScript爱好者，且广泛使用了ES6特性，所以有些名词和表达我暂未理解透彻，还需斟酌。故现将原文译文参照排版，还待之后的更新。 HTML   语义化（Semantics） HTML5 provides us with lots of semantic elements aimed to describe precisely the content. Make sure you benefit from its rich vocabulary.">
    <meta name="twitter:url" content="http://localhost:2368/frontend-guidelines/">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="ZBL">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="JavaScript, CSS, HTML5, guidelines, translation">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "ZBL&#x27;s Doodles",
        "logo": "http://localhost:2368/ghost/img/ghosticon.jpg"
    },
    "author": {
        "@type": "Person",
        "name": "ZBL",
        "image": {
            "@type": "ImageObject",
            "url": "http://localhost:2368/content/images/2016/12/pigeon.JPG",
            "width": 640,
            "height": 640
        },
        "url": "http://localhost:2368/author/zbl/",
        "sameAs": [],
        "description": "I&#x27;m what I&#x27;m."
    },
    "headline": "「译」前端编码最佳实践",
    "url": "http://localhost:2368/frontend-guidelines/",
    "datePublished": "2015-03-14T15:51:36.000Z",
    "dateModified": "2015-03-14T16:08:39.000Z",
    "keywords": "JavaScript, CSS, HTML5, guidelines, translation",
    "description": "几天前从Github上看到了这篇前端编码最佳实践，Star数已破4K，觉得应该是篇不错的小指南，花了点时间将它稍作翻译，也当是复习复习 HTML&amp;amp;CSS&amp;amp;JS。  翻译时随手参照了《CSS设计指南》、《精通CSS-2ndEdition》、老道的《JavaScript语言精粹》、NZ大神的《JavaScript高级程序设计》，在学习了一些专有名词表达同时，也学到了许多有用的代码和思想。  不过原作者好像是CoffeeScript爱好者，且广泛使用了ES6特性，所以有些名词和表达我暂未理解透彻，还需斟酌。故现将原文译文参照排版，还待之后的更新。 HTML   语义化（Semantics） HTML5 provides us with lots of semantic elements aimed to describe precisely the content. Make sure you benefit from its rich vocabulary.",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:2368"
    }
}
    </script>

    <meta name="generator" content="Ghost 0.11">
    <link rel="alternate" type="application/rss+xml" title="ZBL's Doodles" href="http://localhost:2368/rss/">
</head>
<body class="post-template tag-javascript tag-css-2 tag-html5 tag-guidelines tag-translation nav-closed">

    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="index.html#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
            <li class="nav-home" role="presentation"><a href="http://localhost:2368/">Home</a></li>
    </ul>
        <a class="subscribe-button icon-feed" href="http://localhost:2368/rss/">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        


<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
            <a class="menu-button icon-menu" href="index.html#"><span class="word">Menu</span></a>
    </nav>
</header>

<main class="content" role="main">
    <article class="post tag-javascript tag-css-2 tag-html5 tag-guidelines tag-translation">

        <header class="post-header">
            <h1 class="post-title">「译」前端编码最佳实践</h1>
            <section class="post-meta">
                <time class="post-date" datetime="2015-03-14">14 March 2015</time>  on <a href="../tag/javascript/">JavaScript</a>, <a href="../tag/css-2/">CSS</a>, <a href="../tag/html5/">HTML5</a>, <a href="../tag/guidelines/">guidelines</a>, <a href="../tag/translation/">translation</a>
            </section>
        </header>

        <section class="post-content">
            <p>几天前从Github上看到了这篇<a href="https://github.com/githubzbl/frontend-guidelines">前端编码最佳实践</a>，Star数已破4K，觉得应该是篇不错的小指南，花了点时间将它稍作翻译，也当是复习复习 <code>HTML&amp;CSS&amp;JS</code>。 <br>
翻译时随手参照了《CSS设计指南》、《精通CSS-2ndEdition》、老道的《JavaScript语言精粹》、NZ大神的《JavaScript高级程序设计》，在学习了一些专有名词表达同时，也学到了许多有用的代码和思想。 <br>
不过原作者好像是<code>CoffeeScript</code>爱好者，且广泛使用了<code>ES6</code>特性，所以有些名词和表达我暂未理解透彻，还需斟酌。故现将原文译文参照排版，还待之后的更新。</p>

<hr>

<h2 id="html">HTML  </h2>

<h4 id="semantics">语义化（Semantics）</h4>

<p>HTML5 provides us with lots of semantic elements aimed to describe precisely the content. Make sure you benefit from its rich vocabulary. <br>
HTML5 给我们提供了大量的语义化元素标签去准确的描述元素内容。希望你从它的丰富的词汇中获益。</p>

<pre><code>&lt;!-- bad --&gt;
&lt;div id="main"&gt;
      &lt;div class="article"&gt;
            &lt;div class="header"&gt;
              &lt;h1&gt;Blog post&lt;/h1&gt;
              &lt;p&gt;Published: &lt;span&gt;21st Feb, 2015&lt;/span&gt;&lt;/p&gt;
            &lt;/div&gt;
            &lt;p&gt;…&lt;/p&gt;
      &lt;/div&gt;
&lt;/div&gt;
&lt;!-- good --&gt;
&lt;main&gt;
      &lt;article&gt;
            &lt;header&gt;
              &lt;h1&gt;Blog post&lt;/h1&gt;
                  &lt;p&gt;Published: &lt;time datetime="2015-02-21"&gt;21st Feb, 2015&lt;/time&gt;&lt;/p&gt;
         &lt;/header&gt;
            &lt;p&gt;…&lt;/p&gt;
      &lt;/article&gt;
&lt;/main&gt;
</code></pre>

<p>Make sure you understand the semantic of the elements you're using. It's worse to use a semantic element in a wrong way than staying neutral. <br>
确保理解你正在使用的元素的语义。错误的使用一个语义化标签元素比啥都不用更糟糕。</p>

<pre><code>&lt;!-- bad --&gt;
&lt;h1&gt;
      &lt;figure&gt;
            &lt;img alt=Company src=logo.png&gt;
      &lt;/figure&gt;
&lt;/h1&gt;

&lt;!-- good --&gt;
&lt;h1&gt;
      &lt;img alt=Company src=logo.png&gt;
&lt;/h1&gt;
</code></pre>

<h4 id="brevity">简洁（Brevity）</h4>

<p>Keep your code terse. Forget about your old XHTML habits. <br>
保持你代码的简洁精练。忘掉那些关于老掉牙XHTML的习惯。</p>

<pre><code>&lt;!-- bad --&gt;
&lt;!doctype html&gt;
&lt;html lang=en&gt;
  &lt;head&gt;
    &lt;meta http-equiv=Content-Type content="text/html; charset=utf-8" /&gt;
    &lt;title&gt;Contact&lt;/title&gt;
    &lt;link rel=stylesheet href=style.css type=text/css /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Contact me&lt;/h1&gt;
    &lt;label&gt;
      Email address:
      &lt;input type=email placeholder=you@email.com required=required /&gt;
    &lt;/label&gt;
    &lt;script src=main.js type=text/javascript&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;!-- good --&gt;
&lt;!doctype html&gt;
&lt;html lang=en&gt;
  &lt;meta charset=utf-8&gt;
  &lt;title&gt;Contact&lt;/title&gt;
  &lt;link rel=stylesheet href=style.css&gt;

  &lt;h1&gt;Contact me&lt;/h1&gt;
  &lt;label&gt;
    Email address:
    &lt;input type=email placeholder=you@email.com required&gt;
  &lt;/label&gt;
  &lt;script src=main.js&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<h4 id="accessibility">容易理解（Accessibility）</h4>

<p>Accessibility shouldn't be an afterthought. You don't have to be a WCAG expert to improve your website, you can start immediately by fixing the little things that make a huge difference, such as: <br>
容易理解不应该是一个附加品。你没必要成为一名WCAG专家再来改善你的网站，通过改动些小地方立马就能变得大不相同。</p>

<ul>
<li>learning to use the alt attribute properly</li>
<li>学会正确使用<code>alt</code>属性</li>
<li>making sure your links and buttons are marked as such (no <div class="button"> atrocities)
<li>确保你的链接和按钮都这样被标记（不要<code>&lt;div class=button&gt;</code>残暴）</li>
<li>not relying exclusively on colors to communicate information</li>
<li>交流信息时不仅仅依赖颜色</li>
<li>explicitly labelling form controls</li>
<li><p>明确地标签表单控制</p>

<pre><code>&lt;!-- bad --&gt;
&lt;h1&gt;&lt;img alt="Logo" src="logo.png"&gt;&lt;/h1&gt;


&lt;!-- good --&gt;
&lt;h1&gt;&lt;img alt="My Company, Inc." src="logo.png"&gt;&lt;/h1&gt;
</code></pre></li>


<h4 id="language">语言（Language）</h4>

<p>While defining the language and character encoding is optional, it's recommended to always declare both at document level, even if they're specified in your HTTP headers. Favor UTF-8 over any other character encoding. <br>
当界定的编码语言和字符是可选择的话，建议你永远都在文档级别（document level）申明，即使它们已在你的HTTP头部规定好。喜欢<code>UTF-8</code>胜过其他类型编码一万倍~</p>

<pre><code>&lt;!-- bad --&gt;
&lt;!doctype html&gt;
&lt;title&gt;Hello, world.&lt;/title&gt;

&lt;!-- good --&gt;
&lt;!doctype html&gt;
&lt;html lang=en&gt;
      &lt;meta charset=utf-8&gt;
      &lt;title&gt;Hello, world.&lt;/title&gt;
&lt;/html&gt;
</code></pre>

<h4 id="performance">性能（Performance）</h4>

<p>Unless there's a valid reason for loading your scripts before your content, don't block the rendering of your page. If your style sheet is heavy, isolate the styles that are absolutely required initially and defer the loading of the secondary declarations in a separate style sheet. Two HTTP requests is significantly slower than one, but the perception of speed is the most important factor. <br>
除非在内容加载之前先载入脚本有个合理的理由，那么就别阻塞你页面的渲染。
如果CSS文件很大，就页面初始时必要的样式分离出来，然后再延迟加载独立样式表中的次要声明。两次HTTP请求会显著地慢于一次，但是（用户对页面加载）速度的感觉才是最重要的因素。</p>

<pre><code>&lt;!-- bad --&gt;
&lt;!doctype html&gt;
&lt;meta charset=utf-8&gt;
&lt;script src=analytics.js&gt;&lt;/script&gt;
&lt;title&gt;Hello, world.&lt;/title&gt;
&lt;p&gt;...&lt;/p&gt;

&lt;!-- good --&gt;
&lt;!doctype html&gt;
&lt;meta charset=utf-8&gt;
&lt;title&gt;Hello, world.&lt;/title&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;script src=analytics.js&gt;&lt;/script&gt;
</code></pre>

<h2 id="css">CSS</h2>

<hr>

<h4 id="semicolons">分号（Semicolons）</h4>

<p>While the semicolon is technically a separator in CSS, always treat it as a terminator. <br>
虽然从技术上说，分号在CSS中是一个分离器，但永远把它当一个终止器来看待。</p>

<pre><code>/* bad */
div {
      color: red
}

/* good */
div {
      color: red;
}
</code></pre>

<h4 id="boxmodel">盒模型（Box Model）</h4>

<p>The box model should ideally be the same for the entire document. A global * { box-sizing: border-box; } is fine, but don't change the default box model on specific elements if you can avoid it. <br>
理想状况下，整个文档的盒模型应该保持一样。 全局的 <code>* { box-sizing: border-box; }</code> 是很好，但尽量别去改变特定元素的默认盒模型。</p>

<pre><code>/* bad */
div {
  width: 100%;
  padding: 10px;
  box-sizing: border-box;
}

/* good */
div {
  padding: 10px;
}
</code></pre>

<h4 id="flow">流（Flow）</h4>

<p>Don't change the default behavior of an element if you can avoid it. Keep elements in the natural document flow as much as you can. For example, removing the white-space below an image shouldn't make you change its default display: <br>
尽量不要去改变一个元素的默认行为。尽你所能让标签元素都待在正常文档流里。比如说，移除一张图片下方空白不应改变它的默认显示：</p>

<pre><code>/* bad */
img {
  display: block;
}

/* good */
img {
  vertical-align: middle;
}
</code></pre>

<p>Similarly, don't take an element off the flow if you can avoid it. <br>
同样地，尽量别把一个元素从文档流中拿出来。</p>

<pre><code>  /* bad */
  div {
     width: 100px;
     position: absolute;
     right: 0;
  }

   /* good */
   div {
     width: 100px;
     margin-left: auto;
   }
</code></pre>

<h4 id="positioning">定位（Positioning）</h4>

<p>There are many ways to position elements in CSS but try to restrict yourself to the properties/values below. By order of preference: <br>
在CSS中有许多方法来定位元素，但尽量限制自己来使用以下的属性/值。通过偏好排序：</p>

<pre><code>display: block;
display: flex;
position: relative;
position: sticky;
position: absolute;
position: fixed;
</code></pre>

<h4 id="selectors">选择符（Selectors）</h4>

<p>Minimize selectors tightly coupled to the DOM. Consider adding a class to the elements you want to match when your selector exceeds 3 structural pseudo-classes, descendant or sibling combinators. <br>
最小化和DOM紧密耦合的选择符。当选择符超出三个结构伪类（structural pseudo-classes）、后代（descendant）或同胞（ sibling）选择符组合的话，考虑为你希望匹配的元素标签加一个类。</p>

<pre><code>/* bad */
div:first-of-type :last-child &gt; p ~ *

/* good */
div:first-of-type .info
</code></pre>

<p>Avoid overloading your selectors when you don't need to. <br>
不必要的时候避免选择符过载。（<strong>译注：CSS选择符过载是什么？只知道 override。</strong>）</p>

<pre><code>/* bad */
img[src$=svg], ul &gt; li:first-child {
  opacity: 0;
}

/* good */
[src$=svg], ul &gt; :first-child {
  opacity: 0;
}
</code></pre>

<h4 id="specificity">特指度（Specificity）</h4>

<p>Don't make values and selectors hard to override. Minimize the use of id's and avoid !important. <br>
别让值和选择符难以重载。减少ID的使用，避免使用<code>!important</code>。</p>

<pre><code>/* bad */
.bar {
  color: green !important;
}
.foo {
  color: red;
}

/* good */
.foo.bar {
  color: green;
}
.foo {
  color: red;
}
</code></pre>

<h4 id="overriding">层叠（Overriding）</h4>

<p>Overriding styles makes selectors and debugging harder. Avoid it when possible. <br>
 层叠样式会使选择符和调试更加复杂困难。尽可能避免使用。</p>

<pre><code> /* bad */
li {
  visibility: hidden;
}
li:first-child {
  visibility: visible;
}

/* good */
li + li {
  visibility: hidden;
}
</code></pre>

<h4 id="inheritance">继承（Inheritance）</h4>

<p>Don't duplicate style declarations that can be inherited. <br>
能继承的样式声明就别多写。</p>

<pre><code>/* bad */
div h1, div p {
  text-shadow: 0 1px 0 #fff;
}

/* good */
div {
  text-shadow: 0 1px 0 #fff;
}
</code></pre>

<h4 id="brevity">简洁（Brevity）</h4>

<p>Keep your code terse. Use shorthand properties and avoid using multiple properties when it's not needed. <br>
保持代码的简洁。使用简写的属性，不必要时避免使用多重属性。</p>

<pre><code>/* bad */
div {
  transition: all 1s;
  top: 50%;
  margin-top: -10px;
  padding-top: 5px;
  padding-right: 10px;
  padding-bottom: 20px;
  padding-left: 10px;
}

/* good */
div {
  transition: 1s;
  top: calc(50% - 10px);
  padding: 5px 10px 20px;
}
</code></pre>

<h4 id="language">语言（Language）</h4>

<p>Prefer English over math.</p>

<pre><code>/* bad */
:nth-child(2n + 1) {
  transform: rotate(360deg);
}

/* good */
:nth-child(odd) {
  transform: rotate(1turn);
}
</code></pre>

<h4 id="vendorprefixes">浏览器厂商前缀（Vendor prefixes）</h4>

<p>Kill obsolete vendor prefixes aggressively. If you need to use them, insert them before the standard property. <br>
竭力地干掉过时的浏览器前缀吧！必须使用的话，把它们写在标准属性前。</p>

<pre><code>/* bad */
div {
  transform: scale(2);
  -webkit-transform: scale(2);
  -moz-transform: scale(2);
  -ms-transform: scale(2);
  transition: 1s;
  -webkit-transition: 1s;
  -moz-transition: 1s;
  -ms-transition: 1s;
}

/* good */
div {
  -webkit-transform: scale(2);
  transform: scale(2);
  transition: 1s;
}
</code></pre>

<h4 id="animation">动画（Animation）</h4>

<p>Favor transitions over animations. Avoid animating other properties than opacity and transform. <br>
除了<code>opacity</code> 和 <code>transform</code> 两属性，其他尽量使用<code>transition</code>，而不是<code>animation</code>。</p>

<h4 id="units">单位（Units）</h4>

<p>能不带单位就不带单位。相对单位多用<code>rem</code>。多用<code>s</code>而不是<code>ms</code>。（<strong>why?</strong>）</p>

<pre><code>/* bad */
div {
  margin: 0px;
  font-size: .9em;
  line-height: 22px;
  transition: 500ms;
}

/* good */
div {
  margin: 0;
  font-size: .9rem;
  line-height: 1.5;
  transition: .5s;
}
</code></pre>

<h4 id="colors">颜色（Colors）</h4>

<p>需要改变透明度（transparency）时，使用<code>rgba</code>。否则永远使用十六进制值（hexadecimal format）。</p>

<pre><code>/* bad */
div {
  color: hsl(103, 54%, 43%);
}

/* good */
div {
  color: #5a3;
}
</code></pre>

<h4 id="drawing">绘图（Drawing）</h4>

<p>资源使用CSS绘图替代的话可以避免HTTP请求。</p>

<pre><code>/* bad */
div::before {
  content: url(white-circle.svg);
}

/* good */
div::before {
  content: "";
  display: block;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #fff;
}
</code></pre>

<h4 id="hacks">技巧（Hacks）</h4>

<p>别用。</p>

<pre><code>/* bad */
div {
  // position: relative;
  transform: translateZ(0);
}

/* good */
div {
  /* position: relative; */
  will-change: transform;
}
</code></pre>

<h2 id="javascript">JavaScript</h2>

<hr>

<h4 id="performance">性能（Performance）</h4>

<p>Favor readability, correctness and expressiveness over performance. JavaScript will basically never be your performance bottleneck. Optimize things like image compression, network access and DOM reflows instead. If you remember just one guideline from this document, choose this one. <br>
易读性、正确性、富有表现性比性能更重要。从根本上来说，JavaScript绝对不会成为性能瓶颈，应该优化图像压缩、网络连接和DOM刷新。如果你只记得这篇文档的一条规则，那就选择这条吧。</p>

<pre><code class="language-javascript    ">    // bad (albeit way faster)
    const arr = [1, 2, 3, 4];
    const len = arr.length;
    var i = -1;
    var result = [];
    while (++i &lt; len) {
      var n = arr[i];
      if (n % 2 &gt; 0) continue;
      result.push(n * n);
    }

    // good
    const arr = [1, 2, 3, 4];
    const isEven = n =&gt; n % 2 == 0;
    const square = n =&gt; n * n;

    const result = arr.filter(isEven).map(square);
</code></pre>

<h4 id="statelessness">无国籍？（Statelessness）</h4>

<p>Try to keep your functions pure. All functions should ideally produce no side-effects, use no outside data and return new objects instead of mutating existing ones. <br>
尽量使函数纯粹。理想情况下，所有的函数都不会产生副作用，不使用外部的数据，返回新的对象而不是在现有对象上作修改。</p>

<pre><code class="language-javascript">// bad
const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);  
merge({ foo: "foo" }, { bar: "bar" }); // =&gt; { foo: "foo", bar: "bar" }

// good
const merge = (...sources) =&gt; Object.assign({}, ...sources);  
merge({ foo: "foo" }, { bar: "bar" }); // =&gt; { foo: "foo", bar: "bar" }  
</code></pre>

<h4 id="natives">原生（Natives）</h4>

<p>尽可能使用原生方法。</p>

<pre><code class="language-javascript">// bad
const toArray = obj =&gt; [].slice.call(obj);

// good
const toArray = (() =&gt;  
  Array.from ? Array.from : obj =&gt; [].slice.call(obj)
)();
</code></pre>

<h4 id="coercion">强制转换（Coercion）</h4>

<p>有意义的时候就尽情使用「隐式类型转换」（imolicit coercion）吧，不然就别碰它。Don't cargo-cult. （别太草包，要灵活变通？）</p>

<pre><code class="language-javascript    ">    // bad
    if (x === undefined || x === null) { ... }

    // good
    if (x == undefined) { ... }
</code></pre>

<h4 id="loops">循环（Loops）</h4>

<p>Don't use loops as they force you to use mutable objects. Rely on <code>array.prototype</code> methods. <br>
不要使用循环因为它强制你使用可变的对象。使用<code>array.prototype</code>方法。</p>

<pre><code class="language-javascript    ">    // bad
    const sum = arr =&gt; {
      var sum = 0;
      var i = -1;
      for (;arr[++i];) {
        sum += arr[i];
      }
      return sum;
    };

    sum([1, 2, 3]); // =&gt; 6

    // good
    const sum = arr =&gt;
      arr.reduce((x, y) =&gt; x + y);

    sum([1, 2, 3]); // =&gt; 6
</code></pre>

<p>If you can't, or if using <code>array.prototype</code> methods is arguably abusive, use recursion. <br>
不能或者说觉得 <code>array.prototype</code> 被滥用，就用递归（recursion）。</p>

<pre><code class="language-javascript    ">    // bad
    const createDivs = howMany =&gt; {
      while (howMany--) {
        document.body.insertAdjacentHTML("beforeend", "&lt;div&gt;&lt;/div&gt;");
      }
    };
    createDivs(5);

    // bad
    const createDivs = howMany =&gt;
      [...Array(howMany)].forEach(() =&gt;
        document.body.insertAdjacentHTML("beforeend", "&lt;div&gt;&lt;/div&gt;")
      );
    createDivs(5);

    // good
    const createDivs = howMany =&gt; {
      if (!howMany) return;
      document.body.insertAdjacentHTML("beforeend", "&lt;div&gt;&lt;/div&gt;");
      return createDivs(howMany - 1);
    };
    createDivs(5);
</code></pre>

<h4 id="arguments">参数（Arguments）</h4>

<p>Forget about the <code>arguments</code> object. The rest parameter is always a better option because:</p>

<ol>
<li>it's named, so it gives you a better idea of the arguments the function is expecting  </li>
<li>it's a real array, which makes it easier to use. <br>
忘掉 <code>arguments</code> 对象吧。参数名（rest parameter）总是个更好的选择。原因如下：</li>
<li>命名的参数能让你更好理解这个函数期待输入的参数；  </li>
<li>命名的参数是一个真正的数组，这样使用它更容易。  </li>
</ol>

<pre><code class="language-javascript">        // bad
        const sortNumbers = () =&gt;
            Array.prototype.slice.call(arguments).sort();

        // good
        const sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre>

<h4 id="apply">Apply</h4>

<p>忘掉<code>apply()</code>吧，使用更广泛的操作符（spread operator）。</p>

<pre><code class="language-javascript        ">    const greet = (first, last) =&gt; `Hi ${first} ${last}`;
    const person = ["John", "Doe"];

    // bad
    greet.apply(null, person);

    // good
    greet(...person);
</code></pre>

<h4 id="bind">Bind</h4>

<p>Don't <code>bind()</code> when there's a more idiomatic  approach. <br>
有更符合语言习惯的方法的时候，不要用<code>bind()</code>。</p>

<pre><code class="language-javascript">    // bad
    ["foo", "bar"].forEach(func.bind(this));

    // good
    ["foo", "bar"].forEach(func, this);

    // bad
    const person = {
      first: "John",
      last: "Doe",
      greet() {
        const full = function() {
          return `${this.first} ${this.last}`;
        }.bind(this);
        return `Hello ${full()}`;
      }
    }

    // good
    const person = {
      first: "John",
      last: "Doe",
      greet() {
        const full = () =&gt; `${this.first} ${this.last}`;
        return `Hello ${full()}`;
      }
    }
</code></pre>

<h4 id="higherorderfunctions">高阶函数（Higher-order functions）</h4>

<p>尽量不要嵌套函数（nesting functions）。</p>

<pre><code class="language-javascript">    // bad
    [1, 2, 3].map(num =&gt; String(num));

    // good
    [1, 2, 3].map(String);
</code></pre>

<h4 id="composition">组合（Composition）</h4>

<p>Avoid multiple nested function calls. Use composition instead. <br>
 避免多重嵌套的函数调用。改用<code>composition</code>。</p>

<pre><code class="language-javascript ">    const plus1 = a =&gt; a + 1;
    const mult2 = a =&gt; a * 2;

    // bad
    mult2(plus1(5)); // =&gt; 12

    // good
    const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);
    const addThenMult = pipeline(plus1, mult2);
    addThenMult(5); // =&gt; 12
</code></pre>

<h4 id="caching">缓存（Caching）</h4>

<p>Cache feature tests, large data structures and any expensive operation. <br>
将重要的测试、大块的数据结构或者任何高代价的运算操作都缓存起来。  </p>

<pre><code class="language-javascript    ">    // bad
    const contains = (arr, value) =&gt;
      Array.prototype.includes
        ? arr.includes(value)
        : arr.some(el =&gt; el === value);
    contains(["foo", "bar"], "baz"); // =&gt; false

    // good
    const contains = (() =&gt;
      Array.prototype.includes
        ? (arr, value) =&gt; arr.includes(value)
        : (arr, value) =&gt; arr.some(el =&gt; el === value)
    )();
    contains(["foo", "bar"], "baz"); // =&gt; false
</code></pre>

<h4 id="variables">变量（Variables）</h4>

<p>Favor const over let and let over var. <br>
优先级：<code>const</code> &gt; <code>let</code> &gt; <code>var</code>  </p>

<pre><code class="language-javascript">    // bad
    var obj = {};
    obj["foo" + "bar"] = "baz";

    // good
    const obj = {
      ["foo" + "bar"]: "baz"
    };
</code></pre>

<h4 id="conditions">条件（Conditions）</h4>

<p>Favor IIFE's and return statements over if, else if, else and switch statements. <br>
优先级：<code>IIFE</code>+ <code>return</code> &gt; <code>if</code> + <code>else if</code> + <code>switch</code> <br>
<em>译注：<code>IIFE</code>： Immediately-invoked function expression，立即调用的函数表达式；</em></p>

<pre><code class="language-javascript    ">    // bad
    var grade;
    if (result &lt; 50)
      grade = "bad";
    else if (result &lt; 90)
      grade = "good";
    else
      grade = "excellent";

    // good
    const grade = (() =&gt; {
      if (result &lt; 50)
        return "bad";
      if (result &lt; 90)
        return "good";
      return "excellent";
    })();
</code></pre>

<pre><code>
</code></pre>

<h4 id="objectiteration">对象迭代（Object iteration）</h4>

<p>Avoid for...in when you can. <br>
避免使用<code>for-in</code></p>

<pre><code class="language-javascript">    const shared = { foo: "foo" };
    const obj = Object.create(shared, {
      bar: {
        value: "bar",
        enumerable: true
      }
    });

    // bad
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop))
        console.log(prop);
    }

    // good
    Object.keys(obj).forEach(prop =&gt; console.log(prop));
</code></pre>

<h4 id="objectsasmaps">Objects as Maps</h4>

<p>While objects have legitimate use cases, maps are usually a better, more powerful choice. When in doubt, use a Map. <br>
尽管<code>objects</code>有些好的使用案例，但<code>maps</code>通常是一种更好更强大的选择。</p>

<pre><code class="language-javascript">    // bad
    const me = {
      name: "Ben",
      age: 30
    };
    var meSize = Object.keys(me).length;
    meSize; // =&gt; 2
    me.country = "Belgium";
    meSize++;
    meSize; // =&gt; 3

    // good
    const me = Map();
    me.set("name", "Ben");
    me.set("age", 30);
    me.size; // =&gt; 2
    me.set("country", "Belgium");
    me.size; // =&gt; 3
</code></pre>

<h4 id="curry">柯里化（Curry）</h4>

<p>Currying might have its place in other languages, but avoid it in JavaScript. It makes your code harder to read by introducing a foreign paradigm while the appropriate use cases are extremely unusual. <br>
在其他语言中，柯里化可能有它的一席之地，但是不要在 JavaScript 中使用它。因为它引入了很少能见到正确使用的非自身范例（foreign paradigm），这会让你的代码阅读困难。</p>

<pre><code class="language-javascript">    // bad
    const sum = a =&gt; b =&gt; a + b;
    sum(5)(3); // =&gt; 8

    // good
    const sum = (a, b) =&gt; a + b;
    sum(5, 3); // =&gt; 8
</code></pre>

<h4 id="readability">可读性（Readability）</h4>

<p>Don't obfuscate the intent of your code by using seemingly smart tricks. <br>
别用些自作聪明的小把戏混淆了你代码真正的意图。</p>

<pre><code class="language-javascript">    // bad
    foo || doSomething();

    // good
    if (!foo) doSomething();
</code></pre>

<pre><code class="language-javascript">    // bad
    void function() { /* IIFE */ }();

    // good
    (function() { /* IIFE */ }());
</code></pre>

<pre><code class="language-javascript">    // bad
    const n = ~~3.14;

    // good
    const n = Math.floor(3.14);
</code></pre>

<h4 id="codereuse">代码复用（Code reuse）</h4>

<p>Don't be afraid of creating lots of small, highly composable and reusable functions. <br>
尽管去写些短小精悍、组件化、高度复用的函数。</p>

<pre><code class="language-javascript">    // bad
    arr[arr.length - 1];
</code></pre>

<pre><code class="language-javascript">    // good
    const first = arr =&gt; arr[0];
    const last = arr =&gt; first(arr.slice(-1));
    last(arr);
</code></pre>

<pre><code class="language-javascript">    // bad
    const product = (a, b) =&gt; a * b;
    const triple = n =&gt; n * 3;

    // good
    const product = (a, b) =&gt; a * b;
    const triple = product.bind(null, 3);
</code></pre>

<h4 id="dependencies">依赖（Dependencies）</h4>

<p>Minimize dependencies. Third-party is code you don't know. Don't load an entire library for just a couple of methods easily replicable: <br>
精简依赖。你都不知道第三方有些什么代码。
能自己写些简单方法替代就别载入整个库。</p>

<pre><code class="language-javascript">    // bad
    var _ = require("underscore");
    _.compact(["foo", 0]));
    _.unique(["foo", "foo"]);
    _.union(["foo"], ["bar"], ["foo"]);

    // good
    const compact = arr =&gt; arr.filter(el =&gt; el);
    const unique = arr =&gt; [...Set(arr)];
    const union = (...arr) =&gt; unique([].concat(...arr));

    compact(["foo", 0]);
    unique(["foo", "foo"]);
    union(["foo"], ["bar"], ["foo"]);
</code></pre>

<hr>

<p>END</p>
        

        <footer class="post-footer">


            <figure class="author-image">
                <a class="img" href="../author/zbl/" style="background-image: url(../content/images/2016/12/pigeon.JPG)"><span class="hidden">ZBL's Picture</span></a>
            </figure>

            <section class="author">
                <h4><a href="../author/zbl/">ZBL</a></h4>

                    <p>I'm what I'm.</p>
                <div class="author-meta">
                    <span class="author-location icon-location">Beijing</span>
                    
                </div>
            </section>


            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="https://twitter.com/intent/tweet?text=%E3%80%8C%E8%AF%91%E3%80%8D%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A0%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5&amp;url=http://localhost:2368/frontend-guidelines/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:2368/frontend-guidelines/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=http://localhost:2368/frontend-guidelines/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>


        </footer>

    


<aside class="read-next">
    <a class="read-next-story no-cover" href="../alibaba-interview-thoughts/">
        <section class="post">
            <h2>Ali校招笔试题思考</h2>
            <p>昨晚搭着末班车，参加了阿里今年的实习生在线笔试。  回忆之前惨不忍睹的内推面试，玩了整整一个寒假后接到了不期而至的面试电话，连之前一些基础的还算熟悉的题都答得不流畅自然一气呵成，我就知道我悲剧了。  痛定思痛，作为一个即将毕业的大四老鸟（只是说年龄...)，在被各种鄙视，各种蜚语，各种不确定存在的黑暗时期，依旧不屈不挠地学习思考着，我都要被自己感动了。  笔试题只有一个小时，13道题，一开始是单项选择和不定项选择，考了AMD编码规范、闭包、…</p>
        </section>
    </a>
    <a class="read-next-story prev no-cover" href="../html5-data-attributes/">
        <section class="post">
            <h2>拓展HTML5之data元素与自定义data属性</h2>
            <p>如我们所知，HTML5中已经有了一大堆很好的新语义化元素，如&lt;article&gt;和&lt;time&gt;等，但有时我们仍然会发现可能没有一个能正确表示语义含义的元素。我们希望能给我们提供一些可进行拓展的方式——以便添加浏览器、脚本甚至机器人都可以使用的机器可读数据。所以这可能涉及添加JavaScript使用的元数据，给HTML5元素添加额外语义，乃至添加当前尚未涉及的全新语义化数据。  我们知道HTML4中有5种基本的拓展方法：…</p>
        </section>
    </a>
</aside>



        <footer class="site-footer clearfix">
            <section class="copyright"><a href="http://localhost:2368">ZBL's Doodles</a> © 2016</section>
            <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a></section>
        </footer>

    </div>

    <script type="text/javascript" src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
    
    <script type="text/javascript" src="../assets/js/jquery.fitvids.js?v=abcbb21028"></script>
    <script type="text/javascript" src="../assets/js/index.js?v=abcbb21028"></script>

</li></ul></section></article></main></div></body>
