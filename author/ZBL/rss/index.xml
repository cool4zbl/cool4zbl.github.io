<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[ZBL - ZBL's Doodle]]></title><description><![CDATA[Thoughts, ideas]]></description><link>http://zhangbinliu.me/</link><generator>Ghost</generator><lastBuildDate>Wed, 02 Aug 2017 17:21:04 GMT</lastBuildDate><atom:link href="http://zhangbinliu.me/author/ZBL/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[从十个 React 迷你设计模式谈开去]]></title><description><![CDATA[<p>很早之前就一直在读的一篇文章，<a href="https://hackernoon.com/10-react-mini-patterns-c1da92f068c5">10 个React Mini 设计模式</a>，
一边做 <code>Creator</code> 项目，也一边终于把它精读完。
结合自己的开发时候的项目经验，做了点笔记。
<code>Creator</code> 项目是一个多端（Web + Mobile）React SPA，且有一些表单填写和复杂的交互组件，自己单独封装了一个很简单的基于事件的 <code>Store</code>，开发过程中收获很大，这些细节之后可以细说。</p>
<p>原文作者说你是不是天天写 React, 写着写着发现自己可能经常用来实现需求的，也总是那么几个方法，往大了讲其实就是开发中的 <strong>设计模式</strong>。但是这里我们称为 <strong>Mini Patterns</strong>。</p>
<h2 id="-1-sending-data-down-and-up">#1 Sending data down and up</h2>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*J5XOQh2WKIl0NFTAMvcVbQ.png" alt="Data-flow"></p>
<ul>
<li>React 数据流</li>
<li>ParentComponent  通过 <code>props</code> 传给 ChildComponent 值</li>
<li>ChildComponent 通过 <code>props</code> 传过来的一些 function 回调 parent 的一些方法。</li>
</ul>
<h2 id="-2-fixing-html-s-inputs">#2 Fixing HTML’s inputs</h2>
<blockquote>
<p>If I’m building a site that will have a lot of user inputs, one of the first things I do is fix this.</p>
<p>You don’t need to keep working with the somewhat ass-about nature of HTML’s user input elements.</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/800/1*WTUJjlFOOnetc5NpbykN0w.png" alt="User Inputs"></p>
<ul>
<li><p>如果需要有大量 user inputs，最好是自己实现一套相关组件。</p>
</li>
<li><p>所以在 Creator 中基本自己实现了 <code>input</code>，<code>Select</code> 等组件。需求简单所以实现得也是很简单。所以其实 <code>Select</code> 组件仍然需要优化，比如自定义 <code>option</code> 样式，多选等等。</p>
</li>
<li><p>Inputs should return a value via an <code>onChange</code> method, not a JavaScript <code>Event</code> instance, shouldn’t they?</p>
</li>
<li><p>Input 最好通过 <code>onChange</code> 返回一个值，而不是通过一个 JS <code>Event</code> 实例。</p>
</li>
<li><p>You can go a step further and ensure that the data type returned in <code>onChange</code> matches the type passed in. If the <code>typeof props.value</code> is <code>number</code>, then convert <code>e.target.value</code> back to a number before sending the data out again.</p>
</li>
<li><p>在返回 <code>onChange</code> 的值之前确保一下是不是和输入的类型匹配。比如 <code>typeof props.value === &#39;number&#39;</code> 的话，在返回 <code>e.target.value</code> 前需要确保也是数字类型。</p>
</li>
<li><p>这里项目中有个选择证件类型的 <code>Select</code>，与后端默认 身份证 = 0 / 护照 = 1，但是在 <code>e.target.value</code> 时候忘记 convert 了。所以还是需要记得判断下 <code>option</code> 的值类型。</p>
<pre class="hljs"><code>let {<span class="hljs-keyword">name</span>, <span class="hljs-keyword">value</span>} = e.<span class="hljs-type">target</span>
<span class="hljs-keyword">value</span> = isNaN(<span class="hljs-keyword">Number</span>(<span class="hljs-keyword">value</span>)) ? <span class="hljs-keyword">value</span> : <span class="hljs-keyword">Number</span>(<span class="hljs-keyword">value</span>)</code></pre><p>​</p>
</li>
<li><p>A set of radio buttons is functionally the same thing as a <code>&lt;select&gt;</code>, right? It’s messed up to treat them in a completely different manner when the only difference is the UI. Maybe for your app it makes sense to have a single <code>&lt;PickOneFromMany /&gt;</code> component and pass either <code>ui=&quot;radio&quot;</code> or <code>ui=&quot;dropDown&quot;</code>.</p>
</li>
<li><p>一堆单选按钮在功能上和一个 <code>&lt;select&gt;</code> 组件是一样的。没有必要把它们完全不一样地来对待，因为它们仅仅是 UI 不一样。其实可能只需要一个 <code>&lt;PickOneFromMany /&gt;</code> 组件就好，通过 <code>ui=&quot;radio&quot;</code> 或者<code>ui=&quot;dropdown&quot;</code> 来区分。</p>
</li>
<li><p><strong>React Form 与 HTML 的不同</strong></p>
</li>
<li><p><code>value/checked</code> 设置后用户输入无效，相当于设置了 value -&gt; controlled component.</p>
</li>
<li><p><code>textarea</code> 的值要设置在 value 属性</p>
</li>
<li><p><code>select</code> 的<code>value</code> 属性可以是数组，不建议使用 <code>option</code> 的 <code>selected</code> 属性</p>
</li>
<li><p><code>input/textarea</code> 的 <code>onChange</code> 每次输入都会触发，即使不失去焦点</p>
</li>
<li><p><code>radio/checkbox</code>  点击后触发 `onChange</p>
</li>
</ul>
<h2 id="-3-binding-labels-to-inputs-with-unique-ids">#3 Binding labels to inputs with unique IDs</h2>
<blockquote>
<p>if you care about your users, you’ll bind your <code>&lt;label&gt;</code> elements to your <code>&lt;input&gt;</code>s via an <code>id</code>/<code>for</code> combo.</p>
<p>You <em>could</em> generate a random ID for each input/label pair, but then your client-rendered HTML won’t match your server-rendered HTML. Checksum error! That’s no good.</p>
<p>So, instead you can create a little module that gives an incrementing ID, and use that in an <code>Input</code> component like so:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Input Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.id = getNextId();

    <span class="hljs-keyword">this</span>.onChange = <span class="hljs-keyword">this</span>.onChange.bind(<span class="hljs-keyword">this</span>);
  }

  onChange(e) {
    <span class="hljs-keyword">this</span>.props.onChange(e.target.value);
  }

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;label htmlFor={<span class="hljs-keyword">this</span>.id}&gt;
        {<span class="hljs-keyword">this</span>.props.label}

        &lt;input
          id={<span class="hljs-keyword">this</span>.id}
          value={<span class="hljs-keyword">this</span>.props.value}
          onChange={<span class="hljs-keyword">this</span>.onChange}
          /&gt;
      &lt;/label&gt;
    );
  }
}

<span class="hljs-comment">// elementIdCreator.js</span>
let count = <span class="hljs-number">1</span>;

export const resetId = () =&gt; {
  count = <span class="hljs-number">1</span>;
}

export const getNextId = () =&gt; {
  <span class="hljs-keyword">return</span> <code>element-id-${count++}</code>;
}</code></pre><ul>
<li>这里大概是自动给 <code>label</code>/<code>input</code> 加上一对一的 id.</li>
<li>Creator 中好像没有这样使用。</li>
</ul>
<h2 id="-4-controlling-css-with-props">#4 Controlling CSS with props</h2>
<p>Three distinct ways to control the CSS applied to a component.</p>
<ol>
<li><p>Using themes. (Used in Proj Creator)</p>
<p><code>&lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt;</code></p>
<p>Tip: Do your best to only require one theme per component.</p>
<p>这种可能适合页面主题定制化。</p>
<p>Creator 中的 <code>&lt;Button /&gt;</code> 本来是用 theme 做区分，但是好像设计那边看起来就是一个主题，豆瓣绿经典款，所以后来改为了使用下面两种方式。</p>
<p>​</p>
</li>
<li><p>Using flags. (Used too.)</p>
<p><code>&lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt;</code></p>
<p>Creator Project:</p>
<p>```jsx
Button.propTypes = {
  size: PropTypes.oneOf([</p>
<pre class="hljs"><code><span class="hljs-string">&#39;sm&#39;</span>,
<span class="hljs-string">&#39;md&#39;</span>,
<span class="hljs-string">&#39;lg&#39;</span>,
<span class="hljs-string">&#39;row&#39;</span></code></pre><p>  ]),
  status: PropTypes.oneOf(Object.values(BUTTON_STATUS)),
  type: PropTypes.oneOf([</p>
<pre class="hljs"><code><span class="hljs-string">&#39;submit&#39;</span>,
<span class="hljs-string">&#39;save&#39;</span>,
<span class="hljs-string">&#39;cancel&#39;</span>
])</code></pre><p>}</p>
</li>
</ol>
<p>   // use className to control styles</p>
<pre class="hljs"><code> <span class="hljs-keyword">const</span> cls = classNames(<span class="hljs-string">&#39;btn&#39;</span>, {
   [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn</code></span>]: <span class="hljs-literal">true</span>,
   [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${size}&lt;/span&gt;</code></span>]: !!size,
   [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${status}&lt;/span&gt;</code></span>]: !!status,
   [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${type}&lt;/span&gt;</code></span>]: !!type
 }, props.className)</code></pre><pre class="hljs"><code>
   ​

<span class="hljs-number">3.</span> Setting values.

   Pass the <span class="hljs-keyword">value</span> of a CSS property directly. (<span class="hljs-keyword">set</span> it <span class="hljs-keyword">as</span> an inline style)

   <code>&amp;lt;Icon width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;25&quot;&lt;/span&gt; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;25&quot;&lt;/span&gt; type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;search&quot;&lt;/span&gt; /&amp;gt;</code>

   <span class="hljs-preprocessor">### An example</span>

   <img src="https:&lt;span class=&quot;hljs-comment&quot;&gt;//cdn-images-1.medium.com/max/800/1*Kx1jOQONhFZPnGe72Fd4tQ.png" alt="creating-a-link-component"></span>

   <code>``jsx
   &lt;span class=&quot;hljs-comment&quot;&gt;// Link.js&lt;/span&gt;
   &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Link = (props) =&amp;gt; {
     &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; className =</code>link link--${props.theme}-theme`;

     <span class="hljs-keyword">if</span> (!props.underline) className += <span class="hljs-string">&#39; link--no-underline&#39;</span>;

     <span class="hljs-keyword">return</span> &lt;a href={props.href} className={className}&gt;{props.children}&lt;/a&gt;;
   };

   Link.propTypes = {
     theme: PropTypes.oneOf([
       <span class="hljs-string">&#39;default&#39;</span>, <span class="hljs-comment">// primary color, no underline</span>
       <span class="hljs-string">&#39;blend&#39;</span>, <span class="hljs-comment">// inherit surrounding styles</span>
       <span class="hljs-string">&#39;primary-button&#39;</span>, <span class="hljs-comment">// primary color, solid block</span>
     ]),
     underline: PropTypes.<span class="hljs-keyword">bool</span>,
     href: PropTypes.<span class="hljs-keyword">string</span>.isRequired,
     children: PropTypes.oneOfType([
       PropTypes.element,
       PropTypes.array,
       PropTypes.<span class="hljs-keyword">string</span>,
     ]).isRequired,
   };

   Link.defaultProps = {
     theme: <span class="hljs-string">&#39;default&#39;</span>,
     underline: <span class="hljs-keyword">false</span>,
   };</code></pre><pre class="hljs"><code>   <span class="hljs-comment">// Link.css</span>
   <span class="hljs-class">.link--default-theme</span>,
   <span class="hljs-class">.link--blend-theme</span><span class="hljs-pseudo">:hover</span> {
     <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#D84315</span>;
   }

   <span class="hljs-class">.link--blend-theme</span> {
     <span class="hljs-attribute">color</span>: inherit;
   }

   <span class="hljs-class">.link--default-theme</span><span class="hljs-pseudo">:hover</span>,
   <span class="hljs-class">.link--blend-theme</span><span class="hljs-pseudo">:hover</span> {
     <span class="hljs-attribute">text-decoration</span>: underline;
   }

   <span class="hljs-class">.link--primary-button-theme</span> {
     <span class="hljs-attribute">display</span>: inline-block;
     <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span> <span class="hljs-number">25px</span>;
     <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;
     <span class="hljs-attribute">background</span>: <span class="hljs-hexcolor">#D84315</span>;
     <span class="hljs-attribute">color</span>: white;
   }

   <span class="hljs-class">.link--no-underline</span> {
     <span class="hljs-attribute">text-decoration</span>: none;
   }</code></pre><p>   ​</p>
<blockquote>
<p>JavaScript is easy, but with CSS you pay for your sins — once you’ve started a mess, it’s not easy to back out of.</p>
<p>True fact: fighting CSS specificity is the number one cause of death among web developers.</p>
</blockquote>
<p>   嗯，这里原文作者用 CSS specificity 优先级举了个例子。比如他说你现在可以去看看 medium 顶端导航上大 Title 的CSS 样式，</p>
<blockquote>
<p>just guess how many CSS rules are combined to make this round circle with a number in it?</p>
<p>Twenty three rules.</p>
<p>That’s <em>not </em>including the styles inherited from eleven other rules.</p>
<p>The line-height alone is overridden nine times.</p>
</blockquote>
<p>   光是 <code>line-height</code> 特么的就重写了九次！！！</p>
<p>   <img src="https://cdn-images-1.medium.com/max/800/1*lQzlIf8PPqeLUS5VOvTH4Q.png" alt="line-height-css-rules"></p>
<p>   ​</p>
<p>   这 line-height 要是一只猫的话，现在也早死了吧。</p>
<p>   React 的话，就好办了。</p>
<ul>
<li>控制组件的 classes ；</li>
<li>移掉所有的全局 resets 然后都把它们扔到 Button.scss 中；</li>
<li>可以用 <code>all: unset</code> 去掉所有浏览器初始样式。</li>
</ul>
<h2 id="-5-the-switching-component">#5 The switching component</h2>
<p>The switching component, rendering one of many components.</p>
<blockquote>
<p>This may be a <code>&lt;Page&gt;</code> component that displays one of many pages. Or tabs in a tab set, or different modals in a modal component.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">import</span> HomePage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./HomePage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> AboutPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./AboutPage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> UserPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./UserPage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> FourOhFourPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./FourOhFourPage.jsx&#39;</span>;

<span class="hljs-keyword">const</span> PAGES = {
  home: HomePage,
  about: AboutPage,
  user: UserPage,
};

<span class="hljs-keyword">const</span> Page = (props) =&gt; {
  <span class="hljs-keyword">const</span> Handler = PAGES[props.page] || FourOhFourPage;

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Handler</span> {<span class="hljs-attribute">...props</span>} /&gt;</span>
};

Page.propTypes = {
    page: PropTypes.oneOf(Object.keys(PAGES)).isRequired,
};

// Usage

<span class="hljs-tag">&lt;<span class="hljs-title">Page</span> <span class="hljs-attribute">page</span>=<span class="hljs-value">&quot;home&quot;</span> /&gt;</span></span></code></pre><p>If you replace the keys <code>home</code>, <code>about</code> and <code>user</code> with <code>/</code>, <code>/about</code>, and <code>/user</code>, you’ve got yourself half a router.</p>
<p>(Future post idea: removing <code>react-router</code>.)</p>
<p>这里 Creator 中还是使用了 <code>react-router</code> 作为 SPA 路由。</p>
<pre class="hljs"><code><span class="hljs-regexp">//</span> Route.jsx
import React from <span class="hljs-string">&#39;react&#39;</span>
import IntroPage from <span class="hljs-string">&#39;../Page/IntroPage&#39;</span>
import ApplyFormPage from <span class="hljs-string">&#39;../Page/ApplyFormPage&#39;</span>
import AddWorksPage from <span class="hljs-string">&#39;../Page/AddWorksPage&#39;</span>
import ApplyDonePage from <span class="hljs-string">&#39;../Page/ApplyDonePage&#39;</span>
import MyWorksPage from <span class="hljs-string">&#39;../Page/MyWorksPage&#39;</span>

const defaultHeader = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &lt;h1&gt;创作者认证申请&lt;/h1&gt;
const routes = [
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/&#39;</span>,
    <span class="hljs-attribute">exact</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;IntroPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/intro&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;IntroPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step1&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;ApplyFormPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step2&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;AddWorksPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step3&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;ApplyDonePage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/myworks&#39;</span>,
    <span class="hljs-attribute">header</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &lt;h1&gt;管理我的作品&lt;/h1&gt;,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;MyWorksPage /&gt;)
  }
]
export default routes</code></pre><pre class="hljs"><code>// App.js
import {
  HashRouter,
  Route
} from &#39;react-router-dom&#39;
import routes from &#39;./Route&#39;

const App = () =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-title">HashRouter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;App&#39;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">&#39;creator-wrapper&#39;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;header&#39;</span>&gt;</span>
          { routes.map((route, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-title">Route</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{index}</span> <span class="hljs-attribute">path</span>=<span class="hljs-value">{route.path}</span>
              <span class="hljs-attribute">exact</span>=<span class="hljs-value">{route.exact}</span>
              <span class="hljs-attribute">component</span>=<span class="hljs-value">{route.header}</span>
            /&gt;</span>
          )) }
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;main&#39;</span>&gt;</span>
          { routes.map((route, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-title">Route</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{index}</span> <span class="hljs-attribute">path</span>=<span class="hljs-value">{route.path}</span>
              <span class="hljs-attribute">exact</span>=<span class="hljs-value">{route.exact}</span>
              <span class="hljs-attribute">component</span>=<span class="hljs-value">{route.main}</span> /&gt;</span>
          )) }
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        { isMobile ? Footer() : Sidebar() }
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">HashRouter</span>&gt;</span>
)</code></pre><h2 id="-6-reaching-into-a-component">#6 Reaching into a component</h2>
<h3 id="render">render</h3>
<p>React Virtual DOM ==&gt; render= =&gt; DOM</p>
<pre class="hljs"><code>ReactComponent render(
  ReactElement <span class="hljs-keyword">element</span>,
  DOMElement container,
  [<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>]</span>
)</code></pre><blockquote>
<p>Render a ReactElement into the DOM in the supplied <code>container</code> and return a <a href="more-about-refs.html">reference</a> to the component (or returns <code>null</code> for <a href="reusable-components.html#stateless-functions">stateless components</a>).</p>
<p><code>ReactDOM.render()</code> controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React’s DOM diffing algorithm for efficient updates.</p>
</blockquote>
<ul>
<li><code>ReactElement</code> into DOM.</li>
<li>有状态组件 =&gt; <code>refs</code>，无状态组件 =&gt; <code>null</code></li>
<li>组件初次渲染之后再次更新，会使用 ReactDOM diffing algorithm</li>
<li>装载完后，执行回调 callback</li>
<li><code>ReactDOM.render()</code> 不会影响 container node，只会影响 container node 的 children nodes. （可能是被覆盖替换啊..）</li>
</ul>
<pre class="hljs"><code>const myApp = &lt;App /&gt;   <span class="hljs-comment">// just a ReactElement.(a object)</span>

const myAppInstance = ReactDOM.<span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">(&lt;App /&gt;, document.getElementById(<span class="hljs-string">&#39;root&#39;</span>)</span></span>)
myAppInstance.<span class="hljs-function"><span class="hljs-title">doSth</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// The ref returned from ReactDOM.render</span></code></pre><p>这里利用 <code>render</code> 方法得到了 App 组件的实例，就可以使用它做点什么了。</p>
<p>但是如果在组件内，JSX 并不会返回一个组件的实例。组件内只是一个 ReactElement，告诉 React 加载的组件应该长什么样。</p>
<blockquote>
<p>Keep in mind, however, that the JSX doesn&#39;t return a component instance! It&#39;s just a <strong>ReactElement</strong>: a lightweight representation that tells React what the mounted component should look like.</p>
</blockquote>
<h3 id="ref">ref</h3>
<p>一个神奇的属性。</p>
<h4 id="the-ref-callback-attribute">The ref Callback Attribute</h4>
<ul>
<li>可以给任意 React 组件加上 <code>ref</code> prop. 组件被调用时候会新建一个该组件实例，而 <code>ref</code> 会指向这个实例。</li>
</ul>
<ul>
<li><p>可以是一个 callback function，会在组件加载后立即执行。</p>
<pre class="hljs"><code>// <span class="hljs-type">ES5</span>

render: function() {
  <span class="hljs-keyword">return</span> (
    &lt;<span class="hljs-type">TextInput</span>
      <span class="hljs-keyword">ref</span>={function(input) {
        <span class="hljs-keyword">if</span> (input != null) {
          input.focus();
        }
      }} /&gt;
  );
},

// <span class="hljs-keyword">or</span> <span class="hljs-type">ES6</span> arrow function way:
render() {
  <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">TextInput</span> <span class="hljs-keyword">ref</span>={ c =&gt; this._input = c } /&gt;
}
componentDidMount() {
  this._input.focuse()
}</code></pre><p>​</p>
</li>
</ul>
<blockquote>
<p> When attaching a ref to a DOM component like <code>&lt;div /&gt;</code>, you get the DOM node back; when attaching a ref to a composite component like <code>&lt;TextInput /&gt;</code>, you&#39;ll get the React class instance.</p>
</blockquote>
<ul>
<li><code>refs</code> in <code>ReactComponent</code> =&gt; 得到 ReactComponent 实例，就可以调用相关实例方法了（继续 findDOMNode(refs) 就可以得到 DOM 节点，使用 DOM 方法）。</li>
<li><code>refs</code> in <code>DOM</code>  =&gt; 得到 DOM 节点，就可以使用 DOM 方法。</li>
<li><em>Note:</em> Note that when the referenced component is unmounted and whenever the ref changes, the old ref will be called with <code>null</code> as an argument. This prevents memory leaks in the case that the instance is stored, as in the first example. Also note that when writing refs with inline function expressions as in the examples here, React sees a different function object each time so on every update, ref will be called with <code>null</code> immediately before it&#39;s called with the component instance.</li>
<li>为防止内存泄露，当引用组件被卸载或者 <code>ref</code> 改变的时候，<code>ref = null</code>.</li>
<li>如果用 inline function，因为每次都是一个不同的 function object，所以当组件每次更新的时候，<code>ref</code> 都会被设置为 <code>null</code> 直到组件实例再次调用它。</li>
</ul>
<h4 id="the-ref-string-attribute-legacy">The ref String Attribute *legacy</h4>
<p>要获取一个 React 组件的引用，既可以使用 this 来获取当前 ReactComponent，也可以使用 <code>ref</code> 来获取子组件的引用。</p>
<pre class="hljs"><code>&lt;input <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;myInput&quot;</span> /&gt;

// used <span class="hljs-keyword">in</span> componentDidMount()
<span class="hljs-keyword">var</span> input = this.refs.myInput;
<span class="hljs-keyword">var</span> inputValue = input.value;
<span class="hljs-keyword">var</span> inputRect = input.getBoundingClientRect();</code></pre><h4 id="refs-">refs 使用</h4>
<ul>
<li>DOM 操作</li>
</ul>
<blockquote>
<p>Performing DOM measurements almost always requires reaching out to a &quot;native&quot; component such as <code>&lt;input /&gt;</code> and accessing its underlying DOM node using a ref. Refs are one of the only practical ways of doing this reliably.</p>
</blockquote>
<ul>
<li>对于 <code>stateless component</code>， <code>findDOMNode()</code> &amp; <code>ref</code> 返回的都是 <code>null</code>，因为它只是函数执行，并不返回一个实例 <code>a backing instance</code>。要用的话只能自己去手动包一层 component.</li>
</ul>
<h4 id="an-example">An example</h4>
<p>Like adding <code>autofucus</code> to the input to pease your users in an easy way.</p>
<p>The React Way</p>
<pre class="hljs"><code><span class="hljs-comment">// Child Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Compnent</span> {</span>
  focus() {
    <span class="hljs-keyword">this</span>.input.focus()
  }
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;input ref={(el)=&gt; <span class="hljs-keyword">this</span>.input = el} /&gt;
    )
  }
}

<span class="hljs-comment">// Parent Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SignInModal</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Component</span> {</span>
  componentDidMount() {
    <span class="hljs-keyword">this</span>.<span class="hljs-type">InputComponent</span>.focus(); <span class="hljs-comment">// 拿到 Input 组件的引用，就可以调用 Input 组件方法</span>
  }

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;
        &lt;label&gt;<span class="hljs-type">User</span> name: &lt;/label&gt;
        &lt;<span class="hljs-type">Input</span>
          ref={comp =&gt; { <span class="hljs-keyword">this</span>.<span class="hljs-type">InputComponent</span> = comp; }}
        /&gt;
      &lt;/div&gt;
    )
  }
}</code></pre><h2 id="-7-almost-components">#7 Almost-components</h2>
<blockquote>
<p>Don’t prematurely componentize. Components aren’t like teaspoons; you <em>can </em>have too many.</p>
<p>What I am saying: “take something that you <em>don’t</em> think should be a component, and make it a bit more like its own component (if it can be).”</p>
</blockquote>
<p>让那些你认为不应该成为一个组件的东西，长得更像组件一点（如果它可以的话）。</p>
<h2 id="-8-components-for-formatting-text">#8 Components for formatting text</h2>
<p>用来格式化的组件，也就是组件也可以工具化。</p>
<pre class="hljs"><code><span class="hljs-comment">// Here’s a &lt;Price&gt; component that takes a number and returns a pretty string, with or without decimals and a ‘$’ sign.</span>

<span class="hljs-keyword">const</span> Price = (props) =&gt; {
    <span class="hljs-keyword">const</span> price = props.children.toLocaleString(<span class="hljs-string">&#39;en&#39;</span>, {
      style: props.showSymbol ? <span class="hljs-string">&#39;currency&#39;</span> : undefined,
      currency: props.showSymbol ? <span class="hljs-string">&#39;USD&#39;</span> : undefined,
      maximumFractionDigits: props.showDecimals ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>,
    });

    <span class="hljs-keyword">return</span> &lt;span className={props.className}&gt;{price}&lt;/span&gt;
};

Price.propTypes = {
  className: React.PropTypes.string,
  children: React.PropTypes.number,
  showDecimals: React.PropTypes.<span class="hljs-built_in">bool</span>,
  showSymbol: React.PropTypes.<span class="hljs-built_in">bool</span>,
};

Price.defaultProps = {
  children: <span class="hljs-number">0</span>,
  showDecimals: <span class="hljs-keyword">true</span>,
  showSymbol: <span class="hljs-keyword">true</span>,
};

<span class="hljs-keyword">const</span> Page = () =&gt; {
  <span class="hljs-keyword">const</span> lambPrice = <span class="hljs-number">1234.567</span>;
  <span class="hljs-keyword">const</span> jetPrice = <span class="hljs-number">999999.99</span>;
  <span class="hljs-keyword">const</span> bootPrice = <span class="hljs-number">34.567</span>;

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;p&gt;One lamb <span class="hljs-keyword">is</span> &lt;Price className=<span class="hljs-string">&quot;expensive&quot;</span>&gt;{lambPrice}&lt;/Price&gt;&lt;/p&gt;
      &lt;p&gt;One jet <span class="hljs-keyword">is</span> &lt;Price showDecimals={<span class="hljs-keyword">false</span>}&gt;{jetPrice}&lt;/Price&gt;&lt;/p&gt;
      &lt;p&gt;Those gumboots will <span class="hljs-literal">set</span> ya back &lt;Price showDecimals={<span class="hljs-keyword">false</span>} showSymbol={<span class="hljs-keyword">false</span>}&gt;{bootPrice}&lt;/Price&gt; bucks.&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre><p>这里当然可以很简单的用 less code function 来实现</p>
<pre class="hljs"><code><span class="hljs-comment">// could just easily use a function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberToPrice</span><span class="hljs-params">(num, options = {})</span> </span>{
    <span class="hljs-keyword">const</span> showSymbol = options.showSymbol !== <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">const</span> showDecimals = options.showDecimals !== <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">return</span> num.toLocaleString(<span class="hljs-string">&#39;en&#39;</span>, {
      style: showSymbol ? <span class="hljs-string">&#39;currency&#39;</span> : <span class="hljs-literal">undefined</span>,
      currency: showSymbol ? <span class="hljs-string">&#39;USD&#39;</span> : <span class="hljs-literal">undefined</span>,
      maximumFractionDigits: showDecimals ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>,
    });
}

<span class="hljs-keyword">const</span> Page = () =&gt; {
  <span class="hljs-keyword">const</span> lambPrice = <span class="hljs-number">1234.567</span>;
  <span class="hljs-keyword">const</span> jetPrice = <span class="hljs-number">999999.99</span>;
  <span class="hljs-keyword">const</span> bootPrice = <span class="hljs-number">34.567</span>;

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;p&gt;One lamb <span class="hljs-keyword">is</span> &lt;span className=<span class="hljs-string">&quot;expensive&quot;</span>&gt;{numberToPrice(lambPrice)}&lt;/span&gt;&lt;/p&gt;
      &lt;p&gt;One jet <span class="hljs-keyword">is</span> {numberToPrice(jetPrice, { showDecimals: <span class="hljs-literal">false</span> })}&lt;/p&gt;
      &lt;p&gt;Those gumboots will <span class="hljs-keyword">set</span> ya back {numberToPrice(bootPrice, { showDecimals: <span class="hljs-literal">false</span>, showSymbol: <span class="hljs-literal">false</span> })} bucks.&lt;/p&gt;
    &lt;/div&gt;
  );</code></pre><h2 id="-9-the-store-is-the-component-s-servant">#9 The store is the component’s servant</h2>
<p>用 <code>store</code> 来管理组件复杂度。</p>
<p>My suggestion:</p>
<ol>
<li>Work out the general structure of your components and the data they will require</li>
<li>Design your store to support those requirements</li>
<li>Do whatever you need to do to your incoming data to make it fit into the store.</li>
</ol>
<p>推荐使用单个模块来管理所有 Incoming data，所有的数据处理放在一起做，单元测试什么的也变简单了。</p>
<pre class="hljs"><code><span class="hljs-comment">// react/redux way</span>

<span class="hljs-tag">fetch</span>(<span class="hljs-built_in"><code>/api/search?${queryParams}</code></span>)
<span class="hljs-class">.then</span>(response =&gt; response.<span class="hljs-function">json</span>())
<span class="hljs-class">.then</span>(normalizeSearchResultsApiData) <span class="hljs-comment">// the do-it-all data massager</span>
<span class="hljs-class">.then</span>(normalData =&gt; {
    <span class="hljs-comment">// dispatch normalData to the store here</span>
});</code></pre><p><strong>这里推荐徐飞在 QCon 上分享的 <a href="https://zhuanlan.zhihu.com/p/26426054">单页引用的数据流方案探索</a></strong></p>
<h2 id="-10-importing-components-without-relative-paths">#10 Importing components without relative paths</h2>
<p>Turn</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../../../Button/Button.jsx&#39;</span>;
<span class="hljs-keyword">import</span> Icon <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../../../Icon/Icon.jsx&#39;</span>;
<span class="hljs-keyword">import</span> Footer <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../Footer/Footer.jsx&#39;</span>;</code></pre><p>Into</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {Button, Icon, Footer} <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;Components&#39;</span>;</code></pre><p>更灵活方便使用组件。</p>
<p>使用 <code>Webpack2</code> 可以直接配置</p>
<pre class="hljs"><code><span class="hljs-regexp">//</span> exports all components wherever they are
<span class="hljs-regexp">//</span> <span class="hljs-attribute">Ref</span>: Webpack <span class="hljs-built_in">require</span>.context
<span class="hljs-regexp">//</span> <span class="hljs-attribute">https</span>:<span class="hljs-regexp">//</span>webpack.github.io/docs/context.html

<span class="hljs-regexp">//</span> ./{xxx}/yyy/index.js =&gt; import { yyy } from <span class="hljs-string">&#39;components&#39;</span>
const req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#39;.&#39;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/.\/[^/</span>]+\<span class="hljs-regexp">/[^/</span>]+\<span class="hljs-regexp">/index.js$/</span>)

req.keys().forEach(<span class="hljs-function"><span class="hljs-params">(key)</span> =&gt;</span> {
  const componentName = key.replace(<span class="hljs-regexp">/^.+\/([^/</span>]+)\<span class="hljs-regexp">/index.js/</span>, <span class="hljs-string">&#39;$1&#39;</span>)
  <span class="hljs-built_in">module</span>.exports[componentName] = req(key).default
})</code></pre><p>Creator 中因为用的 <code>create-react-app</code> CLI，无法自己配置 Webpack，所以并没有用到...</p>
]]></description><link>/2017-06-28-10-react-mini-patterns-note/index.html</link><guid isPermaLink="true">/2017-06-28-10-react-mini-patterns-note/index.html</guid><category><![CDATA[notes]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Tue, 27 Jun 2017 16:00:00 GMT</pubDate></item><item><title><![CDATA[Bug makers or bug fixers]]></title><description><![CDATA[<blockquote>
<p>世界上只有两种人： Bug makers or bug fixers.
    —— 郫县豆瓣</p>
</blockquote>
<p>可能是周一不宜上线吧。
下午在做某个需求的时候，突然收到了一个之前修过但却并没有修好的小 Bug。接着又收到了一个刚上线的新需求报过来的线上 Bug 反馈，然后紧接着同一个需求的两个、三个 Bug… 一大片，炸开了。最后， PM 说，”这次 Bug 太多了，都先回滚吧。”
只是突然觉得，已经工作了一年多近两年的我，写代码的时候依然不走心。
其实作为程序员，被人指出你代码的 bug 是难受的，除了尴尬，有时候甚至真的会感到羞耻，会有点看不起自己也觉得会被人看不起。
我只希望自己能够在每次写代码的时候永远记住这种感觉。
之前也是遇到过各种奇奇怪怪的线上 Bug，其实大部分都是自己写的时候不用心、测试时候不上心导致。而最近，写的时候居然总有种匆匆忙忙急着完成任务的感觉，可结果却是既没有快速完成，也没有保证质量，既不好也不快，反而耽误了很多时间在 Debug 上。
十足的 Bug Maker.
其实仔细反思一下，我是知道原因的。
最近一个多月以来，老实说，自己的生活发生了一些根本性的变化。
我重新认识了一些人，重新跟一些人建立了新的关系，重构了自己的交友圈，经历了一些或狗血或鸡汤的事，也渐渐开始了一种和原来不太一样的生活方式，开始吃以前没怎么吃过的东西，读一些以前不怎么读的书，说一些有得没得的话。就像看了一场时而卡帧，时而情节又快速前进的黑白电影，散场后的我却浑浑噩噩。
其实不管怎么说，从整体来看，新的生活方式是很好的，是我曾经向往的那种。但可能是我本来就工作不太上心，可能是我本来就懒得总结学习，可能是我之前养成的一些坏习惯，日积月累，量变成了质变，现在终于迎来了炸裂。
也有可能，是我还没有彻底做好开始新生活的准备。
我可能仍然需要提醒自己，在任何时候都要保持自己的心境。</p>
<ol>
<li>找到生活与工作的平衡点，不会被周围噪音改变自己的频率，保护自己的直觉。
今天临时去看了下一个 bug 案发现场，居然发现自己一瞬间没有了 bug-fixing 直觉。
之前读过一本书，说一些有伟大格局观的人，大多都有着极简生活方式，如乔布斯等。「因为只有生活方式简单的人，才更容易保护到那一刹那，获得灵感。你很难想象一个整天忙于各个社交的人，能保护到自己的直觉。反之，人们常常在无意有意与他人合谋，伤害自己的好直觉。常见的三种伤害直觉的方式有：言语；父母与配偶；运气。」
浑浑噩噩一个多月，需要回归到规律作息，规律饮食。</li>
<li>保持一颗热忱的心。
个人觉得，「热忱」的状态决定未来的成就。
每个人都希望自己在工作中被认可，有存在感。但是这些事情，如果你不热爱，就不可能把它做得真正优秀。而有了热情，才有了专注，才会坚持下来，最终发光发热。
「人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。」
其实我是喜欢写点代码的，有时候还会自己动手做一些小工具。
突如其来的事情总是会有，希望自己可以调整调整，对喜欢的东西保持专注，保持一颗热忱的心。</li>
<li>「一幅优秀的绘画作品必须比它应该有的样子更好」
这句话出自我很喜欢的一本书《黑客与画家》。
之前一直觉得，只有伟大的东西才是不朽的。这样导致的结果是，我对自己创造出的东西并没有太苛刻。
书作者 Paul Grahams 举例说保存于美国国家美术馆的达·芬奇的作品《女性肖像》（Ginevrade&#39;Benci），一般人欣赏的时候都会注意到，达·芬奇在少女的头后面摆了一片树枝，他很仔细地画出了树枝上的每一片叶子。许多画家也许会觉得，那不过是放在背景里的衬托物，没有人会仔细看的，不妨简单处理一下就可以了。
但是达·芬奇不这样想。他对作品每一部分的认真程度完全不取决于预料中会不会有人仔细看这个部分。他就像篮球巨星迈克尔·乔丹（MichaelJordan），每一球都一丝不苟，绝不降低对自己的要求。
结果就是，「所有那些看不见的细节合并在一起，就使得这样东西产生了惊人的效果，仿佛上千个细微的声音都以同一个音调在歌唱。同样地，优秀的软件也要求对美的狂热追求。如果你查看优秀软件的内部，就会发现那些预料中没有人会看见的部分也是优美的。我对待代码的认真程度远远超过我对待其他事情。」
既然自己选择了走这条路，做这份工作，就应该要把它踏踏实实做好。每一个细节，每一个代码片段，每一个你认为不够美的地方，都去用心创造细心打磨。
它可能成为不了不朽，但就是明知道一切都会被时间碾碎，也要认真面对啊。</li>
<li>不要完美过头。
其实出 Bug 确实是无法避免的一件事。毕竟比起开发环境，线上环境更复杂多元，影响的因素更多。
抛开之前开发过程中有点不细心不说，但我可能每次对于上线后一些紧急 Bug 太提心吊胆了。对于上线后同行发现的 Bug 更是亚历山大。而这样就导致 Hotfix 时有点畏手畏脚，修的效率也不是特别高。
《黑客与画家》中有个关于创业公司产品快速迭代公式：
1.搭建原型 2.上线运营 特别建议：别管Bug 3.收集反馈 4.调整产品 5.成长壮大
所以在某种特定环境下，也不需要太追求完美。
线上出了 bug？修了就是嘛。实在不行，先回滚咯。
很无聊的 Bouns:  How to become a bugs fixer in JavaScript way ...</li>
</ol>
<p><img src="/content/images/bug-fixers.png" alt="Become a bugFixer in JavaScript way"></p>
<ul>
<li>End -</li>
</ul>
]]></description><link>/2017-03-27-Bugmakers-or-bugfixers/index.html</link><guid isPermaLink="true">/2017-03-27-Bugmakers-or-bugfixers/index.html</guid><category><![CDATA[thoughts]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Sun, 26 Mar 2017 16:00:00 GMT</pubDate></item><item><title><![CDATA[可能我们都有病]]></title><description><![CDATA[<h3 id="-">焦虑、抑郁？</h3>
<p>昨天在朋友圈偶然看到了一个关于「成电延时摄影」视频，突然很好奇地点进去看了下。伴随背景音乐响起，晨雾中的主楼，晨光中的银杏大道，蓝天下的宿舍楼，黄昏下的品学楼，夜幕降临的图书馆，灯光辉煌的体育馆，还有一直没机会上过课的新教学楼，碧波荡漾的东湖西湖… <br/>
以成都的天气，作者肯定是花了很多心血的，虽然不排除后期，但是一共七千五百张照片，一帧帧下来，每一幅都是曝光完美，好像从来没有见过那么美的成电。
仔细想想，毕业离开学校近两年，从来没有很认真地怀念过自己的大学。<br/>
每次跟人提起，就只能用一个词来形容，黑暗。<br/>
那段时间，我经历了入学的迷茫、苦闷，无疾而终的异地感情和孤立，梦想与现实差距带来的焦虑、抑郁，人际关系紧张的被忽视、被抛弃、被不理解，以及进入大学就再没有好过的睡眠。特别严重的一段时间，白天如行尸走肉，不想读书，也无法集中注意力，晚上必须服用安眠药才能入睡，走在路上还有着被害妄想症心理。
同时我也很疑惑，为什么身边的那些人就可以那么无忧无虑，那么轻易得到自己想要的东西。<br/></p>
<p>可能真是在大学里逼迫了自己太多。<br/>
到最后实在是没有办法了，年纪轻轻却完全没有年轻人应该有的精气神，与我交流过的一些朋友都说，你当时真是阴暗，铺面而来的一股负能量。<br/>
终于也撑不住了，咨询心理医生，服用抗焦虑药，学会敞开心扉坦诚和身边的人交流，同时辅助了大量的心理学相关书籍，特别感谢荣格的「人格分析学」，对自己人格进行了基本的剖析，从内心深处开始认识自己。<br/>
同时也给自己灌了大量的心灵鸡汤。<br/>
那段时间很迷一首歌，《给自己的信》，把它的歌词抄了一遍又一遍。</p>
<blockquote>
<p>很相信能成就大爱 很相信能炫耀自己<br/>
很贪心 愿天天很多美好的派对<br/>
写封信来留住大志 写封信来提示自己<br/>
写得低 是心中很多似诗的细碎</p>
<p>怀疑我当天几多岁 令我写了一句不怕流泪<br/>
怀疑我永远不会累 就来十行列明十个壮举<br/>
让我闯出新世界 交出真个性<br/>
假使想爱 必会找到亲爱伴侣<br/>
突然十年便过去 方知岁月冷漠似水<br/></p>
<p>就算笔迹不会变 纸张不会皱 <br/>
偏偏想笑 竟会得到灰暗情绪<br/>
默然从头读过去 <br/>
一句一句太干脆 一个一个已粉碎 <br/></p>
<p>祝福我能游历万国 怎么我还奴役自己 <br/>
不甘心 在天天很多错失的证据 <br/>
这封信如明亮大镜 这封信能明白自己 <br/>
写得低 但怎么抛低理想的散去 <br/></p>
</blockquote>
<p>渐渐地，还记得在大三下学期某一天，我突然就想通了。<br/>
日子不是过给别人看的，而是要自己感受的。<br/>
任何时候都应该善待自己，知道什么才是自己真正想要和需要的，而不是靠别人的价值观，活在别人眼光下。<br/></p>
<h3 id="-">神经症？</h3>
<p>不过，这些低谷情绪现在也仍然会突然冒出来，杀我个措手不及。<br/>
今天和一朋友讨论，她说，虽然知道我是个挺有意思的人，但只不过很多时候还是能让别人感受出来，我是在很努力维护自己自尊的那种人，甚至太刻意。<br/>
想让别人知道你很赞，你懂这些，你很棒，你没关系。装逼不是病，强制自己装逼就是病了，会把你自己逼疯的。不够优秀的时候，不够赞的时候，被别人质疑或者指出问题的时候，要强制维护自尊就是病。<br/>
她问，你不累吗？承认自己有时候有些地方确实做得不够好，不完美又如何呢？<br/>
是，为什么我会这么「努力刻意维护自己的自尊」？我突然沉默了。<br/>
整理了情绪继续讨论下去，发现自己确实喜欢以自己的所谓正确三观来 judge 别人，一旦别人稍有不同意或者不赞成我的观点，我就会跟人辩论起来，小时候跟爸妈辩，长大了嘴贱跟朋友辩，有时候还会特别牙尖毒舌，经常伤到身边最亲密的人。<br/>
她问，你在害怕什么？<br/>
突然内心最柔软的地方被触碰了一下。<br/>
突然意识到，这么多年来，原来我还并没有好。<br/></p>
<p>最近在读一本书，《我们时代的神经症人格》，作者是卡伦·霍妮，与荣格、阿德勒、弗洛姆齐名的心理学大师，也是唯一开创一个精神分析思想流派的女学者。<br/>
霍尼在这本书中运用精神分析的基本原理，对「神经症人格」进行了血淋淋的剖析，她说神经症病人内心充满了各种各样的冲突：一方面，他们对爱怀有病态的追求，但另一方面，他们又害怕爱，逃避爱，无法获得爱；一方面，他们拼命追求权力、名声和财富，另一方面，他们又怀着对失败甚至对成功的恐惧，竭力要逃避竞争；一方面，他们对他人充满了恐惧和敌意，另一方面，他们又总是倾向放弃自我，顺从他人…<br/></p>
<p>读到这里，像是被击中了，这不就是我吗？<br/></p>
<p>她在书里继续分析到，神经症固然一方面源于童年时代因缺乏安全感而产生的一种基本焦虑，但更多地却源于当前实际面临的冲突。这些冲突深深地植根在文化内部，从这一意义讲，神经症患者个人的精神危机，在一定程度上乃是一定社会、一定时代的文化危机的反映，神经症患者的内心冲突，只不过是一定文化内在冲突的缩影。<br/>
现代文化在经济上是建立在个人竞争的原则上的。独立的个人不得不与同一群体中的其他个人竞争，不得不超过他们和不断地把他们排挤开。一个人的利益往往就是另一个人的损失。这一情境的心理后果乃是人与人之间潜在敌意的增强。每一个人都是另一个人的现实的或潜在的竞争对手。竞争，及伴随这种竞争的潜在敌意，已渗透到了一切人类关系中。竞争性刺激从生到死，从摇篮到坟墓都在积极活跃地发挥其作用。<br/>
而我们，又在一个竞争性的社会里，失败即意味着各种需要都遭到实际的挫折。<br/>
失败不仅意味着经济上的不安全，而且意味着丧失名声地位，意味着各种各样情绪上的挫折打击。成功何以如此令人神往的另一个原因，是它对于我们自尊心的影响。不仅他人要根据我们取得的成功程度来评价我们，就是我们自己，不管愿意与否，也要根据同一种模式来评价我们自己。<br/>
在现在意识形态的压力下，即使最正常的人也不能不感觉到，如果他成功，他就有一定价值；如果他失败，他就一钱不值。不用说，这反映了我们的自尊心是建立在摇摇欲坠的基础之上的。<br/>
竞争、同胞之间潜在的敌意、恐惧、摇摇欲坠的自尊心，所有这些因素共同在心理上导致了个人的孤独感。即使他与他人有很多往来和接触，即使他的婚姻美满幸福，他在情感上仍然是孤独的；如果这种孤独感与他缺乏自信心的彷徨忧虑、恐惧担心相吻合，就会成为一场灾难。<br/></p>
<p>「神经症患者就是我们当今文化的副产物。」<br/>
可能在这样的文化中，我们都有不同程度的病。</p>
<h3 id="-">别害怕</h3>
<p>今天凌晨时候家里来了窃贼，还好她在被我发现就逃了出去，还好人财都安全。<br/>
现在回想起来还是有点后怕，要是那人恰好胆子很大还带了刀怎么办，要是真的发生了激烈搏斗然后还受伤了怎么办，就想着，还是要把每天当作生命中最后一天来对待，什么矫情装逼抑郁焦虑，其实都不算什么了。<br/></p>
<blockquote>
<p>去爱吧，就像不曾受过伤一样 <br/>
跳舞吧，像没有人会欣赏一样 <br/>
唱歌吧，像没有人会聆听一样 <br/>
干活吧，像是不需要金钱一样 <br/>
生活吧，就像今天是末日一样 <br/>
--Alfred D’Souza</p>
</blockquote>
<p>现在觉得，其实每个人的人生中都会有那么一段黑暗时光，只是顺序到来先后和时间长短不同而已。<br/>
王尔德曾说，「世界上只有两种悲剧：一种是得不到自己想要的东西，另一种是得到了。」<br/>
所以那些得到的也不一定就是幸福。<br/>
我所失去的都是侥幸，我所拥有的都是人生。</p>
<p>也许现在还是会记得，大学时候的自己，曾靠在洒满阳光的图书馆窗前，手里捧着一本好玩的书，啜一口热咖啡，看银杏叶飘落。<br/>
我们都将孤独地长大，不要害怕。</p>
]]></description><link>/2017-02-28-perhaps-we-all-need-medicine/index.html</link><guid isPermaLink="true">/2017-02-28-perhaps-we-all-need-medicine/index.html</guid><category><![CDATA[thoughts]]></category><category><![CDATA[psychology]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Mon, 27 Feb 2017 16:49:00 GMT</pubDate></item><item><title><![CDATA[Fun with Codemod & AST]]></title><description><![CDATA[<h1 id="fun-with-codemod-ast">Fun with Codemod &amp; AST</h1>
<hr>
<h2 id="content">Content</h2>
<ul>
<li>背景</li>
<li>Codemod</li>
<li>jscodeshift</li>
<li>Demo Time</li>
<li>Refs</li>
</ul>
<hr>
<h2 id="-">背景</h2>
<p>作为一个自信而自豪的前端弄潮儿（F2E），我们总是希望能够在这个每天都在飞速迭代的行业，与时渐进。
前端们是一群不安分的人，大家喜爱新框架、新语法，而 JavaScript 也是一门非常灵活的语言，它提供给我们的 API 也在与时渐进。比如，当 <code>ES2015 ES2016 ES2017…</code> 出来的时候，那些新语法糖，简洁漂亮，且更易于理解逻辑，于是我们都想去尝试下。
但是尝试归尝试，对于新项目尝试起来成本很低，只需要把新功能都用新语法编写就好。
而创建新项目的同时，其实我们也在维护着一些已有的旧项目。如果你还并没怎么理它们，可能它们还活得不错。但是一旦 PM 心情好想加个新功能，或者你哪天心情好想去更新下代码库，然后看到自己之前写的那些代码，那些现在其实可以更优雅漂亮的代码，是不是手里特痒痒特想把它们更新了？
执行力强的前端儿可能说干就干了，嗯，就假设我们有个项目 Project，里面使用的是用<code>ES5</code> 版 <code>React</code> 作为 <code>UI View</code>。然后它大概四个页面<code>(Page)</code>，每个页面包含大概四个组件<code>(Component)</code>，然后你从某个看起来比较小、不容易出错的<code>Component</code> 入手，开始一行一行改写代码，嗯，<code>var React = require(&#39;react’)</code> 改为 <code>import React from &#39;react’</code>， <code>var API = ‘/j/app/xxx’</code> 改为 <code>const API = ‘/j/app/xxx’</code>，<code>var foo</code> 改为 <code>let foo</code>，<code>function () {…}</code> 改为 <code>() =&gt; {…}</code>，<code>module.exports = React.createClass({…})</code> 改为 <code>export default class MyComponent extends React.Component {…}</code> … 
天哪，有完没完，一个组件改完下来，你已经感到身体被掏空，望了望 <code>Components</code> 列表，更不用说，重新 <code>build</code> 过的测试还没过。你陷入了绝望...</p>
<p>那么有没有更快一点的办法呢？
稍微有点经验的前端儿可能想到「正则表达式匹配替换」。Bash <code>Awk | Sed</code> 命令，或者 Vim <code>:%s/var/let/g</code>。可是如果需要有些变量是 <code>const</code> 类型，有些是 <code>let</code>，而有些保持 <code>var</code> 不变怎么办？再比如说 </p>
<pre class="hljs"><code><span class="hljs-tag">merge</span>(a, {<span class="hljs-attribute">b</span>: <span class="hljs-number">1</span>}, c);  <span class="hljs-comment">// Old</span>

需要变为

({..<span class="hljs-class">.a</span>, <span class="hljs-tag">b</span>: <span class="hljs-tag">1</span>, ..<span class="hljs-class">.c</span>});  <span class="hljs-comment">// New</span></code></pre><p>这里光是这个函数的 <code>arguments</code> 就可能有多种形式，比如 <code>variable</code>，一个匿名函数返回的 Object 或者 <code>Plain Object</code> 那种。
这里相当于是一个 <code>Context-non-free</code> 的问题，也就是上下文语义很重要。
这样的话，无论再怎么强大的<code>RegExp</code> 也无能为力。因为正则的本质，其实是根据一定的 <code>Pattern</code> 来匹配字符串，但是在真正的代码里面，所有的字符串都有语义，都有上下文，这里的正则表达式会既复杂又无用。
所以，我们得换一个维度思考问题。</p>
<hr>
<h2 id="codemod">Codemod</h2>
<p>对「代码库的批量迁移更新」，其实也是程序员的一个需求，所以也感激地，已经有一群懒惰又聪明的程序员造出了工具：<code>Codemod</code>，将「大型仓库代码的批量迁移」自动化，省时省力。</p>
<p>好吧，所以 Codemod 到底是什么呢？
官方文档这样写着：</p>
<blockquote>
<p>Codemod is a tool/library to assist you with large-scale codebase refactors that can be partially automated but still require human oversight and occasional intervention.</p>
</blockquote>
<p>这样看来，可以很好的解决我们的需求了。
基于 Codemod，又出现了针对 JavaScript 代码迁移的工具 <a href="https://github.com/facebook/jscodeshift">Facebook jscoodeshift</a>，
基于 jscodeshift，又构建了迁移一般 JavaScript 代码（比如 ES5 -&gt; ES2015) 的工具 <a href="https://github.com/cpojer/js-codemod">js-codemod</a> 和迁移 React 相关项目的 <a href="https://github.com/reactjs/react-codemod">react-codemod</a>。</p>
<p>嗯，这么看来，我们的事情就变得容易多了。
根据上面那些工具的官方文档，我们只需要按顺序执行以下命令：</p>
<pre class="hljs"><code>&gt; npm i -g jscodeshift
&gt; git clone https:<span class="hljs-comment">//github.com/reactjs/react-codemod.git</span>
&gt; git clone https:<span class="hljs-comment">//github.com/cpojer/js-codemod.git</span>
&gt; jscodeshift -t react-codemod/transforms/<span class="hljs-keyword">class</span>.js --<span class="hljs-keyword">mixin</span>-<span class="hljs-keyword">module</span>-name=react-addons-<span class="hljs-keyword">pure</span>-render-<span class="hljs-keyword">mixin</span> --flow=<span class="hljs-literal">true</span> --<span class="hljs-keyword">pure</span>-component=<span class="hljs-literal">true</span> --remove-runtime-proptypes=<span class="hljs-literal">false</span> src/register/component/myComponent.jsx
&gt; jscodeshift -t js-codemod/transforms/no-vars.js ./src/register/component/myComponent.jsx</code></pre><p>然后，再次 <code>git status</code> 一下或者直接打开刚才 transform 的 <code>myComponent.jsx</code> 文件查看，你会发现，神奇般，你的代码都成为了它们应该成为的样子。</p>
<p>这里暂时以我之前做的 Accounts 项目为例：
<a href="https://github.intra.douban.com/accounts/accounts/pull/553/files#diff-b2286efdea6a62288250264e82bd948b">https://github.intra.douban.com/accounts/accounts/pull/553/files#diff-b2286efdea6a62288250264e82bd948b</a></p>
<ul>
<li>基本步骤如下：</li>
<li>因为是第一次使用 <code>codemod</code>，所以比较谨慎，一个一个 <code>component</code> 来；</li>
<li>先用 <code>react-codemod</code> 转，把大部头代码迁移；</li>
<li>然后 <code>js-codemod</code> 小步更新整理；</li>
<li>然后再根据一些自己的 Code Style 做些细节上的修改。比如使用 <code>standard-format</code> 工具格式化代码，符合我个人写的代码风格。</li>
<li>毕竟 JS 太过于灵活，每个人写代码时候风格和结构都是各异的，有时候的转换还是会出现一些与想象中不一致的结果，官方文档也是说仍然需要人工干预，所以会手动修改下代码细节；</li>
<li>一切组件迁移就绪，<code>npm run test</code> 测试通过以后，重新 <code>build</code> 运行</li>
</ul>
<p>这里我把已有的十几个组件和页面文件，全部使用上面的工具进行了更新。
然后当你重新 <code>build</code> 后，你会发现测试仍然通过，组件功能仍然 work，但是代码库却是使用新语法糖进行了大规模彻彻底底地更新！简直太神奇了！
那么，它是怎么做到的呢？</p>
<hr>
<h2 id="jscodeshift">jscodeshift</h2>
<p>让我们来重新读一下 jscodeshift 的<a href="https://github.com/facebook/jscodeshift#jscodeshift-">文档</a>。</p>
<blockquote>
<p>jscodeshift is a toolkit for running codemods over multiple JS files. It provides:</p>
</blockquote>
<ul>
<li>A runner, which executes the provided transform for each file passed to it. It also outputs a summary of how many files have (not) been transformed.</li>
<li>A wrapper around recast, providing a different API. Recast is an AST-to-AST transform tool and also tries to preserve the style of original code as much as possible.</li>
</ul>
<p>那么这里就出现了两个关键的概念：<em>Runner</em> 及 <em>AST</em>。</p>
<ul>
<li>Runner，</li>
<li><blockquote>
<p>A runner/worker feature that can apply transforms to thousands of files in parallel.
-- <a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.sg03sd9eq">CPojer Effective JavaScript Codemods</a></p>
</blockquote>
</li>
<li><p>AST，Abstract Syntax Tree，抽象语法分析树。</p>
</li>
</ul>
<p>为了更好理解以上概念，先来看一下之前运行 jscodeshift 命令过程。
我们先是把一个里面包含了 JS 代码的源文件传给了它，然后它读取了源代码，又根据写好的 <code>transform.js</code> 对源代码进行了相应的变换，最后输出了变换后的 JS 代码，覆盖了原文件。
简单的说，就是 
<code>SourceCode =&gt; codemod =&gt; ObjectCode</code></p>
<p>那么再详细一点，根据 jscodeshift 作者之一的 CPojer 在一次 JSConf 上对这个工具的介绍，jscodeshift 操作基本是按以下过程：
<code>Parse =&gt; Find =&gt; Create =&gt; Update =&gt; Print</code></p>
<ol>
<li>Parse: SourceCode =&gt; AST （Tree Nodes)</li>
<li>Find: Find the Nodes we want to replace         // Transform</li>
<li>Create: Create the New Nodes we want to insert  // Transform</li>
<li>Update: Update the AST at the right location    // Transform</li>
<li>Print: Print it back into JavaScript Source with proper formatting and should like human wrote this.</li>
</ol>
<h3 id="-parse-ast-">第一步，将源代码解析 (parse) 成 AST.</h3>
<p>我们知道自然语言（Natural Language)，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。
而在计算机编程语言 (Programming Language)，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。
不同的语言，都会配之不同的语法分析器(parser)。
对于自然语言，我们的大脑就是一个 Parser。对于编程语言，语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。</p>
<p>什么是语法树？摘自 Wiki 一段：</p>
<blockquote>
<p>计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>
</blockquote>
<p>这么说其实还是有点抽象，我们先打开 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">wiki</a> 看到 wikipedia 这个图，</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/9d7500be-f370-11e6-972f-f5ede1c448f8" alt="image"></p>
<p>前端er 一定会觉得很相似，这里不就是 DOM 语法树的终极抽象版本吗，只是把一个个 DOM Nodes 换成了一个个更加无语义的字符 Token。
FB 有一个很棒的工具 <a href="http://astexplorer.net/">ASTExplorer</a>，可以用来更形象地展示。</p>
<p>比如说，我们现在就只有一个很简单的表达式<code>a+b</code>，这里是 recast Parser 解析后的 AST 结构：</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/758a6076-f370-11e6-97e4-f6152c3814bf" alt="image"></p>
<p>看上去特别复杂。注意那些蓝色字体 <code>File</code>, <code>Programme</code>,<code>ExpressionStatement</code>,<code>Identifier</code>… 这些都是 AST Nodes，其他的都是和这个 Node 相关的数据。</p>
<p>根据前文可以知道，每种语言的 AST 都是不同的。有专门的 Parser 来生成 AST。</p>
<p>关于 <a href="https://en.wikipedia.org/wiki/Parsing#Parser">Parser</a> 又是一门很深的学问了。
在 ASTExplorer.net 上可以看到有很多 parser，比较著名的有 <a href="https://github.com/jquery/esprima/blob/master/src/parser.ts">Esprima(jQuery)</a>，Uglify-JS, Babylon(Babel), Acorn(Tern / Webpack), 及 jscodeshift 使用的 recast. 虽然有很多 Parser，但是基本上，一个 parser 的结构都差不多，对源代码进行词法分析，生成 Tokens，对 Tokens 进行语法分析，然后生成 AST。</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/5751ac04-f370-11e6-849e-692ab4b47bbf" alt="image"></p>
<p>具体可以参考看下 <a href="http://esprima.org/demo/parse.html#">Esprima Parse Demo</a>。
生成的 AST 都遵循一个统一标准 <a href="https://github.com/estree/estree/blob/master/es5.md">ESTree</a> or <a href="parser API https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API">Mozilla SpiderMonkey</a>，也就是说都会返回 ESTree Compatible AST.</p>
<h3 id="-ast-find-nodes-create-new-nodes-update-nodes-">第二三四步，对生成的 AST 进行操作修改 (Find Nodes &amp; Create New Nodes &amp; Update Nodes)</h3>
<p>Wiki 有介绍说，parse AST 的代码基本是使用<code>Visitor Pattern</code>，如：</p>
<pre class="hljs"><code><span class="hljs-comment">// recast</span>
<span class="hljs-keyword">var</span> ast = recast.parse(src);
recast.visit(ast, {
visitIdentifier: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(path)</span> </span>{
<span class="hljs-comment">// do something with path</span>
<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
});</code></pre><p>但是 js-codeshift 基于 <a href="https://github.com/facebook/jscodeshift#collections-and-traversal"><code>Collections</code></a> 概念，很贴心的给这些 Parser API 继续包了一层，提供了一个不一样的前端友好型 API.</p>
<pre class="hljs"><code><span class="hljs-comment">// jscodeshift</span>
  <span class="hljs-tag">jscodeshift</span>(src)
<span class="hljs-class">.find</span>(jscodeshift.Identifier)
  <span class="hljs-class">.forEach</span>(<span class="hljs-function">function</span>(path) {
      <span class="hljs-comment">// do something with path</span>
      });

<span class="hljs-comment">// Provide jQuery-likely and F2E-friendly Syntax API</span>
<span class="hljs-comment">// Manipulate AST nodes conveniently.</span></code></pre><p>读这段代码的时候，一下子觉得又似曾相识。这不就和使用 <code>jQuery</code> 操作 DOM 一样嘛。
可以对比下 “普通 Parser” 与 jscodeshift 操纵 AST 的区别：
可以看到如果使用 <a href="http://esprima.org/">esprima</a> ，AST Traverse / Walk 基本是 <code>visitor pattern</code>.
<a href="https://github.intra.douban.com/zhangbinliu/ast_demo/tree/esprima">https://github.intra.douban.com/zhangbinliu/ast_demo/tree/esprima</a></p>
<h3 id="-">第五步，输出转换后的代码</h3>
<p>这个据 CPojer 说，根据转换后的 AST，以及一些输出 <a href="https://github.com/benjamn/recast/blob/52a7ec3eaaa37e78436841ed8afc948033a86252/lib/options.js#L61">Options</a>（比如是否单引号、tab 宽度是多少、需不需要去掉尾部分号…）是一个挺困难的过程。
但最终，jscodeshift 的 print API 语法却是只要一行代码即可。</p>
<pre class="hljs"><code><span class="hljs-class">.toSource</span>({<span class="hljs-attribute">quote</span>: <span class="hljs-string">&#39;single&#39;</span>}); <span class="hljs-comment">// sets strings to use single quotes in transformed code.</span></code></pre><p>其实 Recast 在这做了<a href="(https://github.com/benjamn/recast/blob/master/lib/printer.js">大量的工作</a> )。</p>
<p>经过这五个步骤，一次 jscodeshift 的转换过程就算完成了。</p>
<hr>
<h2 id="demo-time-">DEMO TIME!</h2>
<h3 id="write-a-codemod-transform">Write a codemod transform</h3>
<p><code>jscodeshift -t &lt;transform.js&gt; /to/file/path</code> 的 <code>transform.js</code>，也就是说，你打算使用 jscodeshift 对源文件进行何种变换，这里面就是变换函数；</p>
<h4 id="problem-">Problem:</h4>
<pre class="hljs"><code><span class="hljs-comment">// Before</span>
<span class="hljs-string">&#39;Hello, &#39;</span> + name + <span class="hljs-string">&#39;, this is a string.&#39;</span>
<span class="hljs-comment">// After</span>
<code>Hello, ${name}, &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;.</code></code></pre><h4 id="solution-">Solution:</h4>
<ol>
<li>Simplify:</li>
</ol>
<pre class="hljs"><code><span class="hljs-comment">// Before</span>
a + b
<span class="hljs-comment">// After</span>
<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${a}&lt;/span&gt;&lt;span class=&quot;hljs-subst&quot;&gt;${b}&lt;/span&gt;</code></span></code></pre><p><code>a + b</code> AST:</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/e4d3c126-f36f-11e6-98aa-382c3afd9bcf" alt="image"></p>
<p><code>${a}${b}</code> AST:</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/ea450a52-f36f-11e6-9a28-f715785d13a2" alt="image"></p>
<p>对比两个 AST 可以发现
我们只需要 </p>
<ol>
<li>读入需转换的代码，找到 <code>BinaryExpression</code></li>
<li>保存 <code>BinaryExpression</code> 左右两边的值（node.left &amp; node.right)</li>
<li>生成一个为 <code>TemlateLiteral</code> Node，<code>quasis</code> 是一个包含了三个 <code>TemplateElement</code> 的数组，<code>cookde &amp; raw keys</code> 都是 <code>&#39;&#39;</code>， <code>expressions</code> 是一个包含 node.left, node.right 值的数组。</li>
<li>然后将它返回输出；</li>
</ol>
<p>Solution Example:</p>
<ol>
<li><a href="http://astexplorer.net/#/gist/33b63b7dc8da6d9ea4936c631adc994d/7905ef5b30dfc0cb3c811af8a8960f11014ef402">http://astexplorer.net/#/gist/33b63b7dc8da6d9ea4936c631adc994d/7905ef5b30dfc0cb3c811af8a8960f11014ef402</a></li>
<li><a href="http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/55c4910295973b3a4d09770d94cec73d5096daa4">http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/55c4910295973b3a4d09770d94cec73d5096daa4</a></li>
<li><a href="http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/cf3c898c5fe494d08a978dd1a3a3e56fc42828a8">http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/cf3c898c5fe494d08a978dd1a3a3e56fc42828a8</a></li>
</ol>
<p>官方没有太详细的 transform 编写指导，可以多谷歌或者学习 react-codemod/tranform or js-codemod/transform，
个人觉得写 JS-codeshift Transform | Babel-Plugin 本质其实就是对比两棵语法树，像解谜一样，看看如何「又好又快」变换成这样。
剩下的一开始如何读取源 JS 代码并解析成语法树，具体在 AST 上 traverse &amp; find &amp; create &amp; update （这里我猜测其实是一个递归遍历节点树的过程？），及之后如何按一定的 code style 生成我们需要的代码，都是透明且不关心的。</p>
<hr>
<h2 id="-">总结 &amp; 开脑洞</h2>
<ul>
<li><p>基本处理流程：
<img src="https://media.github.intra.douban.com/user/62/files/7fe54aa4-f370-11e6-90d8-9f191a40a5cc" alt="image"></p>
</li>
<li><p>AST 是很有用的一个抽象概念。一旦你理解了这些规则，唯一的限制就是解析器和你的想象力。</p>
</li>
<li>纯 AST parse 太过于理论，既然是工程师，还是需要自己动手写点什么来解决自己实际遇到的问题。</li>
<li>可以继续拓展到「语法高亮」、「关键字匹配」、「代码格式化」、「作用域判断」、以及「代码压缩」、「Babel 插件」等等。</li>
<li>渐渐深入底层进行分析，让自己对这门语言有了更多、更深入的了解，可以更好地成为产品「创造者」，而不单纯是「使用者」。</li>
<li>Write JavaScript that write JavaScript! The best editor is JavaScript. Cool!</li>
</ul>
<hr>
<h2 id="-">思考</h2>
<ul>
<li>可以在一个 codemod transform 里面同时进行两个变换吗？个人觉得可能会很复杂且效果不太好，因为有些 transform 并不是正交的。🤔</li>
</ul>
<hr>
<h2 id="refs-">Refs:</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=d0pOgY8__JM">CPojer’s Talk</a></li>
<li><a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.s5kdne4xl">Effective JavaScript Codemods</a></li>
<li><a href="https://survivejs.com/blog/codemod-interview/">Codemod Interview</a></li>
<li><a href="https://vramana.github.io/blog/2015/12/21/codemod-tutorial/">How to write a codemod</a> 结合 CPojer’s Talk, 这个虽很长但很有用！</li>
<li><a href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/">Understanding Babel Plugin</a></li>
<li><a href="http://tech.meituan.com/abstract-syntax-tree.html">AST 在美团的应用</a></li>
<li><a href="http://imweb.io/topic/57b13b4f93d9938132cc8dfd">imweb</a></li>
</ul>
]]></description><link>/2017-02-15-fun-with-codemod-and-ast/index.html</link><guid isPermaLink="true">/2017-02-15-fun-with-codemod-and-ast/index.html</guid><category><![CDATA[programming]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Tue, 14 Feb 2017 17:21:00 GMT</pubDate></item><item><title><![CDATA[豆瓣、北京、工作，及终于与自己握手言和的 2016]]></title><description><![CDATA[<h1 id="-2016">豆瓣、北京、工作，及终于与自己握手言和的 2016</h1>
<p><img src="/content/images/2017/01/title-img.jpg" alt=""></p>
<blockquote>
<p>在隆冬，我终于知道，我身上有一个不可战胜的夏天。 — 加缪</p>
</blockquote>
<p><strong>豆瓣</strong></p>
<p>在 2015 年末，我在笔记本上这样写着：</p>
<blockquote>
<p>有时候在想，能加入豆瓣也真的算是一种幸运。豆瓣这家公司，之前或现在，算是由复旦和华科这两所我很喜欢的学校的人组成，所以有些时候，对于这里的各种相似人生观、世界观及价值观会特别认同。就算偶尔也会对自己现在的能力与效率感到一点焦虑，不过不管怎么说，只要不退步，总是会前进。</p>
</blockquote>
<p>15 年夏天，我加入了豆瓣。
对，就是这个文艺得出了名的互联网公司。<br>
还记得 14 年底我正上大四，尴尬的时间，面临找工作选公司的窘境。<br>
而当时的我，喜欢拍照听歌，弹弹吉他，看些好玩的杂书，见到迷人的设计会兴奋不已，所以在那所死板沉寂绩点为王的工科学校，自认为算是个文艺青年。但是我也一直喜欢硬件，喜欢消费电子，喜欢拆装，享受通过自己动手创造出东西的过程，喜欢 Web，也能写点代码，人生某个阶段曾把成为一名 Geek 作为理想之一。于是不想浪费自己的底子，想着还是可以干点有技术含量的活，那么就去文艺气质的公司做点技术活吧，在不毁自己三观的同时还能养活自己，我是这么想的。
幸运的是，在我做决定的四个月后，我收到了来自豆瓣的 Offer。<br>
毕业前领取三方时候，我特意看了下，电工学院的同学们一个个不是去了华为中兴烽火，就是 XX 电子集团 XX 研究所。辅导员问我去了哪，我幽幽地说，豆瓣... 他大吃一惊，你咋这么浮夸呢。</p>
<p>其实冥冥之中，我与豆瓣是有缘分的。<br>
12 年初在上大一的我，在找某本书的时候第一次遇到了豆瓣，注册帐号填昵称时候，刚好想着自己在郫县上大学，这里有好吃的豆瓣酱，那么干脆就叫 “郫县豆瓣” 吧。
去年过年，公司刚好发了一大袋豆瓣酱作为礼物，恰好也是郫县产的，于是那天郫县豆瓣收到了来自豆瓣的郫县豆瓣酱。</p>
<p>我以为我已经够文艺了，来了之后才发现，远远不够。<br>
在豆瓣，你会想去听更多小众的唱片，读更多有深度的书，看更多有意思的电影话剧舞台剧，因为在这里工作，每天打开就是各种书影音页面，平时还有老师是痛仰乐队吉他手的大豆瓣吉他班，拥有一些好片子的独家片源的豆瓣 D9 放映室，同时还有一群文艺气质满满自带情怀的厂工。有时候会在想，是环境导致你改变了呢还是说你本质就是这样的人，但只是这种气质更显著了？不重要，至少我做到了「不毁三观的同时还能养活自己」。</p>
<p>现在回过头来看，真的很感谢豆瓣。<br>
首先解决了我的工作问题，其次又解决了我的房子问题，然后还解决了我的室友问题。<br>
同时，它也是一个帮助我实现自我价值的平台，可以让我用技术服务千万用户，可以给我参加 JSConf 的机会，可以让我和之前特别崇拜的业内大神们一起交流。</p>
<p>也许在互联网行业，创立十年之余的豆瓣可能在某些方面过于慢，慢得令人发指，慢得根本不及那些创立没几年但火爆的现象级公司。但这并不妨碍我对它初衷的喜爱，毕竟，生活不止有眼前的苟且，真的还有诗和远方。<br>
我总是不想成为一个无趣的人的。<br>
希望自己能够永远理想主义般活着。</p>
<hr>
<p><strong>北京</strong></p>
<p>一些老友或者新朋友见面，总会问我，为什么你会来北京？<br>
我总是半开玩笑的回答，「没办法，只有北京要我啊」。<br>
也很感到幸运的是，自己还是来到了北京。</p>
<p>尽管这里会有雾霾，会消费很高可能积攒不下太多钱，会要每天与一百万人挤地铁，但是，我也能见到繁华的万家灯火，吃各种好吃的，看各种有意思的展听各种有意思的 Live，认识到各种各样有趣的努力活着的人，接触到各类有深度的思想文化，利用这里有的各种资源感受各种社会，这对于来自小城市的我真的是一种莫大的吸引，大家都在这里努力地活着，你会觉得你活在这里每天都是不一样的。</p>
<p>大城市包容又开放，很讲秩序和规则，对我这种既不世故也不圆滑，同时也并不想变成这样的人，在某种程度上有一种舒适安全感。<br>
每天来往的人很多，但是大家都相互尊重讲礼貌，有些时候也能感受到人情。</p>
<p>去年七月份的某天，我走在路上忽然遇到了大暴雨。北方是很少下雨的，那样大的暴雨更是突然。只能狼狈找了个屋檐临时躲雨，一开始还以为是个店面，结果却是在别人的家门口。一个临马路的小房间，里面放了一张上下铺，一对夫妇就这么挤在这里。他们很热心地叫我进来坐，说里面还有个小沙发，女主人很利索地把角落小沙发打扫了下，于是我很不好意思地坐下了。聊了会天发现是外地打工夫妇在这里做房屋装修，屋子是临时租的。男主人仍旧很热心地说，等下你走的时候拿把伞吧，见我推辞，他说没关系的，我们还有两人的伞，你以后有空还过来就好，反正我们还要在这住两个月。临走之前其实雨已经小得差不多了，可是他们却仍把伞塞给我，怕我淋着。当时瞬间就被感动了，这就是我所理解的北京吧。</p>
<p>我是个情绪受天气影响挺重的人，之前在成都四年，那里阴霾潮湿的天气直叫人抑郁。<br>
最喜欢北京的，大概就是大蓝天了。<br>
北方的天空直接、干脆，让来自南方的孩子迷醉。<br>
大晴天随意走在路上，放眼望去一片湛蓝，愉悦、心旷神怡，「梦想更是直接的，让你觉得十二三岁时最喜欢用的 “梦想”、“人生” 等大词真的实实在在靠近。」<br>
所以天气好的时候，我走路基本都是抬着头，总会忍不住拍几张照片记录下好看的天空。
￼￼
<img src="/content/images/2017/01/sky-of-beijing.jpeg" alt="Sky Of Beijing"></p>
<p>其实来北京后，自己看世界的角度与思考架构也起了翻天覆地的变化。<br>
看到过一段话，</p>
<blockquote>
<p>一个人想要进步的最好方法是什么？绝对不是玩命的读书自学，在自己体内累积信息和知识，而是把自己置身到一个更优质的协作关系中。在核心地带，每天光订外卖，叫车这种响应和协作的速度，就会重新雕塑你的人生的感觉。</p>
</blockquote>
<p>在北京，互联网行业的一切都在高速地迭代，与个人发展正相关的行业环境，以及每天前沿思潮碰撞，不知不觉大脑就有了一种全新的感觉，像完成了一次升级。</p>
<hr>
<p><strong>工作与职业</strong></p>
<blockquote>
<p>如果一个事情是你从零开始做，后小有所成，你便会加倍珍惜，这是一种仪式感，能带给人以高潮。</p>
</blockquote>
<p>既然追求设计的美，但又想做点技术活，「前端开发工程师」这个职业一开始真的觉得很适合自己吧。<br>
很多年前，在 QQ 空间还很火爆的时候，我就喜欢去网上找代码，把自己的空间弄得特别好看。当时如果坚持下来，现在可能也是「QQ空间网红」一枚。<br>
后来直到大四找工作，才从零开始认认真真研究这类技术，一个人每天背着几本厚厚的 HTML &amp; CSS &amp; JS 书，去图书馆认认真真啃了两个月。自己的第一个网站上线的时候，激动地电脑刷完平板刷、平板刷完手机刷。一有时间就去浏览 GA，看看今天是不是又新增了访客。</p>
<p>毕业后如愿以偿找到工作来了豆瓣。想着自己的代码即将上线，被千万用户使用，每次提 PR (Pull Request) 都莫名有一种仪式感。<br>
整理代码，rebase commits，基本上我每次都会把 PR 描述写得很详细，从需求是什么，自己做了什么更新，遇到大功能更改，还会把现在更新和之前相比有什么不一样，选择的何种方案，遇到了何种问题及自己对问题的思考过程列出来，附上 preview 地址，有时候还会贴下前端效果图，然后 @相关厂工，把那句 “Please review, thanks!” 一个字母一个字母敲上，最后郑重点击提交。<br>
接下来就是激动地等着自己的代码被 review，被 merge，被上线。<br>
看到线上效果后，就算只是一点点小功能，你还是会珍惜，有时候真会出现传说中的 “颅内高潮”。</p>
<p>突然意识到自己工作对别人也是有价值的，是某天一个厂工跟我说，我两个月前写的一个小项目他们还一直在使用，数据一直在更新，那些东西一直在线上跑着呢。我才突然想到，噢，原来它们是有生命的，真的不用管也能活得很好。</p>
<p>酱厂虽然没有加班文化，但项目紧急的时候还是会写代码到很晚。<br>
没有两三点修过 bug，不足以谈人生。<br>
当然，修别人留下的棘手 bug 尤其痛苦，所以也会有很累想停下来的时候。<br>
有天整理了一份业内前辈的<a href="http://zhangbinliu.me/follow-the-progressive/">博客清单</a>，当自己觉得缺乏灵感，身体被掏空，会去那些一直前行孜孜不倦的前辈们那里学习学习，激励自己跟上他们的步伐。</p>
<p><img src="/content/images/2017/01/Contributions-of-2016.png" alt="Contributions of 2016"></p>
<p>其实有时我还是担心自己的职业的。<br>
比如说现在的 AI，有天在 GitHub 上偶然看到神经元版 <a href="https://github.com/xviniette/FlappyLearning/">Flappy-Learning-Bird</a>，让我开始怀疑自己的工作，前端毕竟不是一门技术门槛很高的手艺，它有些时候体力活会很多。如果机器可以写出比你更好的代码，而你写不出制造那种机器的代码，以后是不是会被取代？<br>
后来几天，我开始学起了算法。</p>
<p>希望自己可以朝更智能的方向前进。<br>
希望自己能够继续带着匠人仪式感活着。</p>
<hr>
<p><strong>租房、一个人住</strong></p>
<p>也许是在真正一个人住以后，我才意识到自己突然多么自由。<br>
虽然我是从初中就开始寄校住宿，但是从来没有完整地在没有父母打扰外人干扰的情况下，拥有一个完完全全属于我自己的一个空间。过去二十二年，我像被困在一个硬盒子里，硬盒子里有各种各样你不喜欢也不能无视的东西。<br>
但当我第一次躺在自己租的第一个小房间的地板上，那一瞬间，盒子里那些曾经不能无视的东西都消失了，盒子的四壁向外倒塌了，平平地向四面延伸展开，外面出现了整个世界！从现在开始，每一天二十四小时竟然都是我自己的，穿什么、吃什么、去哪里、几点睡、要不要说话、躺床上还是躺地板上，竟然都是我自己完完全全可以决定的了。<br>
很多刚开始北漂的人都会有点想家，而我却十分没心没肺地享受那种前所未有的自由感。<br>
我终于独立了，终于可以自己决定自己的每天的生活了！</p>
<p>“人们在最破落的地板上也要铺上地毯，在最简陋的桌上也要摆上一束花，在最昏暗的房间里也要点上一盏灯。”</p>
<p><img src="/content/images/2017/01/flowers.jpg" alt="Flowers"></p>
<p>我一直都很信那句话，房子是租来的，生活不是。<br>
也是在一个人住后，我才发现我对于家居家具尤其是厨具的喜爱。曾经有段时间达到了每半个月逛一次宜家，虽然每次人都是很多，虽然每次都是那点东西，但是我总能发现不一样的地方。居家属性爆棚到以至于每次看到一些心仪的厨具，我脑海里面都能脑补出来我使用它们的场景。<br>
朋友们都会说，啊，你真是一个热爱生活的人。<br>
有时候足够幸运，终于碰上聊得来的室友，一起做几道简单的菜作为晚餐。我们坐在桌子两端，整个小屋子气氛很好，家常菜不能算得上美味，但是却让人觉得踏实。有那么一刻，我觉得好像我们并不是在北京漂泊的两个人，而是在家生活的好朋友，而这个租来的小屋子并没有那么多排斥我们的气息，反倒有一种格外的包容。</p>
<p>当然有时候也还是会难受得想哭。<br>
现在坐在家里，还是能回想起 15 年九月底，因为一些突发情况，我不得不短期内从租来的第一个房里搬出去。正好是中秋节前一个周末，一个人沿着 14 号线，一大早走到晚上找房，大概走了两万五千步，看了各种迥异的房子和各种房客的迥异人生，不由自主一直哼着那首人来人往。也终于有所不安，终于体会到居无定所的可怕及「漂」的真正含义。<br>
那天最后好歹是解决了房子问题。晚上大家都在欣赏圆月，而我回到那个即将搬离的家，听着来北京前友人送的那首《一个人的北京》，「许多人来来去去，相聚又别离，也有人喝醉哭泣，在一个人的北京」，突然就红了双眼，眼泪止不住的流。</p>
<p>熬过那些负面情绪，又经历了自己组装衣柜书架，修理燃气灶下水道空调床垫饮水机暖气片，学会和各种各样的人周旋打交道，生活自理基本独立，性格脾气都变好了。<br>
一个人住也给了我极大的独处空间，学会如何与自己相处。</p>
<p>离开父母一个人独立生活，也渐渐思考到家庭环境对一个人成长的影响。<br>
有天接触到一个词，“原生家庭”，大意是说除了基因作祟之外，你出生到成年之前的主要岁月里，你爸妈的基本观点、生存常识和做事方法会深远地影响你一生。
某个时候终于可以和父母平心静气地讨论双方及之间的成长冲突，也是终于接纳了自己的内向性格。<br>
原来，我之所以长成我，一切都是有原因的。<br>
毕业时候我跟我爸说，我去豆瓣了。第二天他跟我说，噢你说的那个豆瓣网站，我昨天去看了看，上面的内容还挺有意思挺有追求的。那一瞬间我觉得，嗯，我爸果然还是当年那个文艺青年。<br>
就像之前读过一段话，</p>
<blockquote>
<p>我追求理性，但是我写诗；<br>
我强调自律，但我很难早起；<br>
我控制情绪，但我渴望真爱。</p>
</blockquote>
<p>其实一切的一切，无论我身处何处，基因不会欺骗人，我的活法永远有我父母的影子。<br>
但我并不是太想重复过一遍我父母的人生。<br>
“经济不独立，人格则无法独立”。现在的我，基本经济独立，但仍旧希望自己拥有独立人格，过独特的一生。<br>
希望自己能够自由而独立地活着。</p>
<hr>
<p><strong>吃和健身</strong></p>
<p>吃和健身，某种程度上说，刚好是互逆的过程。<br>
这两件事也是从内到外改变了自己吧。</p>
<p>「别人老说，你要是再瘦 20 斤，你可了不得了，但我就是爱吃。」<br>
黄磊如是说，我猜我也是如此吧。<br>
我是爱吃的，但我更喜欢自己下厨。来北京也吃过一些好吃的精致的餐厅，但是到最后还是觉得，无论何种饕餮美味，那种感觉，其实也抵不过大早上起来喝一口热乎银耳羹的满足。</p>
<p><img src="/content/images/2017/01/cooking.jpg" alt="My-Cooking"></p>
<p>You are what you eat. <br>
一边学着做饭，一边与自己对话。我记得我有段时间，早餐吃了四天的水波蛋，就觉得永远吃不腻。每次用叉子小心戳破包裹的那层蛋白，看着蛋黄液缓缓流出，流到刚烤好的外酥内嫩的 Waffle，或者煎好的卷饼，再或者最普通的吐司片，撒上几粒黑椒，配上一勺酸奶一勺凯撒酱，再夹着带着夏天色彩的翠绿芦笋和奶油草莓，咬上一口，偶尔再喝一杯加了热牛奶的红茶，整个人都被治愈了。</p>
<p>来北京后特别想念老家的山枣糕，每次家里寄过来一大包后，我可以大晚上一边看剧一边刷掉半斤。<br>
红薯南瓜酸枣加一把炒熟芝麻籽绝不能有紫苏，一口口下去特有嚼劲，满满的都是家乡的味道。<br>
饮食文化对人的影响是根深蒂固。</p>
<p>我是爱吃的，但是还是得控制体重，有时候这两者并不能完全平衡。<br>
所以某天抽风买了一大把特价处理的油麦菜，不带脑子地做了一盘极难吃的蒜蓉油麦菜，并且抱着修行的目的，以吃草的心态强迫自己吃完后，我终于泪流满面地站在厨房开始怀疑自己的人生。现在也想不通自己为什么泪流满面，可能和食物有关的情绪，没有为什么。</p>
<p>自己做饭，吃的都是自己喜欢的菜，导致体型愈发变得不受控制。<br>
下定决心要健身的一瞬间，是去年三月某天，我妈跟我说，你现在二十二岁，正是人生最美好的年华，可是你却还没拥有最美的姿态。<br>
那天夜里在房间一个人脱光了站在镜子前，望着里面臃肿圆肥的身体，配上萎靡的脸，颓废到自己在心里都嫌弃自己一万遍。</p>
<p>对啊，在最美好的年华里，我怎么能长成这个样子？<br>
第二天果断去了家旁边一个健身房。在那里，我见到了很多平时我会偷看的那些自带光芒的人。他们的美好的身体极具线条感，眼睛和皮肤闪着光，健身的时候姿态利落迷人。他们好像拥有了那个时候我想要拥有的一切。也许自律即自由。<br>
「我也要成为那样的人。」我在心里默默念着。
办了张卡，真正开始了自己的健身之旅。</p>
<p>健身，又是与自己的一次对话。<br>
力量训练的时候，你会感到你的肌肉逐渐被撕裂，又被拉长、继续生长。就像那个连自己都嫌弃的原来的臃肿的你，被渐渐撕碎，又慢慢组合成一个模样精致的人。
最大的改变是我从一个跑八百米都可以上气不接下气累到瘫倒的人，到现在渐渐可以跑一公里两公里五公里不喘气，意志也就是这样磨炼出来了。<br>
最喜欢的瞬间是终于结束了一次大汗淋漓的训练，洗完舒服的澡从健身房走出来，走在北京的大马路上，吹着口哨，我觉得我的脚下都生着风。<br>
当然过程中也会有懒惰想懈怠的时候，热爱长跑并且坚持长跑几十年的村上春树曾说「今天不想跑，所以才去跑，这才是长距离跑者的思维方式」。这句话真是一针强劲鸡血，坚持下来，熬过最开始那段时间后，我已经养成了「一天不运动不舒服斯基」的习惯。<br>
如果没有足够时间去健身房，我会在家自己 Keep，翻了下自己 Keep 训练记录：</p>
<p><img src="/content/images/2017/01/keep.jpg" alt="Keep-Record"></p>
<p>吃得健康，生活健康，整个人精神面貌改善很多，也更自信了。
希望自己能够热气腾腾自带光地活着。</p>
<hr>
<p><strong>走出去</strong></p>
<blockquote>
<p>生活平淡，报纸枯燥。
大胆和浪漫似乎已经在这个充满罪恶的世界上绝迹了。</p>
</blockquote>
<p>来北京后一直用 Swarm 记录自己去过的地方。
<img src="/content/images/2017/01/checkins.jpg" alt="My-Swarm-Checkins"></p>
<p>从在外省上大学起，到现在离家千里北漂，愈发认为自己的确是一个喜欢往外面走的人。<br>
喜欢新鲜感喜欢惊喜，喜欢明亮的高饱和度色彩，不喜欢死板不喜欢一成不变，而有时候出门透透气都能给我不一样的灵感。<br>
感谢大北京各种资源，刚来这的我，就尝试了好十几个同城相关的 App。<br>
周末早起把日常事务完成后，就会去逛店看展参加活动见新朋友，虽然有时候会一天赶三四个场子，从早到晚从东到西，横跨整个北京城，自带鸡血的我却累并快乐着。<br>
听喜欢乐队的现场，看色彩明亮的艺术展。程序员的工作做久了，有时候还是需要换换感性的脑子。<br>
也经历过凌晨十二点听完 Live 在北京二环冒着寒风打不到车，就在心里骂自己，天啊下次一定不买这么晚的票了，然而一旦有喜欢的乐队，无论什么时间点还是会继续来听。可能人活着的意义就是折腾。</p>
<p>有时候也想走得更远一点。<br>
“烟花三月下扬州”，一个人去了趟上海杭州，终于来到了之前 Dream School Top1 复旦。坐在光华楼前草坪上吹着风晒太阳，听到校园英语广播时候，我突然迎风流泪了。<br>
九月份和组里的人一起去了南京参加 JSConf，见到各路业界大神的同时，也逛了下夫子庙秦淮河。<br>
跨年时候去了大东北，沈阳和哈尔滨，南方孩子第一次见到那么多的雪和冰，内心是兴奋的。<br>
16 年最开心的一次旅行，是国庆一个人去云南旅行。
昆明大理丽江，九天三个城市，每天我都会满城市暴走，每天都不一样。睡眠一直不太好的我那几天却睡得格外好，躺在客栈，一瞬间爱上了第二天在异乡醒来的那种感觉。<br>
在大理环洱海骑行时候，左手边是一望无际的油菜花，更远处还有苍山，右手边是海天一色的洱海，一路鲜花，天很蓝，云很低，我就那么一直骑一直骑，好像很自由，好像内心的自己都释放了出来。<br></p>
<p><img src="/content/images/2017/01/erhai-img.jpg" alt="洱海"></p>
<p>以前去一个地方我总会规划很久，列一堆行程攻略，现在好像更喜欢即兴的旅行。<br>
当然这样说走就走的旅行代价是很高的，订错票走错车站错过火车这类事情基本碰到过，有段时间我基本自称为「出行杀手」。<br>
但其实人生无论什么选择都是要付出代价的。这样的即兴的旅行也是一次自我建设，依然是需要努力需要自律需要规划的。那样才不会换个地方依旧浑浑噩噩。
要是突然走不动或者没有兴致了，我就会提醒自己，「来都来了」，虽然很老套，但是很管用。<br>
走的都是国内的城市，风景可能大同小异，但是心情就迥然不同了。<br>
多去探索，多去感受，某个瞬间，经历的这些大大小小的事情会突然质变，成为自己一笔独一无二的财富。</p>
<p>“发自内心的开放度，要么来自天性，要么来自看过世界。”<br>
希望自己能够继续多看看世界。</p>
<hr>
<p><strong>与自己握手言和</strong></p>
<blockquote>
<p>对每个人而言，真正的职责只有一个：找到自我。
然后在心中坚守其一生，全心全意，永不停息。所以其它的路都是不完整的，是人的逃避方式，是对大众理想的懦弱回归，是随波逐流，是对内心的恐惧。</p>
</blockquote>
<p>这两年终于做到了一个人北漂一个人住，一个人上下班一个人工作，一个人做饭一个人吃，一个人锻炼，一个人逛街一个人旅行，一个人读书一个人看电影，一个人听很多的歌。<br>
这要是放在以前，应该是不敢想象的吧。</p>
<p>有人会问，全是一个人，你寂寞吗？<br>
但我觉得这应该是一种孤独。「寂寞会发慌，孤独则是饱满的。」<br>
享受孤独，保持灵魂的独立，在这个过程中与自己对话，与世界对话，倾听来自内心的真正声音，慢慢认识了自己，接纳了自己。<br>
终于与那个内向害羞易焦虑公众场合不擅长与人打交道的人握手言和。</p>
<p>其实内心里一直有个理想形态模样的自己，而感到很高兴的是，现在的我，正一步步向着那个理想的自己前进。<br>
「年轻就是相信自己还可以成为那个人，无论宇宙规律怎样，自己不设限不认命，还在为此努力。而让理想主义不会败给现实的方法，就是明知道一切都会被时间碾碎，也要微笑着冲上去。日复一日，虽千万人倦怠而吾往矣，才有机会成为极少数的人啊。」<br>
以上。</p>
<p>（题图来自手机里保存了很久的一张照片，心有猛虎，细嗅蔷薇）</p>
]]></description><link>/2017-01-14-2016-year-review/index.html</link><guid isPermaLink="true">/2017-01-14-2016-year-review/index.html</guid><category><![CDATA[thoughts]]></category><category><![CDATA[douban]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Sat, 14 Jan 2017 13:32:00 GMT</pubDate></item><item><title><![CDATA[跟随前进者的步伐]]></title><description><![CDATA[<p>每个人，在人生不同阶段，或多或少是需要一些鸡血的。</p>
<p>自从工作以来，也确实觉得自己懒癌，且很多事情缺乏自控力和自律。</p>
<p>只记得乔老爷子说过，</p>
<blockquote>
<p>自由从何而来？从自信来，而自信则是从自律来！先学会克制自己，用严格的日程表控制生活，才能在这种自律中不断磨练出自信。自信是对事情的控制能力，如果你连最基本的时间都做控制不了，还谈什么自信？</p>
</blockquote>
<p>是不是真的出自乔老爷子之口还没有经过求证，但当时看到这句话的时候，确实是突然会心一击。</p>
<p>一直想做起来的个人博客，无论是实实在在的文章内容，到表面的 UI / 主题 / 页面，再到更底层的网络优化 / VPS 配置 / 自动运维，这块真是在一拖再拖。</p>
<p>其实自己一直有在关注一些有意思的同行，这里先贴几个自己缺乏灵感的时候会去光临的个人网站清单。</p>
<p>（以下排名不分先后，暂时按语言维度分类）</p>
<h4 id="english">English</h4>
<ul>
<li><a href="https://www.nczonline.net/">Nicholas C. Zakas</a>
大名鼎鼎的 NCZ，博客朴实无华但是干货满满。别说你从没读过他写的东西。</li>
<li><a href="http://lea.verou.me/">Lea Verou</a>
真 · CSS 女王</li>
<li><a href="http://substack.net/">Substack</a>
好像什么领域都涉足的 Geek.</li>
<li><a href="https://toddmotto.com">Todd Motto</a>
Angular Creator @Google</li>
<li><a href="https://mathiasbynens.be/">Mathias Bynens</a>
Web 标准专家。除了 Web 领域牛逼以外，还涉足 Unicode &amp; Bash，Github Repos 可以闪瞎你的眼。</li>
<li><a href="http://stevesouders.com/">Steve Sounders</a>
在 Yahoo &amp; Google 工作过的大牛，专注性能。著有「高性能网站建设指南」。</li>
<li><a href="http://www.phpied.com/">Stoyan Stefanov</a>
超级爱写书的 Facebook 工程师。除了前端外，PHP 写得也挺好的。著有「面向对象的 JavaScript(1st, 2nd)」</li>
<li><a href="https://meowni.ca">Monica Dinosaurescu</a>
很好玩的 Emojineer。 Work @Google Polymer。</li>
<li><a href="http://simurai.com">Simurai</a>
什么都懂的 UI designer...</li>
<li><a href="marijnhaverbeke.nl">Marყ̈n Haverbeke</a>
著有「Eloquent JavaScript (1st, 2nd)」，好像长得也很帅。</li>
<li><a href="https://css-tricks.com/">Chris Coyier</a>
CSS Tricks 的创始人和维护者。介绍很多很棒的你肯定会用到的前端技巧。（其实他的个人网站<a href="http://chriscoyier.net/">在这</a>）</li>
<li><a href="kennethreitz.org">Kenneth Reitz</a>
Python Request 库维护者。唔，喜欢拿徕卡拍照且减肥成功的人生赢家。</li>
<li><a href="https://feross.org/">Feross Aboukhadijeh</a>
WebTorrent 作者之一。JS Standard Style 作者。斯坦福毕业的一小哥，兴趣爱好广泛。</li>
<li><a href="http://www.p01.org/">Mathieu &#39;p01&#39; Henri</a>
代码艺术家，JS1K 的积极参与和获奖者。A very COOL guy.<blockquote>
<p>Creative coder, technical speaker, demoscener, JavaScript developer and size optimizer extraordinary.</p>
</blockquote>
</li>
</ul>
<h4 id="chinese-">Chinese:</h4>
<ul>
<li><a href="https://imququ.com/">Jerry Qu</a>
360 的屈屈，高产技术博客作者。</li>
<li><a href="https://luolei.org/">罗磊</a>
前端工程师 @阅文。话说我真是关注他挺久了，一开始使用本博客平台 <code>Ghost</code> 也有这个原因。</li>
<li><a href="http://www.barretlee.com/">李靖 BarretLee</a>
小胡子哥。嗯，也是一个很厉害的前端，现在在淘宝工作，听说毕业前已经把犀牛书啃了 N 遍，所以 JS 非常扎实。</li>
<li><a href="http://www.zhangxinxu.com/">张鑫旭 Zhang Xinxu</a>
真 · CSS 男神，与 css-tricks 有得一拼。</li>
<li><a href="http://www.yangzhiping.com/">阳志平 Yang Zhiping</a> 主业是做认知神经学相关，当时知道他是他的博客有很多 Ruby 相关的东西，而且感觉读过很多书，写出来的东西挺有思想挺有启发的。貌似开了个「集智俱乐部」，专门用来提高人的心智。</li>
<li><a href="http://zhangwenli.com/">羡辙 Zhang Wenli</a> 一个挺厉害的前端妹子，上交毕业现在在阿里。写过一本 <code>Three.js</code> 小书。知道她是因为豆瓣上跟她共同标记过的书很多。很有思想，不仅技术厉害，一些文章也很对我胃口。这里再贴一下她的<a href="https://www.douban.com/people/ovilia1024/">豆瓣</a></li>
</ul>
<p>待补充。</p>
]]></description><link>/2016-10-22-follow-the-progressive/index.html</link><guid isPermaLink="true">/2016-10-22-follow-the-progressive/index.html</guid><category><![CDATA[learning]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Sat, 22 Oct 2016 08:34:00 GMT</pubDate></item><item><title><![CDATA[一个人没有音乐是可以生存，但他可能生活得不太好]]></title><description><![CDATA[<p>这是一篇关于<a href="https://book.douban.com/subject/1493169/">指尖下的音乐 Music at Your Fingertips</a> 的<a href="https://book.douban.com/review/8063271/">书评</a>。</p>
<hr>
<p>没想到，一本谈论「钢琴演奏」的书，居然充满了如此多的哲理。上升到的高度，就连并不是钢琴演奏者（比如我），都受益良多。</p>
<p>大师之所以成为大师，除了有过人的天赋外，一定与他们那些富有方法和技巧的刻意练习分不开关系。</p>
<p>这是在朝阳图书馆偶然发现的一本小书，内侧封面介绍说，作者是世界著名钢琴家 Ruth Slenczynska ，四岁就以音乐神童的身份演出，从艺七十多年以来已在世界各地举办了 3000 场以上的独奏会。Slenczynska 同时也是一位备受欢迎的音乐评审和音乐教育大师，一针见血地解决许多钢琴演奏上的问题，所以这本书算是习琴者必备参考书之一。</p>
<p>借了很久，今天终于抽出半天时间一口气看完，做了一晚上的笔记。</p>
<p>当时也正好自己是在学吉他的劲头上，对于现场演奏这块比较苦恼，想着各种器乐的学习和演奏都是通的，同时作为一个音乐爱好者，一直想对钢琴有所了解，于是翻开随意读了几页，渐渐发现，正如这本书的代序所说，这本书真的不仅仅是讲「如何练琴」这么简单，Slenczynska 对音乐的认识和见解，已经把普通的悉谱、练琴、演奏过程，小至分解到一个个音符、一段段乐句，大至上升到了音乐的高度，甚至于演奏者的生活方式及人生态度，或者更宽泛地说，三观。</p>
<p>总的来说，本书给我的最大感触有三点。</p>
<p>第一，Slenczynska 强调，学习音乐，应该先从学习如何「听」开始。此处她说的「听」，是一个人内在的听觉，那种能分辨心中的音乐与外在声音的「听力」。有点玄学，个人觉得应该就是进入自己心流以后，能把外界嘈杂噪音完全屏蔽掉，可以很好的聆听到来自内心的、想要的、真正的音乐。</p>
<p>第二，音乐就是一种语言，演奏音乐就是带着理解的情绪，把它表达出来。而完美的演奏就是需要「运用想象力」，从悉谱时想象作曲家当时在写这个音符、这个乐句的心意，到想象整个乐章、整个乐曲，演奏者自身应该以一种什么样的情绪来表达，最后想象演奏者自己坐在演奏厅，以一种什么样的方式来演奏。我们必须能先想象出音乐里每一个音符的音色，每一个乐句的走向，及整个作品欲表达的情感与气氛。有了想象后，还需要有能力把这些意念显明地传达出来。如此，我们创造出来的境界，才能马上在聆听者的心中引起共鸣，留下完整且深刻印象。</p>
<p>第三，音乐的吸收与表达，到了练习到最后，应该是身、心、琴三者合一，&quot;将钢琴视为我们身体的一部分，是具体讲述内心音乐思绪的延伸体。&quot; 当音乐完完全全进入你的潜意识，你才真正拥有它。&quot;一首精致的乐曲，我们不应仅止于「学会」它，更应该将之「吸收」进我们的体内，使它成为你我身体的一部分；不仅相似于你的手指、牙齿等器官，更形同你的心智，能够随着时间的更移而成长、成熟&quot;。将自己全身心投入进去，慢慢地你和你的作品会互相塑造、相互成长。真正热爱音乐的人，演奏出来的音乐才是优美的。</p>
<p>透过练琴，或者说「音乐」，读的时候，联想起了与自己也特别紧密编程、下厨、健身等，发现这些睿智的道理（说是又炖了一碗鸡汤也好，至少是好喝的能补的药效持久的鸡汤），也能适用在这些方面。</p>
<p>以下为一些手敲的书摘和自己林林总总的感悟。</p>
<hr>
<h5 id="-">译序 山丘上的木屋</h5>
<ol>
<li><p>打磨音符，其实就是在增强手指的力度，使这些手指在紧张下，不至于瘫痪，还能发出美丽的声音。打磨休止符，则是个奇怪的用语，但事实的确如此。过去我曾任意地忽视并遗弃休止符，现在都得正视它们存在的意义及正确的长度。音符磨亮后，我得像说话一样地注意乐句的标点符号、感情记号，我得呼吸，我得知道怎么唱、怎么跳、怎么用力。何时用单手指的力、何时用手臂的力、何时用身体的力。它们在音乐的表达上，皆有不同的目的。</p>
</li>
<li><p>稳定地爬出了一些成绩后，我被允许「行走」……这个阶段的音乐像极了放慢的影片，一切都是慢动作，但是音乐里所有的表情存在，音乐的张力亦被夸张地表现着，乐句有方向，线条间也有呼吸。</p>
</li>
<li><p>「如果你把自己局限在第二等钢琴家中，你就永远只能是第二等钢琴家。我是不愿意成为第二等的，我也不和别人计较，我只和最好的自己比较。如果我这一次做得好，下次我一定要更好。」</p>
</li>
<li><p>「横介于 &quot;很好&quot; 和 &quot;极佳&quot; 之间的一条线，是极其纤细的，你只要再多努力一点，再多加深一点感觉，再多加入一些想象，就跨过去了。」</p>
</li>
<li><p>我曾好奇地问老师，「为什么一些钢琴家，每天只要练习两个小时，上台就能生龙活虎，而我们却要花这么多时间？」她回答，「当我还是一个孩童的时候，我父亲总是对外宣布，他那天才般的女儿，一天只练习两个小时。而实际上，我每天必定练九个小时的琴。」</p>
<p>（Note：关于这点，Slenczynska 还写过一本自传，<a href="https://book.douban.com/subject/1464418/">琴恋</a>， 有书评说她的父亲对她练琴超级苛刻，也许天才的成长，也并不是那么一路鲜花。）</p>
</li>
<li><p>每一位学生均被指定弹奏两首乐曲，同时必须准备着所有人的乐谱，带着黑、红、蓝三种铅笔。以黑笔记下指法和细节，以红笔在巴赫的音乐里画出主题，再以蓝笔画出副主题。</p>
<p>​</p>
</li>
</ol>
<hr>
<h5 id="-">前言 三十年个人经验的累积</h5>
<ol>
<li><p>从我开始学习音乐起，老师们在教学上最强调的一件事，就是要我「用耳朵注意地听」（用耳朵去分辨声音），以一种非常开放、真诚、喜好研究的心态去学习任何一种美好的音色。同时，练习用耳朵去判断，确定自己所弹奏的音乐「听起来是对的」，而在这「听起来是对的」的前提下，任何能达到此目标的方法都可以使用。</p>
</li>
<li><p>一个优秀的音乐家必定对许多音乐以外的事物感到兴趣，这些兴趣只是因着内心的喜好而存在，没有丝毫额外的目的。</p>
</li>
<li><p>每一位钢琴家在技巧上所遇到的问题，都守着他们心理因素的影响。不论我们面临多么艰难的乐曲，只要我们心底有克服困难的愿望，除去了心理上的障碍，一切问题便简单多了。</p>
</li>
<li><p>「你是谁，你不过是一个九岁的孩子，为什么要将自己与成熟的钢琴家相比拟呢？你不应该在镜中看一个不实在的自己。从你弹奏的音乐里去了解音乐、与音乐沟通才是最重要的。」</p>
</li>
<li><p>事实上每一位伟大的艺术家，都是从学生的阶段一步步走过来的；消化了自己的理念，试验了诸多不同的练习方法和音乐观念，经历了无数次的失败、成功，通过知识的吸收、勤奋的练习，建立了乐观进取的人生观后，才发展成为一位具有独立风格的艺术家。虽然，一位赫赫有名的音乐巨匠与一位毫无一点演奏经验的学生所使用的都是同样的乐谱，然而，他们所表达的意义却迥然不同。其间的差异，便是他们有不同的感受与表达能力。</p>
<p>（Note：这里觉得，任何一位音乐巨匠、一位编程大师、一位厨艺高人、一位杰出的运动员，他们的成长方式应该都是异曲同工。）</p>
<p>​</p>
</li>
</ol>
<hr>
<h5 id="-">第一章 个人因素 —— 艺术家的成长</h5>
<ol>
<li>在音乐中，我们的耳朵绝对不会遗漏一个纯正艺术品所欲传达的精神。</li>
<li>身为一个音乐家，我们的音乐所能表达的，仅仅是真实的自我，不是他人；音乐就像一面镜子，赤裸裸地将自己反映出来。内心如有任何些微造作、虚伪与不真诚，我们都会感到羞耻，而在音乐中表露无遗。</li>
<li>我们也时常将经历到的灵感，小心翼翼地储藏在脑海里，当需要的时候，它们就从记忆里蹦出，像火花一般地点燃我们再创造的力量。</li>
<li>一位艺术家的形成，是由许多个人特殊的因素所发展出来的，如：高度的想象力、聪慧、灵敏、易于变通。处在任何环境下都有强烈的学习欲望；即使面临的是崎岖之路，仍然顽强地、辛勤地一步步向前走。</li>
<li>有时候，信心是我们唯一能够拥有的东西，它带领我们跨越了绝望的天堑。</li>
<li>爱做白日梦、幻想太多的音乐家，应该训练自己多做些练习。（Note：比如我..）</li>
<li>对一个演奏家来说，他的心、头脑和手是在一起工作的。这心充满了好奇与美，这头脑知道如何使情感得以宣泄，而手，在任何情况下，都能服从且实现心与脑所给予的音乐意念。</li>
<li>......我们之所以选择这朵花，主要是我们内心的一双眼睛已代替肉眼，看到花在未来绽放的情景。音乐的形成与此相去不远。在练习每首乐曲之初，我们必须能先想象出音乐里每一个音符的音色，每一个乐句的走向，及整个作品欲表达的情感与气氛。有了想象后，还需要有能力把这些意念显明地传达出来。如此，我们创造出来的境界，才能马上在聆听者的心中引起共鸣，留下完整且深刻印象。</li>
<li><p>音乐就像我们呼吸的空气一般，是人们生活中不可或缺的。音乐也是一种语言，比任何话语都更能打动人心。而能够在情感上与人们相互交流的音乐演奏，便是世间最光辉与神圣的荣耀，它使得极尽枯燥与单调平凡的联系，都变成了无比快乐的过程。</p>
<p>（Note： 感觉编程、做饭也是如此吧。开始之前，你脑海中要对你即将出现的作品已经有了个大概的轮廓，大师级别的甚至可能精确到了作品的每个小细节。在创作的时候，你得与自己的作品不断沟通，注入情感。到它终于完成，展现在他人面前，大家都能感受到作者满满的心思与心血。）</p>
</li>
</ol>
<hr>
<h5 id="-">第二章 音乐是一种语言</h5>
<ol>
<li><p>音乐是一种活生生的语言，比任何用口语说出的言词更易打动人心，表达深刻、强烈的情感；而演奏家就是音乐语言的叙述者。</p>
</li>
<li><p>李斯特曾说：‘’一个钢琴家在弹奏钢琴时，对自己的音乐应该持有十分严格的批评，这种批评就像发自另一位与自己有相同竞争力的钢琴家口中。“ 许多钢琴家在演奏时候，非常忙碌地制作音乐，而忘了用耳朵去听，这首因为他们在练习的时候，就没有聆听自己弹奏的习惯。因此，如果我们想给予自己的音乐一些建设性的批评，必须在练习时便训练自己用耳朵仔细地聆听。假想自己是一个听众，远远地坐在离钢琴右边 4 英尺的地方（那里是感情发声后，所有声音聚集的点），全神贯注地听着我们的音乐是否连贯，线条是否有意义，整首乐曲是否充满了音乐的起伏与流动。</p>
<p>（Note： 感觉这里编程和演奏很相似，平庸的程序员只是在非常忙碌地制造一堆代码，并不是真正意义上的「编程」，所以，在自己写代码的时候，要假设是在用白板编程，或者想象旁边正有一双眼睛在帮你 Code Review，这样才能真的进入状态。）</p>
</li>
<li><p>以“话语” 为钥匙。练习时，分析乐曲中每一个句子，然后用平静且能听得见的声音告诉自己，你认为某一乐句欲表现的情绪是什么：是愉悦、悲伤，还是思乡、抱怨？是痛苦、欢乐，还是热情、预言？在你决定了最适当的 “感觉” 后，将这种 “感觉” 在键盘上一次又一次做试验，直到你双手弹奏出来的音乐成功地呈现了先前在口语上给予自己的提示。很快，你便能透过音乐传达出自己的情感。</p>
</li>
<li><p>“渐弱” 只是单纯地在乐句的音量上慢慢减少，与节奏上的变化没有丝毫的关联。</p>
</li>
<li><p>直到多年后的一天，我突然发现，我并不满意其中一个音符的表达，这个不满意使我整个改变了自己对这首乐曲的解释。</p>
</li>
<li><p>当我们与一首乐曲一同成长时，总是不断地想在诠释上寻求更新的音色表现、更新的细节及意境。不论在过往的日子里，我们是如何感受着这首乐曲，这些感受皆会随着时光的更替，而变得半真实，那是再也无法重温的旧梦了。</p>
<p>（Note：就像自己一开始写的代码是为了业务快速上线，之后每隔一段时间对它不断修改重构，直到某天看到，发现整个感觉都变了。）</p>
</li>
<li><p>我从不在乐谱上做记号。因为我喜欢在每一次重新演奏某首乐曲时，都有新鲜的感觉。一些小细节很可能在上一次演奏时，并未被注意到，或是未能完全理解它们的意义，而在这一次却可以被发现，而给予整个乐句新的面貌及涵义。</p>
</li>
<li><p>绝大多数杰出的音乐作品都有一个完整的结构，在这个结构下，乐曲中每一个音符与细节都经过精心设计，它们在乐曲中有 一定位置。通常，一条长达乐句是有许多小乐句组合而成，而每一个小句子里有存在着许多更小的元素。单独看一个小句子与整体看一个大的乐句，在音乐的表现意义上是完全不同的。</p>
<p>（Note： 这里和编程阅读一些著名项目的源码，下厨做一些口感层次丰富的大菜一样，要学会从一开始就拆解它们。）</p>
</li>
<li><p>三步找到乐句中表达的重点:</p>
<ol>
<li>全神贯注地将音乐线条完整地弹出来，没有丝毫间断。</li>
<li>决定乐句的气氛，而后使每一个音符与细节都在这个氛围的引导下被弹奏。</li>
<li>找出乐句或段落中的最高点，使音乐在进行时有一个移动的方向。</li>
</ol>
</li>
<li><p>肖邦：“钢琴家应该尽可能地在最准确／最好的钢琴上做练习，因为那将使我们的耳朵熟悉最优美的声音。</p>
<p>（Note：同样，编程应该用比较好的硬件和软件设备，阅读优秀的代码，熟悉优美的设计实现。）</p>
</li>
<li><p>运用&quot;想象力的练习&quot;。</p>
<p>（Note: Fake it till you make it.）</p>
</li>
</ol>
<hr>
<h5 id="-">第三章 培养均衡地弹奏的能力</h5>
<ol>
<li><p>如此随心所欲的音乐表达，却是经过长时间仔细推敲、不断磨练，注重音乐中每一个音符、休止符的正确弹奏，不放弃乐谱上任何隐秘线条与音色的探索之，所获得的能力。</p>
</li>
<li><p>节拍器是练习必备的工具。先从很慢的速度，60 开始，然后 62 — 64 — 66 等，一点点快起来。掌握好后，再从 60 开始， 63 — 66 — 69， 以 3 的速度，熟练后以 4 的速度， 64 — 68 — 72。再以 5 的速度 60 — 65 — 70 — 75 — 80 来练习。</p>
</li>
<li><p>耳朵的重要性。</p>
</li>
<li><p>李斯特的练琴方法：开始练习一首新的乐曲时，总是以很慢的步骤分五步研究乐谱：</p>
<ol>
<li>第一次看谱，仔细地看清楚每一个音符确实的位置；</li>
<li>第二次则分辨音符的时值；</li>
<li>第三次，分析乐句的音色，由不同的音色来表达情感上细微的变化；</li>
<li>第四次，仔细地分析高低谱表内所有的声部，除了明显的主题外，他总希望能再找到一些可以醒目加强的细小旋律和线条；</li>
<li>最后，他决定他要的速度。</li>
<li>结束看谱后，他再开始在琴键上练习。</li>
</ol>
<p>他不断地从音乐的弹奏里，分析自己情绪上的翻译。每当一段激烈的乐段过去后，他便思考，应以何种方式，自然地延续热情过后松弛的感觉：是冷淡的情绪？抑或是疲累的感受？他非常坚持钢琴家必须绝对地投入音乐的弹奏，因为唯有如此，才会有真正属于个人的诠释产生。</p>
<p>而在绝对投入之前，钢琴家的双手必须在键盘上已有完全控制琴键的能力。</p>
<p>「绝对不要让你那不听使唤的双手，阻碍了你艺术家般的诠释。」</p>
<p>（Note：</p>
<p>​    读这段话的时候，想到之前练吉他的时候，会刻意练习自己不去看品格并且边练边背谱子，可是还需要有分析每个音符情绪的境界；</p>
<p>​    编程的时候需要对键盘布局、快捷键操作足够熟悉，让打字的节奏跟上思维的节奏。后来自己写代码的时候会更加刻意练习特殊字符，如 #$%^&amp;*( 的输入；</p>
<p>​    关于下厨，想到昨天看了一篇对名厨大董（对就是那个大董烤鸭店的大董）的报道，他说到自己原来准备比赛来练习做菜的时候，会达到闭着眼睛也能放对调料的境界。）</p>
</li>
<li><p>节拍器的训练可以建立自然反应的律动感。</p>
<p>以节拍器上各种速度背谱，迫使我们在不同的速度里重复清晰地听到每一乐段的音符，音乐里各个细节便稳固地存于我们脑海中。</p>
</li>
<li><p>运用节拍器慢速度训练去克服所有技巧上的障碍，进而除掉对节拍器的依赖。之后需要训练双手能自由肯定地出入琴键。</p>
</li>
</ol>
<hr>
<h5 id="-">第四章 练习的秘诀</h5>
<ol>
<li><p>身为一位演奏者，我们必须将钢琴视为我们身体的一部分，是具体讲述内心音乐思绪的延伸体。</p>
</li>
<li><p>我们唯有从缓慢、艰苦、不抄捷径、同一时段只专注于一件事的练习过程里，才能得到我们欲求的能力。虽然，我们是那么的平凡，但是却可以在该工作的生活辛勤工作，在能够轻松的时候自在逍遥。</p>
</li>
<li><p>在钢琴的演奏上，并没有完全无法克服的困难，所有的症结都只是在于你是否下定决心去克服它。世界上没有任何一个人、没有任何一本书，能够给予我们解决所有问题的答案。最能够解决困难的方法，就存在于你自己的头脑、你的内心，以及你的双手中。</p>
<p>（Note：也许所有的器乐演奏也是如此，所有的工作，所有的学习也是如此。）</p>
</li>
</ol>
<hr>
<h5 id="-">第五章 音乐的吸收与传达</h5>
<ol>
<li><p>一首精致的乐曲，我们不应仅止于「学会」它，更应该将之「吸收」进我们的体内，使它成为你我身体的一部分；不仅相似于你的手指、牙齿等器官，更形同你的心智，能够随着时间的更移而成长、成熟。</p>
</li>
<li><p>你必须毫不迟疑地为这首音乐所「吸引」住。你的心情就像是陷入了热恋，被这音乐迷得神魂颠倒、心荡神怡，内心燃烧着巨大的热情想要得到她，甚至愿意奉献出所有的努力，改正所有自我在表达上的缺点与弱点。而一件真正的艺术品，正是需要我们付出相当大的代价后，才能完全地拥为己有。</p>
</li>
<li><p>一位优秀的钢琴家应该从内心去熟知他的音乐，甚至可以正确地写下所弹奏的音符。</p>
</li>
<li><p>训练自己从外界环境的改变中独立出来，不受任何客观因素的干扰，是作为一位演奏家最根本应该掌握的筹码。</p>
</li>
<li><p>给予青年学习者的忠告：</p>
<ol>
<li><p>「最黑暗的时刻总是出现于黎明前。」在练习乐曲过程中，千万不要轻易气馁。</p>
</li>
<li><p>不论什么时候，你身在何处，一定要随身携带乐谱。一旦你在记忆上或是音乐的表达上有一丁点疑问，都可以立即查询。「因为，&quot;贝多芬&quot;是那么写在乐谱上的。」</p>
</li>
<li><p>演奏一首乐曲，切勿太过分地加重弹奏那些需要强调的音符，及没有任何强音记号的音符。</p>
</li>
<li><p>不要「夸张」地做老师给你的建议。不应该在不同的乐曲上运用相同的演奏方式，除非它们在音乐的表达上有相似的特质。</p>
</li>
<li><p>避免将自我塑造成一个保守主义的演奏者。</p>
<p>由自然、不压抑的身躯里释放出来的音乐才是健康优美的，而放松自由的弹奏技巧永远值得热爱音乐的人勇于一试。</p>
</li>
</ol>
<p>（Note：真正热爱音乐的人，演奏出来的音乐才是优美的。</p>
<p>​        真正热爱编程的人，编写出来的代码才是优美的。</p>
<p>​        真正热爱下厨的人，烧出来的菜才是优美的。）</p>
<p>​</p>
</li>
</ol>
<hr>
<h5 id="-">第六章 钢琴曲目的建立</h5>
<ol>
<li><p>大多数杰出的作曲家都是钢琴家，他们喜爱钢琴远远超过弦乐器。钢琴天生具备了和声及多线条的自然效果，在自我的表达上能够给予艺术家们最大的满足感。</p>
</li>
<li><p>「演奏适于发挥自我特质的乐曲。」</p>
<p>（Note：已经涉及到了成名前后个人气质是塑造。）</p>
</li>
</ol>
<hr>
<p>第七、八、九章都是作者自己整理和总结的，一些非常适合用来练习某些演奏技巧的经典曲目，满满的五线谱片段，所以并没有太仔细看。</p>
<p>但是作者在讲的时候把那些片段都很用心地按小节进行了拆分讲解，读者若是钢琴演奏学生应该受益匪浅。</p>
<hr>
<h5 id="-">第九章 完整的准备演奏曲目</h5>
<ol>
<li><p>练习1： 从最艰难的作品着手练习；</p>
<p>练习2： 将所有曲目分三个部分。</p>
</li>
<li><p>塑造音乐时脑海里要有完整的意念。</p>
</li>
<li><p>在一个演奏季里弹奏 50 场音乐会，比弹奏 10 场要来得容易。因为演奏得愈多，愈能保持肢体与头脑的活力，故愈弹奏变愈轻松。持续不断的演出，可以让你的音乐永葆光亮。</p>
</li>
<li><p>艺术家是不可以等待灵感到来的时候才工作，他的职责是随时随地都能创造出音乐的气氛，为他自己，也为他的听众。良好的练习让我们保持灵敏的手指，即使有时候头脑处于空白状况下，它们依然能有好品质的演出能力，使音乐能够深入聆听者的内心。</p>
<p>（Note：</p>
<p>​    关于灵感，这里想起曾经有人问李敖他靠不靠灵感写作，李敖回答：「妓女不靠性欲接客，我不靠灵感写作」。话糙理不糙。</p>
<p>​    热爱长跑并且坚持长跑几十年的村上春树说过同样的话：「今天不想跑，所以才去跑，这才是长距离跑者的思维方式。」</p>
<p>​    这两段话在自己才开始健身，懒惰想懈怠的时候一针强劲鸡血。现在坚持健身锻炼差不多四个月，已经形成了「一天不运动不舒服斯基」的习惯，整个人精神面貌改善很多，收获非常大。</p>
</li>
<li><p>我非常相信演出时的怯场，有百分之九十是来自平日训练的不足，只有百分之十是来自害怕。</p>
</li>
</ol>
<hr>
<h5 id="-">第十章 听的艺术</h5>
<ol>
<li><p>欲成为有深度有见地的聆听者，必须广泛接触音乐。</p>
</li>
<li><p>聆听者应该了解作曲家及乐谱。</p>
<p>诚实地选出你较喜欢的音乐，了解作曲家及乐谱，并从演奏的观点及你个人的感觉来分析所听到的演奏。</p>
<ol>
<li>分析出乐曲被创作的年代：古典？浪漫？印象还是现代？</li>
<li>乐曲的旋律或节奏是否具有某一个国家特有的音乐色彩语言？</li>
<li>乐曲的旋律或和声特征是否使你想起某一个作曲家的作品？</li>
</ol>
</li>
</ol>
<hr>
<h5 id="-">第十一章 我的教学经验</h5>
<ol>
<li>「一个人是可以没有音乐而生存，但是他不会活得太好。」</li>
</ol>
<hr>
<h5 id="-">第十二章 无声练习</h5>
<p>视奏练习：不依赖眼睛，双手找琴键。</p>
<p>（Note：练习视觉和触觉）</p>
<h5 id="-">第十三章 录音机的效用</h5>
<ol>
<li>聆听自己的录音，可以刺激出客观批评</li>
<li>录音机用来辅助背谱。试着将一些由慢速到快速，没有错误的练习录下来，然后在练琴以外的时刻小声的播放，可以一直听一直听，直到这首乐曲的所有音符都在你脑海里生根为止。每个星期都重新录一次，不断重复地听一首乐曲，「重复」可以打破我们内在精神里那道无形的硬壳，直入我们的潜意识。人的记忆分三个方向进行：听觉、视觉及触觉。</li>
<li>录音机帮助练习协奏曲 （Note：相当于练习乐队排练）</li>
<li>利用录音机与音乐沟通</li>
<li>每个星期对着录音机演奏，当众演奏水平就能提高</li>
</ol>
<p>（Note：练习听觉。想起之前练习口语，会反复把自己的声音录下来，然后不断修改语法语调语气。在学吉他时，当练习一些演出曲目，也有尝试每次用手机 Video 录下来。虽然还只是自己拍自己，整个感觉就不一样了。就像把自己置于演出环境下，你会更加认真对待每次的练习，事倍功半。）</p>
<hr>
<h5 id="-">第十六章 如何走上演奏台</h5>
<ol>
<li><p>乐曲经过完整的练习及背谱之后，应即刻上台实际弹奏，永远等不到流畅的那天，所以早一些把手上的音乐拿到演奏台上去演奏，才会收获更多有价值的经验。</p>
</li>
<li><p>找一位愿意聆听的朋友来听演奏。</p>
</li>
<li><p>小的音乐家表现小的音乐观念，大的音乐家表现大的音乐观念。</p>
</li>
<li><p>熟知音乐的每一段落，以备紧急之需......各种速度练习六遍以上，必须养成追求完美技巧的习惯。</p>
</li>
<li><p>早期的演奏以舒适从容的速度弹奏。</p>
</li>
<li><p>音乐只有在完全进入潜意识后才为人们所拥有。</p>
</li>
<li><p>记忆模糊时应马上打开乐谱仔细复习  在一特别乐段上可以用不同的方法轮流练习。</p>
</li>
<li><p>养成一坐到钢琴前便弹奏开场曲的习惯。</p>
</li>
<li><p>世界上没有一场演奏会是完美无缺的，遇到惨痛失败时，要坚信必有成功的一天。</p>
<p>「怯场是最糟糕的音乐自觉」</p>
<p>钢琴家唯有在忘却了最根本的技术问题时，才能开始自由地创造音乐。作为一位艺术家，你必须把你自己完全地投注于你的音乐；在那短暂时光中所创造出的满足感，就是你在经过了所有努力之后，得到的最大回报。它们是上天给予你最神奇的礼物！</p>
</li>
</ol>
]]></description><link>/2016-08-28-review-music-at-your-fingertips/index.html</link><guid isPermaLink="true">/2016-08-28-review-music-at-your-fingertips/index.html</guid><category><![CDATA[notes]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Sun, 28 Aug 2016 05:58:00 GMT</pubDate></item><item><title><![CDATA[移动环境下的 SEO]]></title><description><![CDATA[<p>真的有很久很久没来理这个博客，距离上一篇文章的发布日期是两年前。
毕业工作后来了豆瓣，最近对移动环境（主要是浏览器及微信）的 SEO 相关进行了下研究，正好在这里分享一下。</p>
<p>以下，Enjoy。</p>
<hr>
<h3 id="1-seo-search-engine-optimazition">1. SEO：Search Engine Optimazition</h3>
<p>产品：搜索引擎优化，促进内容网站信息分享／传播，提高目标转化率，留存率</p>
<p>工程：为各类页面实现统一的信息分享、传播，提高搜索排名（search ranking）</p>
<p>个人觉得：</p>
<ul>
<li>豆瓣是一个内容网站，拥有一些 UGC 优质内容，SEO 间接帮助用户分享。
且分享率越高，也会提高搜索排名。</li>
<li>M 站的目前面向<strong> 人（User） </strong>的 UX 比较完善，但是仍需要丰富一些细节，让 <strong>Search Engine</strong> 的 UX 更好，更好地理解 M 站。</li>
</ul>
<h3 id="2-seo-">2. 前端在 SEO 中的位置</h3>
<ul>
<li><strong>帮助产品进行TDK （Title / Description / Keyword）优化</strong></li>
<li><strong>添加一些 Social Meta Tag （Facebook / Twitter / G+ / WeChat / Weibo）</strong></li>
<li>页面内容优化（HTML5 标签语义化、唯一的 H1 标题、img 设置 <code>alt</code> 属性，不需要爬虫跟踪的链接加 <code>nofollow</code>）</li>
<li>URL 优化 (<strong>canonical</strong>，标签表示页面的唯一性)<ul>
<li>在搜索引擎里，<strong>只有链接完全一样，才会认为是同一个链接</strong>，如果链接带上参数，虽然访问到的内容还是一样，但是在搜索引擎看来确是不同的链接，页面抓取也会出现多次，从而导致多个链接，内容一样。</li>
<li>因此 URL 中最好是不要带上查询参数。但为了产品统计数据，总需要 <code>?from=xxx&amp;refer=xxx</code>等参数，所以使用 <code>canonical</code>标签来确保链接唯一性，避免权重分散、流失。</li>
<li>比如 <code>m.douban.com/group/topics[?start=xxx]</code>均视为同一个页面这里的 <code>?start=xxx</code>是一个分页查询参数，所以为了确保这些页面都能继承 m.douban.group/toics 这个 url  的权重，在<code>head</code>中增加了<code>canonical</code>标签</li>
</ul>
</li>
<li>Meta robots</li>
<li>Sitemap</li>
</ul>
<h3 id="3-">3. 具体实现</h3>
<blockquote>
<p><strong>统一 SNS 抓取</strong></p>
<p>提供一个 mako 函数，统一分享的标题、图片、描述</p>
<ul>
<li>Open Graph</li>
<li>Twitter Card</li>
</ul>
<p><strong>实现统一的分享接口</strong></p>
<p>可变的图片、标题、描述</p>
<ul>
<li><p>微信 （iOS、Android 系统分享菜单、微信内置分享）</p>
</li>
<li><ul>
<li>外部调用分享可能会抓取标题、第一个图片地址（Open Graph）</li>
<li>调用内置分享可用第三个链接 (API 跨子域)</li>
</ul>
</li>
<li><p>微博</p>
</li>
</ul>
<p>参考链接：</p>
<p><a href="https://developers.facebook.com/docs/sharing/opengraph">https://developers.facebook.com/docs/sharing/opengraph</a></p>
<p><a href="https://dev.twitter.com/cards/overview">https://dev.twitter.com/cards/overview</a></p>
<p><a href="http://github.intra.douban.com/frodo/Talion/blob/master/views/j/wechat/__init__.py">http://github.intra.douban.com/frodo/Talion/blob/master/views/j/wechat/<strong>init</strong>.py</a> </p>
<p>— From <a href="https://paper.dropbox.com/doc/-SEO-UVIgU3WYPUeiJv3nOPP0N">Douban FE Dropbox</a></p>
</blockquote>
<h3 id="-">实现方案</h3>
<h4 id="1-seo_meta-mako-widget">1. 增加了 <code>seo_meta()</code> Mako widget</h4>
<p> <a href="http://github.intra.douban.com/frodo/Talion/blob/master/templates/card/widgets.html#L527">http://github.intra.douban.com/frodo/Talion/blob/master/templates/card/widgets.html#L527</a></p>
<pre class="hljs"><code><span class="xml"></span>&lt;%<span class="perl">def name=<span class="hljs-string">&quot;seo_meta(title, desc, image=None, url=None, type=None, rating_count=None, rating_val=None, wechat_timeline_title=None,wechat_chat_title=None, wechat_desc=None, wechat_image=None)&quot;</span>&gt;
    &lt;%
        from douban.image.qiniu import qiniu_proxy_url

        default_title = <span class="hljs-string">&#39;豆瓣&#39;</span>
        default_desc = <span class="hljs-string">&#39;读书、看电影、涨知识、学穿搭...，加入兴趣小组，获得达人们的高质量生活经验，找到有相同爱好的小伙伴。&#39;</span>
        default_image = static(<span class="hljs-string">&#39;/pics/icon/m_logo_180.png&#39;</span>)
        default_url = <span class="hljs-string">&#39;<a href="http://m.douban.com/">http://m.douban.com/</a>&#39;</span>
        default_type = <span class="hljs-string">&#39;article&#39;</span>
        image = qiniu_proxy_url(image, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>, mode=<span class="hljs-string">&#39;1&#39;</span>) <span class="hljs-keyword">if</span> image <span class="hljs-keyword">else</span> <span class="hljs-string">&#39;&#39;</span>
    </span>%&gt;<span class="xml">
    <span class="hljs-comment">&lt;!-- Schema.org markup for Google+ --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;name&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ title or default_title }&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ desc or default_desc }&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span>&gt;</span>
</span><span class="perl">    % <span class="hljs-keyword">if</span> rating_count:</span><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;reviewCount&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ rating_count }&quot;</span>&gt;</span>
</span><span class="perl">    % endif</span><span class="xml">
</span><span class="perl">    % <span class="hljs-keyword">if</span> rating_val:</span><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;ratingValue&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ rating_val }&quot;</span>&gt;</span>
</span><span class="perl">    % endif</span><span class="xml">
    <span class="hljs-comment">&lt;!-- Twitter meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;twitter:card&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;summary&quot;</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- Open Graph meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ title or default_title }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ desc or default_desc }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:site_name&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;豆瓣(手机版)&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:url&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ url or default_url }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:type&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;image/png&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:width&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;300&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:height&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;300&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:type&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ type or default_type }&quot;</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- Wechat meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:timeline_title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_timeline_title or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:chat_title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_chat_title or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_desc or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span> /&gt;</span>
    </span>&lt;%<span class="perl">block filter=<span class="hljs-string">&quot;collect_js&quot;</span>&gt;
    ;(function () {
        window.setMeta = function (name, val) {
          var meta = document.querySelectorAll(<span class="hljs-string">&#39;meta[property=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;], meta[name=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;]&#39;</span>)
          <span class="hljs-keyword">if</span> (!meta.<span class="hljs-keyword">length</span>) {
            meta = document.createElement(<span class="hljs-string">&#39;meta&#39;</span>)
            meta.name = name
            document.head.appendChild(meta)
          }
         meta[<span class="hljs-number">0</span>].content = val || <span class="hljs-string">&#39;&#39;</span>
        }
        window.getMeta = function (name) {
          var meta = document.querySelectorAll(<span class="hljs-string">&#39;meta[property=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;], meta[name=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;]&#39;</span>)
          <span class="hljs-keyword">if</span> (!meta.<span class="hljs-keyword">length</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;&#39;</span>
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> meta[<span class="hljs-number">0</span>].content
          }
        }
        setMeta(<span class="hljs-string">&#39;og:url&#39;</span>, location.href)
        !getMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>, document.title)
        !getMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>, document.title)
        !getMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>, getMeta(<span class="hljs-string">&#39;og:description&#39;</span>))
    })();
    &lt;<span class="hljs-regexp">/%block&gt;
&lt;/</span><span class="hljs-variable">%def</span>&gt;</span></code></pre><h4 id="2-m-seo-meta-tags">2. 给 m 站大部分页面增加了 SEO Meta Tags</h4>
<p>之前分享出去抓不到自定义的 description 和 image ，现默认分享到 weixin 的 title 、 description 、image 值都和 Open Graph 一样，也可以自定义。</p>
<p>默认情况下</p>
<ul>
<li><code>og:title</code>， <code>og:description</code> 和之前的 title, description 一样；</li>
</ul>
<ul>
<li><code>og:url</code> ： 当前页面 url；</li>
<li><code>og:image</code>：<ul>
<li>小组帖子页和单个日记页如有图片，则为第一张图片的 src url，没有的话为现在默认的分享 icon src url；</li>
<li>条目页的均为该条目的 image src url；</li>
<li>相册页为该相册第一张 image src；</li>
<li>豆列、标签页为默认的分享 icon src</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Hashtag 页</strong></p>
<ul>
<li>image: 运营头图 || 豆 icon；</li>
<li>title: { hashtag_name} - 豆瓣；</li>
<li>description: 运营描述 || &#39;有关#{ hashtag_name }#的话题讨论，豆瓣用户参与的精彩话题&#39;；</li>
</ul>
</li>
<li><p><strong>单条广播页</strong></p>
<ul>
<li>微信聊天、朋友圈：image =  广播第一张图 || 豆 icon；</li>
<li>微信聊天页： title = XXX 的豆瓣广播; description = 广播文字内容的前十五个字 || 默认的 m 站描述；</li>
<li>微信朋友圈： title = 广播文字内容前十五个字 || XXX 的豆瓣广播</li>
</ul>
</li>
<li><p>关于 image 图片规格：</p>
<p>为了使抓取的图片更优雅，不被压缩变形，使用「七牛图片服务」进行剪裁。</p>
<p>默认 <code>og:image</code> 等 image 均会被以 <code>width = height = 300</code> 进行处理。</p>
<ul>
<li><a href="http://github.intra.douban.com/frodo/Talion/tree/23fe149cc3186f15195634cca774861d3ce9efca">Talion</a>/<a href="http://github.intra.douban.com/frodo/Talion/tree/23fe149cc3186f15195634cca774861d3ce9efca/libs">libs</a>/<strong>image.py</strong></li>
<li><a href="http://github.intra.douban.com/frodo/Talion/blob/23fe149cc3186f15195634cca774861d3ce9efca/libs/image.py#L11">http://github.intra.douban.com/frodo/Talion/blob/23fe149cc3186f15195634cca774861d3ce9efca/libs/image.py#L11</a></li>
<li><code>from douban.image.qiniu import qiniu_proxy_url</code></li>
</ul>
<p>​</p>
</li>
</ul>
<p>效果截屏：</p>
<p><a href="http://github.intra.douban.com/frodo/Talion/pull/253">http://github.intra.douban.com/frodo/Talion/pull/253</a></p>
<p>（补图）</p>
<p>(<a href="http://p.dapps.douban.com/p/38c24dc31b4d482c8095083995e43d00.blob">http://p.dapps.douban.com/p/38c24dc31b4d482c8095083995e43d00.blob</a>)</p>
<p><a href="http://p.dapps.douban.com/p/78b40c471bab42209a0cb8ee2283c974.blob">http://p.dapps.douban.com/p/78b40c471bab42209a0cb8ee2283c974.blob</a></p>
<h4 id="3-">3. 统一分享接口（微信重度使用患者）</h4>
<ul>
<li><a href="http://github.intra.douban.com/frodo/Talion/blob/master/static/js/card/weixin.js#L52">weixin.js</a>、 <a href="https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html#.E5.88.86.E4.BA.AB.E6.8E.A5.E5.8F.A3">微信 JSSDK 文档</a></li>
</ul>
<pre class="hljs"><code>
          wx.onMenuShareTimeline($.extend({}, shareData,{
              title: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>) || <span class="hljs-built_in">document</span>.title,
              success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                  wxShareStat.target = <span class="hljs-string">&#39;timeline&#39;</span>;
                  $.get(<span class="hljs-string">&#39;/j/wechat/shared&#39;</span>, wxShareStat);
              },
              cancel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
          }));

          wx.onMenuShareAppMessage($.extend({}, shareData,{
              title: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>) || <span class="hljs-built_in">document</span>.title,
              desc: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>) || <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;og:description&#39;</span>),
              success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                  wxShareStat.target = <span class="hljs-string">&#39;friend&#39;</span>;
                  $.get(<span class="hljs-string">&#39;/j/wechat/shared&#39;</span>, wxShareStat);
              },
              cancel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
          }));</code></pre><p>  结合使用 <code>meta[name=&quot;weixin:image&quot;]</code></p>
<pre class="hljs"><code>      &lt;meta property=<span class="hljs-string">&quot;weixin:timeline_title&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_timeline_title <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
      &lt;meta property=<span class="hljs-string">&quot;weixin:chat_title&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_chat_title <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
      &lt;meta property=<span class="hljs-string">&quot;weixin:description&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_desc <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
      &lt;meta property=<span class="hljs-string">&quot;weixin:image&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ image <span class="hljs-keyword">or</span> default_image }</span>&quot;</span> /&gt;</code></pre><p>  ​</p>
<ul>
<li><p>自定义微信分享到聊天、朋友圈的显示内容，文案<code>setMeta()</code>, <code>getMeta()</code></p>
</li>
<li><p><strong>Tips:</strong> 如果没有设置 <code>wx.onMenuShareTimeline()</code>/ <code>wx.onMenuShareAppMessage()</code> 中的 title / imgUrl / desc 参数，微信内置浏览器默认抓取对应的<code>og:xxx</code> 相关。</p>
</li>
<li><p><strong>Bugs:</strong> 通过 Safari Extension 分享出来的永远抓的是 <code>apple-touch-icon</code> 😂</p>
</li>
</ul>
<pre class="hljs"><code>  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;<a href="https://img3.doubanio.com/f/talion/315ba4fc82e5cdb5c50ef1d9f88c8aa2c5c0c4ba/pics/icon/m_logo_76.png">https://img3.doubanio.com/f/talion/315ba4fc82e5cdb5c50ef1d9f88c8aa2c5c0c4ba/pics/icon/m_logo_76.png</a>&quot;</span>&gt;</span></code></pre><h3 id="further-reading-resource">Further Reading &amp; Resource</h3>
<ol>
<li>Sitemap &amp; <a href="http://baiduseoguide.com/news/20141128113.html">Deadlink</a></li>
<li>Social Meta Tag Cheatsheet</li>
<li>Google SEO TOP1: Baidu Baike 😂</li>
<li><a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/MetaTags.html">Apple Safari supported meta tags</a></li>
<li><a href="http://static.googleusercontent.com/media/www.google.com/en//webmasters/docs/search-engine-optimization-starter-guide.pdf">Google SEO search-engine-optimization-starter-guide</a></li>
<li>Google 结构化数据标记辅助工具</li>
<li><a href="http://www.hobo-web.co.uk/seo-tutorial/">SEO Tutorial</a></li>
<li><a href="http://www.ghugo.com/jd-seo/">京东 SEO</a></li>
<li>SEO Tools<ul>
<li><a href="https://www.google.com/webmasters/">Google Webmasters Search Console</a></li>
<li><a href="https://varvy.com/tools/">Varvy SEO tool</a></li>
<li><a href="http://keywordtool.io/">Keyword Tool</a></li>
</ul>
</li>
</ol>
]]></description><link>/2016-05-20-seo-in-mobile/index.html</link><guid isPermaLink="true">/2016-05-20-seo-in-mobile/index.html</guid><category><![CDATA[SEO]]></category><category><![CDATA[shares]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Thu, 19 May 2016 18:21:00 GMT</pubDate></item><item><title><![CDATA[[译]前端指南]]></title><description><![CDATA[<p><strong>Update</strong>
以下大概写于两年前，亟待更新。</p>
<hr>
<p>几天前从Github上看到了这篇<a href="https://github.com/bendc/frontend-guidelines">前端编码最佳实践</a>，Star数已破4K，觉得应该是篇不错的小指南，花了点时间将它稍作翻译，也当是复习复习 <code>HTML&amp;CSS&amp;JS</code>。
翻译时随手参照了《CSS设计指南》、《精通CSS-2ndEdition》、老道的《JavaScript语言精粹》、NZ大神的《JavaScript高级程序设计》，在学习了一些专有名词表达同时，也学到了许多有用的代码和思想。
不过原作者好像是<code>CoffeeScript</code>爱好者，且广泛使用了<code>ES6</code>特性，所以有些名词和表达我暂未理解透彻，还需斟酌。故现将原文译文参照排版，还待之后的更新。</p>
<hr>
<h2 id="html">HTML</h2>
<p>###语义化（Semantics）
HTML5 provides us with lots of semantic elements aimed to describe precisely the content. Make sure you benefit from its rich vocabulary.
HTML5 给我们提供了大量的语义化元素标签去准确的描述元素内容。确保你从它的丰富的词汇中获益。</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">&quot;main&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;article&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;header&quot;</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Blog post<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Published: <span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>21st Feb, 2015<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>…<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">article</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">header</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Blog post<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Published: <span class="hljs-tag">&lt;<span class="hljs-title">time</span> <span class="hljs-attribute">datetime</span>=<span class="hljs-value">&quot;2015-02-21&quot;</span>&gt;</span>21st Feb, 2015<span class="hljs-tag">&lt;/<span class="hljs-title">time</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-title">header</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>…<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">article</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">main</span>&gt;</span></code></pre><p>Make sure you understand the semantic of the elements you&#39;re using. It&#39;s worse to use a semantic element in a wrong way than staying neutral.
确保你理解你正在使用的元素的语义。错误的使用一个语义化标签元素比保持中立更糟糕。</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">figure</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">Company</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">logo.png</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">figure</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>

<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">Company</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">logo.png</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span></code></pre><p>简洁（Brevity）
Keep your code terse. Forget about your old XHTML habits.
保持你代码的简洁精练。把你的老掉牙XHTML习惯忘掉吧。</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">en</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">Content-Type</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">stylesheet</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">style.css</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">text</span>/<span class="hljs-attribute">css</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Contact me<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
      Email address:
      <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">email</span> <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">you@email.com</span> <span class="hljs-attribute">required</span>=<span class="hljs-value">required</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">main.js</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">text</span>/<span class="hljs-attribute">javascript</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>

<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">en</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">stylesheet</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">style.css</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Contact me<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
    Email address:
    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">email</span> <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">you@email.com</span> <span class="hljs-attribute">required</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">main.js</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre><p> 容易理解（Accessibility）
 Accessibility shouldn&#39;t be an afterthought. You don&#39;t have to be a WCAG expert to improve your website, you can start immediately by fixing the little things that make a huge difference, such as:
容易理解不应该是一个附加品。你没必要成为一名WCAG专家再来改善你的网站，你马上就能通过修复一些小事情来make a huge difference。</p>
<ul>
<li>learning to use the alt attribute properly</li>
<li>学会正确使用<code>alt</code>属性</li>
<li>making sure your links and buttons are marked as such (no <div class=button> atrocities)</li>
<li>确保你的链接和按钮都这样被标记（不要<code>&lt;div class=button&gt;</code>残暴）</li>
<li>not relying exclusively on colors to communicate information</li>
<li>交流信息时不仅仅依赖颜色</li>
<li>explicitly labelling form controls</li>
<li><p>明确地标签表单控制</p>
<pre class="hljs"><code>  <span class="hljs-comment">&lt;!-- bad --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">&quot;Logo&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">&quot;logo.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- good --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">&quot;My Company, Inc.&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">&quot;logo.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span></code></pre></li>
</ul>
<p>语言（Language）
While defining the language and character encoding is optional, it&#39;s recommended to always declare both at document level, even if they&#39;re specified in your HTTP headers. Favor UTF-8 over any other character encoding.
当界定的编码语言和字符是可选择的话，建议你永远都在文档级别（document level）申明，即使它们已在你的HTTP头部规定好。喜欢<code>UTF-8</code>胜过其他类型字符编码一万倍~</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Hello, world.<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>

<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">en</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Hello, world.<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre><p>性能（Performance）
Unless there&#39;s a valid reason for loading your scripts before your content, don&#39;t block the rendering of your page. If your style sheet is heavy, isolate the styles that are absolutely required initially and defer the loading of the secondary declarations in a separate style sheet. Two HTTP requests is significantly slower than one, but the perception of speed is the most important factor.
除非在内容加载之前先载入脚本有个合理的理由，那么就别阻塞你页面的渲染。
如果CSS文件很大，就页面初始时必要的样式分离出来，然后再延迟加载独立样式表中的次要声明。两次HTTP请求会显著地慢于一次，但是（用户对页面加载）速度的感觉才是最重要的因素。</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">analytics.js</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Hello, world.<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Hello, world.<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">analytics.js</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre><h2 id="css">CSS</h2>
<p> 分号（Semicolons）
While the semicolon is technically a separator in CSS, always treat it as a terminator.
虽然从技术上说，分号在CSS中是一个分离器，但永远把它当一个终止器来看待。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red
</span></span></span>}

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
}</span></code></pre><p>盒模型（Box Model）
The box model should ideally be the same for the entire document. A global <em> { box-sizing: border-box; } is fine, but don&#39;t change the default box model on specific elements if you can avoid it.
理想状况下，整个文档的盒模型应该保持一样。 全局的 `</em> { box-sizing: border-box; }` 是很好，但尽量别去改变特定元素的默认盒模型。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">10px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">box-sizing</span>:<span class="hljs-value"> border-box</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">10px</span></span></span>;
}</span></code></pre><p>  流（Flow）
Don&#39;t change the default behavior of an element if you can avoid it. Keep elements in the natural document flow as much as you can. For example, removing the white-space below an image shouldn&#39;t make you change its default display:
尽量不要去改变一个元素的默认行为。尽你所能让标签元素都待在正常文档流里。比如说，移除一张图片下方空白不应改变它的默认显示：</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">img</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> block</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">img</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">vertical-align</span>:<span class="hljs-value"> middle</span></span>;
}</span></code></pre><p> Similarly, don&#39;t take an element off the flow if you can avoid it.
 同样地，尽量别把一个元素从文档流中拿出来。</p>
<pre class="hljs"><code>  <span class="hljs-comment">/<em> bad </em>/</span>
  <span class="hljs-tag">div</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100px</span></span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value"> absolute</span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">right</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
  }</span>

   <span class="hljs-comment">/<em> good </em>/</span>
   <span class="hljs-tag">div</span> <span class="hljs-rules">{
       <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100px</span></span></span>;
       <span class="hljs-rule"><span class="hljs-attribute">margin-left</span>:<span class="hljs-value"> auto</span></span>;
   }</span></code></pre><p>定位（Positioning）
There are many ways to position elements in CSS but try to restrict yourself to the properties/values below. By order of preference:
在CSS中有许多方法来定位元素，但尽量限制自己来使用以下的属性/值。通过偏好排序：</p>
<pre class="hljs"><code><span class="hljs-attribute">display</span>: <span class="hljs-string">block;</span>
<span class="hljs-attribute">display</span>: <span class="hljs-string">flex;</span>
<span class="hljs-attribute">position</span>: <span class="hljs-string">relative;</span>
<span class="hljs-attribute">position</span>: <span class="hljs-string">sticky;</span>
<span class="hljs-attribute">position</span>: <span class="hljs-string">absolute;</span>
<span class="hljs-attribute">position</span>: <span class="hljs-string">fixed;</span></code></pre><p>选择符（Selectors）
Minimize selectors tightly coupled to the DOM. Consider adding a class to the elements you want to match when your selector exceeds 3 structural pseudo-classes, descendant or sibling combinators.
最小化和DOM紧密耦合的选择符。当选择符超出三个结构伪类（structural pseudo-classes）、后代（descendant）或同胞（ sibling）选择符组合的话，考虑为你希望匹配的元素标签加一个类。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-operator">div</span>:<span class="hljs-keyword">first</span>-<span class="hljs-operator">of</span>-type :<span class="hljs-keyword">last</span>-child &gt; p ~ <em>

<span class="hljs-comment">/</em> good */</span>
<span class="hljs-operator">div</span>:<span class="hljs-keyword">first</span>-<span class="hljs-operator">of</span>-type .info</code></pre><p>Avoid overloading your selectors when you don&#39;t need to.  不必要的时候避免选择符过载。（<strong>译注：CSS选择符过载是什么？只知道 override。</strong>）</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">img</span><span class="hljs-attr_selector">[src$=svg]</span>, <span class="hljs-tag">ul</span> &gt; <span class="hljs-tag">li</span><span class="hljs-pseudo">:first-child</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">opacity</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-attr_selector">[src$=svg]</span>, <span class="hljs-tag">ul</span> &gt; <span class="hljs-pseudo">:first-child</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">opacity</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
}</span></code></pre><p>特指度（Specificity）
Don&#39;t make values and selectors hard to override. Minimize the use of id&#39;s and avoid !important.
别让值和选择符难以重载。减少ID的使用，避免使用<code>!important</code>。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-class">.bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green <span class="hljs-important">!important</span></span></span>;
}</span>
<span class="hljs-class">.foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-class">.foo</span><span class="hljs-class">.bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green</span></span>;
}</span>
<span class="hljs-class">.foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
}</span></code></pre><p> 层叠（Overriding）
 Overriding styles makes selectors and debugging harder. Avoid it when possible.
 层叠样式会使选择符和调试更加复杂困难。尽可能避免使用。</p>
<pre class="hljs"><code> <span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">li</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">visibility</span>:<span class="hljs-value"> hidden</span></span>;
}</span>
<span class="hljs-tag">li</span><span class="hljs-pseudo">:first-child</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">visibility</span>:<span class="hljs-value"> visible</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">li</span> + <span class="hljs-tag">li</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">visibility</span>:<span class="hljs-value"> hidden</span></span>;
}</span></code></pre><p>继承（Inheritance）
Don&#39;t duplicate style declarations that can be inherited.
能继承的样式声明就别复制。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-tag">h1</span>, <span class="hljs-tag">div</span> <span class="hljs-tag">p</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">text-shadow</span>:<span class="hljs-value"> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span> <span class="hljs-hexcolor">#fff</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">text-shadow</span>:<span class="hljs-value"> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span> <span class="hljs-hexcolor">#fff</span></span></span>;
}</span></code></pre><p>简洁（Brevity）
Keep your code terse. Use shorthand properties and avoid using multiple properties when it&#39;s not needed.
保持代码的简洁。使用简写的属性，不必要时避免使用多重属性。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> all <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">top</span>:<span class="hljs-value"> <span class="hljs-number">50%</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin-top</span>:<span class="hljs-value"> -<span class="hljs-number">10px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding-top</span>:<span class="hljs-value"> <span class="hljs-number">5px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding-right</span>:<span class="hljs-value"> <span class="hljs-number">10px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding-bottom</span>:<span class="hljs-value"> <span class="hljs-number">20px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding-left</span>:<span class="hljs-value"> <span class="hljs-number">10px</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">top</span>:<span class="hljs-value"> <span class="hljs-function">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">10px</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">5px</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span></span></span>;
}</span></code></pre><p>语言（Language）
Prefer English over math.</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-pseudo">:nth-child(2n</span> + 1) <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">rotate</span>(<span class="hljs-number">360deg</span>)</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-pseudo">:nth-child(odd)</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">rotate</span>(<span class="hljs-number">1turn</span>)</span></span>;
}</span></code></pre><p>浏览器前缀（Vendor prefixes）
Kill obsolete vendor prefixes aggressively. If you need to use them, insert them before the standard property.
竭力地干掉过时的浏览器前缀吧！必须使用的话，把它们写在标准属性前。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-webkit-transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-moz-transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-ms-transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-webkit-transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-moz-transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-ms-transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">-webkit-transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
}</span></code></pre><p>动画（Animation）
Favor transitions over animations. Avoid animating other properties than opacity and transform.
除了<code>opacity</code> 和 <code>transform</code>，其他尽量使用<code>transition</code>，而不是<code>animation</code>。</p>
<p>单位（Units）
能不带单位就不带单位。相对单位多用<code>rem</code>。多用<code>s</code>而不是<code>ms</code>。（<strong>why?</strong>）</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> .<span class="hljs-number">9em</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"> <span class="hljs-number">22px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> <span class="hljs-number">500ms</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> .<span class="hljs-number">9rem</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"> <span class="hljs-number">1.5</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> .<span class="hljs-number">5s</span></span></span>;
}</span></code></pre><p>颜色（Colors）
需要改变透明度（transparency）时，使用<code>rgba</code>。否则永远使用十六进制值（hexadecimal format）。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-function">hsl</span>(<span class="hljs-number">103</span>, <span class="hljs-number">54%</span>, <span class="hljs-number">43%</span>)</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#5a3</span></span></span>;
}</span></code></pre><p>绘图（Drawing）
资源使用CSS绘图替代的话可以避免HTTP请求。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span><span class="hljs-pseudo">::before</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"> <span class="hljs-function">url</span>(white-circle.svg)</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span><span class="hljs-pseudo">::before</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"> <span class="hljs-string">&quot;&quot;</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> block</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">20px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">20px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border-radius</span>:<span class="hljs-value"> <span class="hljs-number">50%</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#fff</span></span></span>;
}</span></code></pre><p>技巧（Hacks）
别用。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> {
  <span class="hljs-comment">// position: relative;</span>
  <span class="hljs-attribute">transform</span>: <span class="hljs-function">translateZ</span>(<span class="hljs-number">0</span>);
}

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> {
  <span class="hljs-comment">/<em> position: relative; </em>/</span>
  <span class="hljs-attribute">will-change</span>: transform;
}</code></pre><h2 id="javascript">JavaScript</h2>
<p>性能（Performance）
Favor readability, correctness and expressiveness over performance. JavaScript will basically never be your performance bottleneck. Optimize things like image compression, network access and DOM reflows instead. If you remember just one guideline from this document, choose this one.
易读性、正确性、富有表现性比性能更重要。从根本上来说，JavaScript绝对不会成为性能瓶颈，应该优化图像压缩、网络连接和DOM刷新。如果你只记得这篇文档的一条规则，那就选择这条吧。</p>
<pre class="hljs"><code>// bad (albeit way faster)
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> len = arr.length;
<span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> <span class="hljs-literal">result</span> = [];
<span class="hljs-keyword">while</span> (++i &lt; len) {
  <span class="hljs-keyword">var</span> n = arr[i];
  <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
  <span class="hljs-literal">result</span>.push(n <em> n);
}

// good
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> isEven = n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> square = n =&gt; n </em> n;

<span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = arr.filter(isEven).map(square);</code></pre><p>无国籍？（Statelessness）
Try to keep your functions pure. All functions should ideally produce no side-effects, use no outside data and return new objects instead of mutating existing ones.
尽量使函数纯粹。理想情况下，所有的函数都不会产生副作用，不使用外部的数据，返回新的对象而不是在现有对象上作修改。</p>
<pre class="hljs"><code>// bad
const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);
merge({ foo: <span class="hljs-string">&quot;foo&quot;</span> }, { bar: <span class="hljs-string">&quot;bar&quot;</span> }); // =&gt; { foo: <span class="hljs-string">&quot;foo&quot;</span>, bar: <span class="hljs-string">&quot;bar&quot;</span> }

// good
const merge = (...sources) =&gt; Object.assign({}, ...sources);
merge({ foo: <span class="hljs-string">&quot;foo&quot;</span> }, { bar: <span class="hljs-string">&quot;bar&quot;</span> }); // =&gt; { foo: <span class="hljs-string">&quot;foo&quot;</span>, bar: <span class="hljs-string">&quot;bar&quot;</span> }</code></pre><p>原生（Natives）
尽可能使用原生方法。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
const <span class="hljs-built_in">toArray</span> = obj =&gt; [].slice.<span class="hljs-built_in">call</span>(obj);

<span class="hljs-comment">// good</span>
const <span class="hljs-built_in">toArray</span> = (() =&gt;
  <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span> ? <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span> : obj =&gt; [].slice.<span class="hljs-built_in">call</span>(obj)
)();</code></pre><p>强制转换（Coercion）
有意义的时候就欣然使用「隐式类型转换」（imolicit coercion）吧，不然就避免它。Don&#39;t cargo-cult. （别太草包，要灵活变通？）</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-tag">if</span> (x === undefined || x === null) { ... }

<span class="hljs-comment">// good</span>
<span class="hljs-tag">if</span> (x == undefined) { ... }</code></pre><p>循环（Loops）
Don&#39;t use loops as they force you to use mutable objects. Rely on <code>array.prototype</code> methods.
不要使用循环因为它强制你使用可变的对象。使用<code>array.prototype</code>方法。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">sum</span> = arr =&gt; {
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">sum</span> = 0;
  <span class="hljs-keyword">var</span> i = -1;
  <span class="hljs-keyword">for</span> (;arr[++i];) {
    <span class="hljs-keyword">sum</span> += arr[i];
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;
};

<span class="hljs-literal">sum</span>([1, 2, 3]); <span class="hljs-comment">// =&gt; 6</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">sum</span> = arr =&gt;
  arr.reduce((x, y) =&gt; x + y);

<span class="hljs-literal">sum</span>([1, 2, 3]); <span class="hljs-comment">// =&gt; 6</span></code></pre><p>If you can&#39;t, or if using <code>array.prototype</code> methods is arguably abusive, use recursion.
不能的话，或者可以说 <code>array.prototype</code> 被滥用，就使用递归（recursion）。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> createDivs = howMany =&gt; {
  <span class="hljs-keyword">while</span> (howMany--) {
    <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(<span class="hljs-string">&quot;beforeend&quot;</span>, <span class="hljs-string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>);
  }
};
createDivs(<span class="hljs-number">5</span>);

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> createDivs = howMany =&gt;
  [...Array(howMany)].forEach(() =&gt;
    <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(<span class="hljs-string">&quot;beforeend&quot;</span>, <span class="hljs-string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>)
  );
createDivs(<span class="hljs-number">5</span>);

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> createDivs = howMany =&gt; {
  <span class="hljs-keyword">if</span> (!howMany) <span class="hljs-keyword">return</span>;
  <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(<span class="hljs-string">&quot;beforeend&quot;</span>, <span class="hljs-string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>);
  <span class="hljs-keyword">return</span> createDivs(howMany - <span class="hljs-number">1</span>);
};
createDivs(<span class="hljs-number">5</span>);</code></pre><p>参数（Arguments）
Forget about the <code>arguments</code> object. The rest parameter is always a better option because:</p>
<ol>
<li>it&#39;s named, so it gives you a better idea of the arguments the function is expecting</li>
<li>it&#39;s a real array, which makes it easier to use.
忘掉 <code>arguments</code> 对象吧。参数名（rest parameter）总是个更好的选择。原因如下：</li>
<li>命名的参数能让你更好理解这个函数期待输入的参数；</li>
<li><p>命名的参数是一个真正的数组，这样使用它更容易。</p>
<pre class="hljs"><code> <span class="hljs-comment">// bad</span>
 <span class="hljs-keyword">const</span> sortNumbers = () =&gt;
       <span class="hljs-keyword">Array</span>.prototype.slice.call(arguments).sort();

 <span class="hljs-comment">// good</span>
 <span class="hljs-keyword">const</span> sortNumbers = (...numbers) =&gt; numbers.sort();</code></pre></li>
</ol>
<p>Apply
忘掉<code>apply()</code>吧，使用更广泛的操作符（spread operator）。</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> greet = (first, last) =&gt; <span class="hljs-string"><code>Hi &lt;span class=&quot;hljs-subst&quot;&gt;${first}&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;${last}&lt;/span&gt;</code></span>;
<span class="hljs-keyword">const</span> person = [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>];

<span class="hljs-comment">// bad</span>
greet.apply(<span class="hljs-literal">null</span>, person);

<span class="hljs-comment">// good</span>
greet(...person);</code></pre><p>Bind
Don&#39;t <code>bind()</code> when there&#39;s a more idiomatic  approach.
有更符合语言习惯的方法的时候，不要用<code>bind()</code>。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
[<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>].forEach(func.bind(<span class="hljs-keyword">this</span>));

<span class="hljs-comment">// good</span>
[<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>].forEach(func, <span class="hljs-keyword">this</span>);

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> person = {
  first: <span class="hljs-string">&quot;John&quot;</span>,
  last: <span class="hljs-string">&quot;Doe&quot;</span>,
  greet() {
    <span class="hljs-keyword">const</span> full = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${this.first}&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;${this.last}&lt;/span&gt;</code></span>;
    }.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string"><code>Hello &lt;span class=&quot;hljs-subst&quot;&gt;${full()}&lt;/span&gt;</code></span>;
  }
}

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> person = {
  first: <span class="hljs-string">&quot;John&quot;</span>,
  last: <span class="hljs-string">&quot;Doe&quot;</span>,
  greet() {
    <span class="hljs-keyword">const</span> full = () =&gt; <span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${this.first}&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;${this.last}&lt;/span&gt;</code></span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string"><code>Hello &lt;span class=&quot;hljs-subst&quot;&gt;${full()}&lt;/span&gt;</code></span>;
  }
}</code></pre><p>高阶函数（Higher-order functions）
尽量不要嵌套函数（nesting functions）。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-built_in">map</span>(num =&gt; String(num));

<span class="hljs-comment">// good</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-built_in">map</span>(String);</code></pre><p>组合（Composition）
Avoid multiple nested function calls. Use composition instead.
 避免多重嵌套的函数调用。改用<code>composition</code>。</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> plus1 = a =&gt; a + <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> mult2 = a =&gt; a * <span class="hljs-number">2</span>;

<span class="hljs-comment">// bad</span>
mult2(plus1(<span class="hljs-number">5</span>)); <span class="hljs-comment">// =&gt; 12</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);
<span class="hljs-keyword">const</span> addThenMult = pipeline(plus1, mult2);
addThenMult(<span class="hljs-number">5</span>); <span class="hljs-comment">// =&gt; 12</span></code></pre><p>缓存（Caching）
Cache feature tests, large data structures and any expensive operation.
将重要的测试、大块的数据结构或者任何高代价的运算操作都缓存起来。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> contains = (arr, value) =&gt;
  <span class="hljs-keyword">Array</span>.prototype.includes
    ? arr.includes(value)
    : arr.some(el =&gt; el === value);
contains([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>], <span class="hljs-string">&quot;baz&quot;</span>); <span class="hljs-comment">// =&gt; false</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> contains = (() =&gt;
  <span class="hljs-keyword">Array</span>.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)
)();
contains([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>], <span class="hljs-string">&quot;baz&quot;</span>); <span class="hljs-comment">// =&gt; false</span></code></pre><p>变量（Variables）
Favor const over let and let over var.
优先级：<code>const</code> &gt; <code>let</code> &gt; <code>var</code></p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> obj = {};
obj[<span class="hljs-string">&quot;foo&quot;</span> + <span class="hljs-string">&quot;bar&quot;</span>] = <span class="hljs-string">&quot;baz&quot;</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> obj = {
  [<span class="hljs-string">&quot;foo&quot;</span> + <span class="hljs-string">&quot;bar&quot;</span>]: <span class="hljs-string">&quot;baz&quot;</span>
};</code></pre><p>条件（Conditions）
Favor IIFE&#39;s and return statements over if, else if, else and switch statements.
优先级：<code>IIFE</code>+ <code>return</code> &gt; <code>if</code> + <code>else if</code> + <code>switch</code>
译注：<code>IIFE</code>： Immediately-invoked function expression，立即调用的函数表达式；</p>
<pre class="hljs"><code>// bad
<span class="hljs-keyword">var</span> grade;
<span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> &lt; <span class="hljs-number">50</span>)
  grade = <span class="hljs-string">&quot;bad&quot;</span>;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> &lt; <span class="hljs-number">90</span>)
  grade = <span class="hljs-string">&quot;good&quot;</span>;
<span class="hljs-keyword">else</span>
  grade = <span class="hljs-string">&quot;excellent&quot;</span>;

// good
<span class="hljs-keyword">const</span> grade = (() =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> &lt; <span class="hljs-number">50</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bad&quot;</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> &lt; <span class="hljs-number">90</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;good&quot;</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;excellent&quot;</span>;
})();</code></pre><p>对象迭代（Object iteration）
Avoid for...in when you can.
避免使用<code>for-in</code></p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> shared = { foo: <span class="hljs-string">&quot;foo&quot;</span> };
<span class="hljs-keyword">const</span> obj = Object.create(shared, {
  bar: {
    value: <span class="hljs-string">&quot;bar&quot;</span>,
    enumerable: true
  }
});

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">prop</span> <span class="hljs-keyword">in</span> obj) {
  <span class="hljs-keyword">if</span> (obj.hasOwnProperty(<span class="hljs-keyword">prop</span>))
    console.<span class="hljs-literal">log</span>(<span class="hljs-keyword">prop</span>);
}

<span class="hljs-comment">// good</span>
Object.keys(obj).<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">prop</span> =&gt; console.<span class="hljs-literal">log</span>(<span class="hljs-keyword">prop</span>));</code></pre><p>Objects as Maps
While objects have legitimate use cases, maps are usually a better, more powerful choice. When in doubt, use a Map.
尽管<code>objects</code>有些好的使用案例，但<code>maps</code>通常是一种更好更强大的选择。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> me = {
  name: <span class="hljs-string">&quot;Ben&quot;</span>,
  age: <span class="hljs-number">30</span>
};
<span class="hljs-keyword">var</span> meSize = <span class="hljs-built_in">Object</span>.keys(me).length;
meSize; <span class="hljs-comment">// =&gt; 2</span>
me.country = <span class="hljs-string">&quot;Belgium&quot;</span>;
meSize++;
meSize; <span class="hljs-comment">// =&gt; 3</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> me = <span class="hljs-built_in">Map</span>();
me.<span class="hljs-literal">set</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ben&quot;</span>);
me.<span class="hljs-literal">set</span>(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">30</span>);
me.size; <span class="hljs-comment">// =&gt; 2</span>
me.<span class="hljs-literal">set</span>(<span class="hljs-string">&quot;country&quot;</span>, <span class="hljs-string">&quot;Belgium&quot;</span>);
me.size; <span class="hljs-comment">// =&gt; 3</span></code></pre><p>柯里化（Curry）
Currying might have its place in other languages, but avoid it in JavaScript. It makes your code harder to read by introducing a foreign paradigm while the appropriate use cases are extremely unusual.
在其他语言中，柯里化可能有它的一席之地，但是不要在 JavaScript 中使用它。因为它引入了很少能见到正确使用的非自身范例（foreign paradigm），这会让你的代码阅读困难。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> sum = a =&gt; b =&gt; a + b;
sum(<span class="hljs-number">5</span>)(<span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; 8</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> sum = (a, b) =&gt; a + b;
sum(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; 8</span></code></pre><p>可读性（Readability）
Don&#39;t obfuscate the intent of your code by using seemingly smart tricks.
别用些自作聪明的小把戏混淆了你代码真正的意图。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
foo || doSomething();

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">if</span> (!foo) doSomething();


<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/<em> IIFE </em>/</span> }();

<span class="hljs-comment">// good</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/<em> IIFE </em>/</span> }());

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> n = ~~<span class="hljs-number">3.14</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">3.14</span>);</code></pre><p>代码复用（Code reuse）
Don&#39;t be afraid of creating lots of small, highly composable and reusable functions.
尽管去写些短小精悍、组件化、高度复用的函数。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
arr[arr.length - <span class="hljs-number">1</span>];

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> first = arr =&gt; arr[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> last = arr =&gt; first(arr.slice(-<span class="hljs-number">1</span>));
last(arr);


<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> product = (a, b) =&gt; a <em> b;
<span class="hljs-keyword">const</span> triple = n =&gt; n </em> <span class="hljs-number">3</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> product = (a, b) =&gt; a * b;
<span class="hljs-keyword">const</span> triple = product.bind(<span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>);</code></pre><p>依赖（Dependencies）
Minimize dependencies. Third-party is code you don&#39;t know. Don&#39;t load an entire library for just a couple of methods easily replicable:
精简依赖。你都不知道第三方有些什么代码。
能自己写些简单方法替代就别载入整个库。</p>
<pre class="hljs"><code>// <span class="hljs-atom">bad</span>
<span class="hljs-atom">var</span> <span class="hljs-name"><em></span> = <span class="hljs-atom">require</span>(<span class="hljs-string">&quot;underscore&quot;</span>);
<span class="hljs-name"></em></span>.<span class="hljs-atom">compact</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">0</span>]));
<span class="hljs-name"><em></span>.<span class="hljs-atom">unique</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>]);
<span class="hljs-name"></em></span>.<span class="hljs-atom">union</span>([<span class="hljs-string">&quot;foo&quot;</span>], [<span class="hljs-string">&quot;bar&quot;</span>], [<span class="hljs-string">&quot;foo&quot;</span>]);

// <span class="hljs-atom">good</span>
<span class="hljs-atom">const</span> <span class="hljs-atom">compact</span> = <span class="hljs-atom">arr</span> =&gt; <span class="hljs-atom">arr</span>.<span class="hljs-atom">filter</span>(<span class="hljs-atom">el</span> =&gt; <span class="hljs-atom">el</span>);
<span class="hljs-atom">const</span> <span class="hljs-atom">unique</span> = <span class="hljs-atom">arr</span> =&gt; [...<span class="hljs-name">Set</span>(<span class="hljs-atom">arr</span>)];
<span class="hljs-atom">const</span> <span class="hljs-atom">union</span> = (...<span class="hljs-atom">arr</span>) =&gt; <span class="hljs-atom">unique</span>([].<span class="hljs-atom">concat</span>(...<span class="hljs-atom">arr</span>));

<span class="hljs-atom">compact</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">0</span>]);
<span class="hljs-atom">unique</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>]);
<span class="hljs-atom">union</span>([<span class="hljs-string">&quot;foo&quot;</span>], [<span class="hljs-string">&quot;bar&quot;</span>], [<span class="hljs-string">&quot;foo&quot;</span>]);</code></pre>]]></description><link>/2015-03-14-frontend-guidelines/index.html</link><guid isPermaLink="true">/2015-03-14-frontend-guidelines/index.html</guid><category><![CDATA[translate]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Sat, 14 Mar 2015 15:51:00 GMT</pubDate></item><item><title><![CDATA[CSS 中那些大大小小的坑]]></title><description><![CDATA[<h1 id="css-">CSS 中那些大大小小的坑</h1>
<blockquote>
<p>中国读者不是不善于交流，而是对基础知识掌握不够牢固，不敢交流。就如同有人提到用英文写作时所说的，最难的不是怎么写，而是写什么。英文语法错误其实是别人最容易纠正的，但你到底想要表达什么则是别人无法知道的。具体到CSS，虽然不难学，但真正彻底把原理和基本概念全搞通也不是一件容易的事。 —— 李松峰</p>
</blockquote>
<p>最近读完了Charles Wyke-Smith的《CSS设计指南》，上面那段话是节选的译者李松峰的序（在这多说一句，觉得李松峰翻译的书质量都很高，现在的我基本在遍历）。越来越觉得只读书不思考是毫无用处的，于是把笔记整理出来，并加上了自己思考过的感悟。</p>
<hr>
<p>###CHAPTER 1 HTML标记与文档结构
用HTML标记内容的目的是为了赋予网页语义（semantic）。换句话说，就是要给你的网页内容赋予某些用户代理（user agent）能够理解的含义。 浏览器、屏幕阅读器，以及搜索引擎放出的web爬虫都是用户代理，它们需要显示、朗读和分析网页。</p>
<ul>
<li><mark>文本用闭合标签，引用内容用自闭合标签。</mark><ul>
<li>闭合标签与自闭合标签的区别在于，闭合标签包含的是会显示的实际内容，而自闭合标签只是给浏览器提供一个对要显示内容的<strong>引用</strong>。浏览器会在HTML页面加载时候，<strong>额外向服务器发送请求</strong>，以取得自闭合标签引用的内容。</li>
</ul>
</li>
<li>属性alt(alternative)，定义的是在图片因故未能加载成功时候在屏幕上显示的文本。视障用户的屏幕阅读器会大声读出alt属性的内容，因此一定要给<code>&lt;img&gt;</code>标签的<code>alt</code>属性添加让人一听（或一看）就能明白的内容。</li>
<li><code>&lt;h1&gt;</code>被搜索引擎视为仅次于<code>&lt;tittle&gt;</code>标签的另一个搜索关键词重要来源。</li>
<li>只要有不适合放在其他文本标签中的文本，都可以把它放在一个段落里。</li>
<li>某些标签，如<code>&lt;ol&gt;</code>要求其他标签，如<code>&lt;li&gt;</code>与之共同出现。</li>
<li><code>&lt;!DOCTYPE html&gt;</code>是DTD（文档类型定义），声明：“以下是一个HTML文档。”</li>
<li><code>&lt;html&gt;</code>只有两个直接的子标签：<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>。帮助浏览器理解页面的信息都包含在<code>&lt;head&gt;</code>标签中。</li>
<li>块级标签：标题、段落、列表、独立引用等，如文档流一般上下堆叠显示；行内标签：链接、图片、字体样式、简写<code>&lt;abbr&gt;</code>、引证<code>&lt;cite&gt;</code>、文本内引用<code>&lt;q&gt;</code>相互并列显示，只有在空间不足以并列的情况下才会折到下一行。</li>
<li><strong>块级元素盒子会拓展到与父元素同宽。</strong></li>
<li><strong>行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧。</strong></li>
<li>DOM（文档对象模型）是从浏览器的视角来观察页面中的元素及每个元素的属性，由此得出这些元素的一个家族树。通过DOM，可以确定元素之间的相互关系。在CSS中引用DOM中特定的位置，就可以选中相应的HTML元素，并修改其样式属性。CSS修改了元素后，这些变化会立即在DOM中发生，并体现在页面上。</li>
</ul>
<hr>
<p>###CHAPTER 2 CSS工作原理
当元素的同一个样式属性有多种样式值的时候，CSS靠层叠机制来决定最终应用哪种样式。</p>
<ul>
<li>为文档添加样式的三种方法：<ul>
<li>行内样式 ：  <code>&lt;p style=&quot;font-size: 12px; font-weight: bold;&quot;&gt;Adding inline CSS styling&lt;/p&gt;</code> 作用范围：只影响它所在的标签，而且总会覆盖嵌入样式和链接样式。</li>
<li>嵌入样式： 嵌在<code>head</code>元素中。如
<code>&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;...&lt;/style&gt;&lt;/head&gt;</code>
作用范围仅限于当前页面。会覆盖外部样式表，但被行内样式覆盖。</li>
<li>链接样式：把样式集中在一个单独文件——样式表（一个拓展名为.css的文本文件）。
在多个HTML中连接同一个样式表：
<code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code>
作用范围：有<code>&lt;link&gt;</code>标签的页面。</li>
<li><strong>@import指令</strong>：一种@规则，可以在样式表中链接其他样式表。
<code>import url(css/style2.css)</code>
注意：@import必须出现在样式表其他样式之前，否则不会被加载。<em>（见link css与@import css 的区别）</em></li>
</ul>
</li>
<li>一般上下文选择符。 基于祖先或同胞元素选择一个元素。
  <code>tag1 tag2 {statements}</code>  <strong>只要tag2在整个结构层次中有个tag1的祖先元素，无论上下文之间隔着多少层次没有关系</strong>。</li>
<li>子选择符<code>&gt;</code> <code>tag1 &gt; tag2</code>   标签2必须是标签1的子元素。</li>
<li>紧邻同胞选择符<code>+</code> <code>tag1 + tag2</code>   标签2必须紧跟在其同胞标签1后面。</li>
<li>一般同胞选择符<code>~</code> <code>tag1 ~ tag2</code>  标签2必须跟（不一定紧跟）在其同胞标签1后面。</li>
<li>通用选择符<code>*</code> 匹配任何元素。<code>* {color: green;}</code> <strong><code>color</code> 属性设定的是前景色，前景色既影响文本也影响边框，但一般用来设定文本颜色。</strong>
  故<code>p * {color: red;}</code>改变p包含的所有元素的文本变成红色。
  构成非子选择符：<code>section * a {font-size: 1.3em}</code> 任何是section孙子元素，而非子元素的a标签都会被选中。</li>
<li><strong>多类选择符</strong>。 <code>&lt;p class=&quot;specialtext featured&quot;&gt;...&lt;/p&gt;</code>
  选择同时存在这两个类名的元素：<code>.specialtext.featured {statements}</code>  注意两个类名之间没有空格，因为选择同时具有这个类名的那个元素。</li>
<li><strong>ID属性</strong>：ID用于页内导航链接。<ul>
<li><code>&lt;a href=&quot;#bio&quot;&gt;Biography&lt;/a&gt;
  &lt;h3 id=&quot;bio&quot;&gt;Biography&lt;/h3&gt;
  &lt;p&gt;....&lt;/p&gt;</code>
<code>href</code>属性值开头的<code>#</code>表示链接的目标在当前页面中，因而不会触发浏览器加载页面（如果没有#，浏览器会尝试加载bio目录下的默认页面）。会跳到h3元素的位置。
<code>&lt;a href=&quot;#&quot;&gt;Back to Top&lt;/a&gt;</code> 点击该链接返回页面顶部。
另外，如果不知道href放什么URL，可以用#作为占位符，但不能留空，因为href属性值为空的链接行为跟正常链接不一样。</li>
</ul>
</li>
<li><strong>ID</strong>是为了唯一的标识一个元素。每个ID名在页面中只能用一次。给页面中每个顶级区域都添加一个ID，得到明确的上下文。</li>
<li><strong>类</strong>是为了标识一组具有相同特征的元素。</li>
<li><strong>属性名选择符</strong> <code>标签名[属性名]</code>，选择任何带有属性名的标签名。
  什么时候使用？一般经常给alt和title属性设定相同的值。alt属性中的文本会在图片因故未能加载时显示，或者由屏幕朗读器朗读出来。而title属性会在用户鼠标移动到图片上时，显示一个包含相应文本的提示。</li>
<li><strong>属性值选择符</strong> <code>标签名[属性名=&quot;属性值&quot;]</code>，选择任何带有值为属性值的属性名的标签名。</li>
<li><strong>UI伪类</strong>在HTML元素处于某种状态时应用CSS。<ul>
<li>链接伪类。<code>::link/::visited / ::hover / ::active</code></li>
<li><code>:focus</code>伪类。<code>e:focus</code>在单击它获得焦点时候改变CSS。</li>
<li><strong><code>:target</code>伪类</strong>。 <code>e:target</code>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target伪类选中它。<pre class="hljs"><code>&lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">&quot;#more_info&quot;</span>&gt;More Information&lt;/a&gt;
&lt;<span class="hljs-tag">h2</span> id=<span class="hljs-string">&quot;more_info&quot;</span>&gt;This is the information you are looking <span class="hljs-keyword">for</span>.&lt;/h2&gt;</code></pre>那么规则<code>#more_info:target {background: #eee;}</code>会在用户单击链接转向ID为more_info的元素时候，为该元素（h2）添加浅灰色背景，以便在一大堆引证中识别。（实例见Wikipedia）</li>
</ul>
</li>
<li>结构伪类<ul>
<li><code>li:frist-child</code>&amp;<code>li:last-child</code>代表一组同胞元素中第一个或最后一个元素。</li>
<li><code>e:nth-child(n)</code> e为元素名，n表示一个数值（也可以使用odd或even）。用于提高表格的可读性，对表格的所有行交替应用不同颜色。</li>
</ul>
</li>
<li>伪元素（CSS3 new）<ul>
<li><code>e::first-letter</code> 首字符。</li>
<li><code>e::first-line</code>文本段落第一行，长度会随着浏览器窗口大小变换而改变。</li>
<li><code>::before</code>和<code>::after</code>伪元素，可用在特定元素前后添加特殊内容。<a href="#">（见用CSS伪类绘制各种图形 CSS trick）</a></li>
</ul>
</li>
<li>继承：文本样式（颜色）及字体（字号）。不继承元素盒子的定位和显示方式（边距、边框等）。<strong>所以使用相对字体单位（em和百分比）要格外小心！</strong></li>
<li>层叠：样式在文档层次中逐层叠加。<ul>
<li>层叠顺序：浏览器默认CSS-&gt;用户CSS-&gt;作者链接CSS(按照它们链接到页面的先后顺序)-&gt;作者嵌入CSS-&gt;作者行内CSS。</li>
<li>层叠规则：<ol>
<li>找到应用给每个元素和属性的所有声明。</li>
<li>按顺序和权重排序。 <code>!important;</code>用于加重声明的权重。</li>
<li>按特指度（specificity）排序。ID&gt;类&gt;标签名。但设定的样式胜过继承的样式。</li>
<li>顺序决定权重。位置靠下或者后声明的规则胜出。</li>
</ol>
</li>
</ul>
</li>
<li>em和ex都是字体大小的单位。但它们作为长度单位适用于任何元素。<ul>
<li>em表示一种字体中字母M的宽度，因此它的具体大小取决于你使用的字体。</li>
<li>ex等于给定字体中字母x的高度（小写字母x代表一种字体的字母中间部分的高度，不包括字母上下突出的部分——如d、p上下出头）。</li>
</ul>
</li>
<li>百分比非常适合设定被包含元素的宽度，此时的百分比是相对于宽度而言。<strong>可以把HTML结构元素宽度设定为body宽度的百分比，“流式”设计的关键，可以根据浏览器窗口大小而成比例伸缩。</strong></li>
<li>饱和度设定有多少颜色，灰色的饱和度低，而强烈色彩饱和度高。亮度设定颜色的明暗，0%就是黑色，100%就是白色。</li>
</ul>
<hr>
<p>###CHAPTER 3 定位元素
要掌握CSS，核心就是要掌握元素定位！
可见页面的版式 主要由三个属性控制：position 属性、display 属性和 float 属性。 position：控制页面上元素间的位置关系；display：控制元素是堆叠、并排还是根本不在页面上出现；float：提供控制的方式，以便把元素组成多栏布局。</p>
<p><strong>！！此处添加一张描述盒模型的图！！</strong></p>
<ul>
<li>HTML页面实际由一堆盒子组成。默认情况下，每个盒子的边框不可见，背景也是透明。</li>
<li>三组属性：<ul>
<li>边框（border）：宽窄、样式和颜色。</li>
<li>内边距（padding）：盒子内容区与边框的间距。</li>
<li>外边距（margin）：盒子与相邻元素的间距。
如何理解？<strong>外边距是边框向外推其他元素，内边距是边框向内推元素的内容。</strong></li>
</ul>
</li>
<li>简写样式：<code>margin{top, right, bottom, left}</code></li>
<li>边框（border）3个属性：<ul>
<li><code>border-width</code>：thin, medium, thick等文本值，也可以用除百分比和负值之外的任何绝对值；</li>
<li><code>border-style</code>：none,  hidden, dotted, dashed, solid, double, groove, ridge, inset, outset文本值；</li>
<li><code>border-color</code>：使用任意颜色值，包括RGB、HSL、十六进制值和颜色关键字。
默认情况下，边框三个相关属性的值分别为<code>border-width: medium; border-style: none; border-color: black;</code>。调试的时候设置<code>border: 1px solid;</code>，1px可以把边框对布局宽度和高度的影响降到最低。</li>
</ul>
</li>
<li>盒子外边距：<ul>
<li>使用<code>* {margin: 0; padding: 0;}</code>中和默认值，再根据需要添加，就会在各浏览器上获得一致的效果。</li>
<li>叠加外边距：<strong>垂直方向上的外边距会叠加，水平外边距不叠加。</strong>上下外边距相遇时，它们会相互重叠，直至一个外边距碰到另一个元素的边框，且较宽的外边距决定两个元素最终距离。而水平相邻的元素，水平间距是相邻外边距之和。</li>
<li>设置外边距时需要混合使用不同的单位。比如一个段落的左右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间距，不受字号变大或变小的影响。而对于上下外边距，以em为单位则可以让段间距随字号变化而相应增大或缩小（按比例变化，整体布局就会依旧协调）。</li>
</ul>
</li>
<li>盒子到底有多大<ul>
<li>没有宽度的盒子：如果不设置块级元素的width属性，那么这个属性的默认值为auto，结果会让元素的宽度拓展到与父元素同宽。sum(添加水平边框、内边距和外边距) = 内容宽度减少量。</li>
<li>为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的<code>width</code>属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。</li>
</ul>
</li>
<li><p>浮动与清除
浮动可以实现：1. 传统出版物的文字绕排图片的效果。2. 可以让原来上下堆叠的块级元素变成左右并列，从而实现布局中的分栏。</p>
<ul>
<li><p>浮动元素会脱离常规文档流，在原来紧跟其后的元素就会在空间的允许下，向上提升到与浮动元素平起平坐。</p>
<blockquote>
<p>尽量把这个元素往上放，能放多高放多高，直到碰到某个元素的边界为止。  -- Eric Meyer</p>
</blockquote>
</li>
<li><p>浮动非图片元素时，必须给它设定宽度，否则后果难料。</p>
</li>
<li>浮动元素脱离文档流，父元素也不会再包围它。三种围住浮动元素：<ol>
<li>为父元素添加<code>overflow: hidden</code>。实际上<code>overflow: hidden</code>声明的真正用途是防止包含元素被超大内容撑大，包含元素依然保持其设定的宽度，而超大的子内容则会被容器剪切掉（之前有在下拉菜单的顶级元素上应用这个声明，结果作为其子元素的下拉菜单没有被显示，就是因为其被父元素剪切了），除此之外，它能可靠地迫使父元素包含其浮动的子元素。</li>
<li>同时浮动父元素。浮动父元素后，不管其子元素是否浮动，它总是会紧紧包围（也称收缩包裹）住它的子元素。</li>
<li>添加非浮动的清除元素。原理：给父元素的最后添加一个非浮动的子元素，然后清除该子元素。由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）浮动元素的下方，因此包含元素一定会包含这个子元素——以及前面的浮动元素。此种方法一共有两种方式：</li>
</ol>
</li>
<li>在HTML标记中添加一个子元素div，且给它应用clear属性。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-title">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">&quot;images/...&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>It&#39;s fun to float.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;clear-me&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">section</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">footer</span>&gt;</span>Here is the footer.<span class="hljs-tag">&lt;/<span class="hljs-title">footer</span>&gt;</span>
.clear_me { clear: left; }</code></pre><ul>
<li>用CSS来添加消除元素的方法。</li>
</ul>
<pre class="hljs"><code><span class="hljs-variable">&lt;section class = &quot;clearfix&quot;&gt;</span>
    <span class="hljs-variable">&lt;imag src=&quot;images/... /&gt;</span>
    <span class="hljs-variable">&lt;p&gt;</span>It&#39;s fun <span class="hljs-keyword">to</span> float.<span class="hljs-variable">&lt;/p&gt;</span>
<span class="hljs-variable">&lt;/section&gt;</span>
<span class="hljs-variable">&lt;footer&gt;</span>Here is the footer.<span class="hljs-variable">&lt;/footer&gt;</span></code></pre><pre class="hljs"><code><span class="hljs-class">.clearfix</span><span class="hljs-pseudo">:after</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"> <span class="hljs-string">&quot;.&quot;</span></span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value">block</span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">visibility</span>:<span class="hljs-value"> hidden</span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">clear</span>:<span class="hljs-value"> both</span></span>;
}</span></code></pre><p><code>clear: both</code> 意味这section中新增的子元素会清除左右浮动元素。</p>
<p>####定位
<code>position</code>有4个属性：static、relative、absolute、fixed，默认为static。
<strong>static（静态定位）</strong>：块级元素在常规文档流中自上而下的堆叠。
<strong>relative（相对定位）</strong>：到底相对哪里定位？相对的是它原来在文档流中的位置（或者默认位置）。
<code>p{ position: relative; top:25px; left:30px;}</code>
注意：top,left为正（负）值意味着把元素向下（上）、向右（左）移动。
<strong>absolute(绝对定位)</strong>：绝对定位会把元素彻底从文档流中拿出来。
<code>p{ position: absolute; top:25px; left:30px;}</code>
绝对定位元素默认的<em>定位上下文</em>是body。但绝对定位元素的任何祖先元素都可以成为它的定位上下文，只要你把相应的祖先元素<code>position：relative;</code>
<strong>fixed（固定定位）</strong>：固定定位元素也被完全移除了文档流，但固定定位的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面而移动。一般情况下，常用来创建位于顶部或左右侧，不随页面滚动而移动的导航元素。</p>
<p>####显示属性
display 把块级元素变成行内元素（或相反），可以使原先的行内元素填满其父元素。
<code>display: none</code>：该元素及所有包含在其中的元素，都不会在页面中显示。它们原先占据的所有空间也都会被“回收”，就好像相关的标记根本不存在一样。
<code>visibility</code>默认为visible，若设置为<code>hidden</code>，元素会隐藏，但它占据的页面空间仍然在（也就是只在页面上隐形了而已咯）。</p>
<p>####背景
<strong>！！此处添加盒模型三维透视图！！</strong>
CSS每个元素盒子可以想象成两个图层组成。
<strong>背景颜色</strong>
元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用实色填充（background-color属性），也可以包含任意多个背景图片（使用background-image属性），背景图片叠加在背景颜色之上。
<em>注意</em> 关于<code>color</code>属性：前景色属性，作用范围是元素的内容和边框。影响边框的前提是border没有设定边框颜色（或者<code>border-color</code>没有设定），边框就会使用color属性设定的字体颜色。默认为黑色。
<strong>背景图片</strong>
指定背景图片来源：<code>background-image: url(images/path);</code>
默认情况下，比元素小的背景图片以元素左上角为起点，水平和垂直方向上重复出现，直至填满整个背景空间。所以元素盒子底部和右侧的圆形图案都只显示了一部分。
<strong>背景重复</strong>
<code>background-repeat</code>：
<code>repeat</code>：默认值， 水平与垂直方向均重复；
<code>repeat-x</code>：只在水平方向重复；
 <code>repeat-y</code>：只在垂直方向重复；
 <code>no-repeat</code>：在任何方向上均不重复，即只让背景图片显示一次。
 <strong>CSS3背景</strong>
 <code>background-repeat: round</code> ：通过调整图片大小来适应背景区来确保图片不被剪切；
 <code>background-repeat: space</code>： 通过在图片间添加空白来适应背景区域。
<strong>背景位置</strong>
<code>background-position</code>：该属性有五个关键字值。<code>top、left、bottom、right和center</code>。 关键字中任意两个组合起来都可以作为该属性值。
<strong>注意</strong>，<code>background-position</code>属性会同时设定元素和图片的原点。原点决定了元素和图片中某一点的水平和垂直坐标。默认情况下。<code>background-position</code>的原点位于左上角，即元素左上角和图片的左上角是对齐的。
但是当把起点位置改为center center（50% 50% 也是一样的效果），如
<code>p#center {background-position: center;}</code>
若只设一个关键字值（不是数值），则另一个也会取相同的值。
设定了图片中心点与元素中心点重合，然后向水平和垂直方向重复。
如再设置<code>background-repeat: no-repeat</code> 则会实现图片在背景区域内居中的效果。
<strong>比较设置背景位置三个值：关键字、百分比、绝对或相对单位的数值。</strong>
<strong>关键字</strong>：顺序不重要。
<strong>数值</strong>：第一个值表示水平位置，第二个值表示垂直位置。要是只设定一个值，则将其用来设定水平位置，垂直位置被设为<code>center</code>。
使用关键字和百分比，设定的值同时应用于元素和图片。
<strong>像素等绝对单位数值</strong>：设定图片的左上角会被放在距离元素左上角指定位置的地方。
有趣的是，还可以设置负值，或者足够大的正值，实现显示部分图片。
<strong>背景尺寸</strong>
<code>background-size</code>：
50%：缩放图片，使其填充背景区的一半。
100px 50px：把图片调整到100px宽，50px高。
cover：拉大图片，使其完全填满背景区；保持宽高比。
contain：缩放图片，使其恰好适合背景区；保持宽高比。
<strong>背景粘附</strong>
<code>background-attachment</code>：控制滚动元素内的背景图片是否随元素滚动而移动。
<code>scroll</code>：属性默认值，即背景图片随元素移动。
<code>fixed</code>： 背景图片不随元素滚动而移动。
<code>inherit</code> ：继承初始值。
<strong>附</strong>：原书关于<code>background-attachment</code>属性设置并没有讲太多内容，但是在制作现代网页设计常见的<strong>视差滚动效果</strong>时候，是个重要属性。当然，在实现更amazing的效果时候会较复杂，需要结合CSS3的多背景图片属性，还有JavaScript(jQuery)来对页面进行控制。感兴趣请戳 <a href="http://isux.tencent.com/parallax-scrolling.html">Tencent ISUX「视“差”滚动浅析」</a>。
<strong>其他CSS3背景属性</strong>
<code>background-clip</code>： 控制背景绘制区域的范围。如让背景颜色和背景图片只出现在内容区，而不出现在内边距区域。
<code>background-origin</code>：控制背景定位区域的原点，可以设定盒子左上角以外的位置。
<code>background-break</code>：控制分离元素（比如跨越多行的行内盒子）的显示效果。</p>
<p>####多背景图片
CSS3中可以给元素添加多个背景图片，使用简写属性<code>background</code>如下：</p>
<pre class="hljs"><code>    <span class="hljs-tag">p</span> <span class="hljs-rules">{
        <span class="hljs-rule"><span class="hljs-attribute">text-align</span>:<span class="hljs-value"> center</span></span>;
        <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value">
        <span class="hljs-function">url</span>(images/<span class="hljs-number">01</span>.png) <span class="hljs-number">30px</span> -<span class="hljs-number">10px</span> no-repeat,
        <span class="hljs-function">url</span>(images/<span class="hljs-number">02</span>.png) <span class="hljs-number">145px</span> <span class="hljs-number">0px</span> no-repeat,
        <span class="hljs-function">url</span>(images/<span class="hljs-number">03</span>.png) <span class="hljs-number">140px</span> -<span class="hljs-number">30px</span> no-repeat <span class="hljs-hexcolor">#ffbd75</span></span></span>;
    }</span></code></pre><p><strong>注意</strong>：CSS规则中先列出的图片显示在上层，更接近前景。</p>
<p>####背景渐变
<code>linear-gradient</code>:
<code>radial-gradient</code>:</p>
<hr>
<p>###Chapter 4 字体和文本</p>
<blockquote>
<p>一个网站的品质如何，有时候只要看看它用的字体就能一目了然。如果说图片是蛋糕上的糖衣，那么排版才是卓越设计的根本。</p>
</blockquote>
<p>接触CSS这么久后，发现字体与排版是门大学问（也就是说，是个深坑…），只有经验丰富的设计师，才能创造出专业水准的网页排版吧。</p>
<p><strong>难道字体和文本不是一回事？</strong>
啊哈，当然不是。
<strong>字体</strong>是“文字的不同体式”，或“字的形体结构”。根据外观，字体可以分为不同<em>类别</em>（font collection），包括衬线字体（serif）、无衬线字体（sans-serif）和等宽字体（monospace）。每一类字体可以继续分为不同的<em>字体族</em>（font family），比如 Times 和 Helvetica。而字体族中又可以包含不同的<em>字形</em>（font face），反应了相应字体族基本设计的不同变化，例如 Times Roman、Times Bold、Helvetica Condensed、Bodoni italic。
<strong>文本</strong>就是一组字或者字符，比如章标题、段落正文等，跟使用什么字体无关。
CSS为字体和文本分别定义了属性。字体属性主要用于描述一类字体的大小和外观（什么字体族，多大字号，粗体还是斜体）。文本属性描述对文本的处理方式（行高或者字符间距，有没有下划线和缩进）。</p>
<p>####字体族
一般应该给整个页面<code>body</code>设定一种主字体，然后只对那些需要使用不同字体的元素再应用font-family。
有些字体在用户机器上不支持，那么就应该设置字体栈来指定本地字体。为了保险，字体栈的后面应补上大多数操作系统都内置的字体。
<strong>注意</strong>如果字体名像 Trebuchet MS 一样多于一个单词（有空格），应该加上引号：&quot;Trebuchet MS &quot;。</p>
<p>####字体大小
浏览器样式表默认为每个HTML元素都设定了font-size，所以你在设定 font-size 的时候，其实就是在修改默认值。</p>
]]></description><link>/2014-11-10-css-design-guide-notes/index.html</link><guid isPermaLink="true">/2014-11-10-css-design-guide-notes/index.html</guid><category><![CDATA[frontend]]></category><category><![CDATA[notes]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Mon, 10 Nov 2014 09:08:00 GMT</pubDate></item><item><title><![CDATA[写在百度电面后]]></title><description><![CDATA[<h1 id="-">写在百度电面后</h1>
<p>Desperado.</p>
<figure>
<img src="http://zbl-ghost-backup.qiniudn.com/blogcover_roadtothesky_2880x900.jpg" alt="road to the sky">
<figcaption>Road to the sky.</figcaption>
</figure>


<p>睡得昏昏沉沉的早上，突然接到了电话，在从惊呆到真呆中，就这么面完了百度。</p>
<hr>
<p>“先作下自我介绍吧！”
自我介绍？天，简历里面不是写了吗？噢，我写了什么？
“呃，我叫XXX，是电子科大电子信息工程的大四学生...呃，我喜欢互联网及互联网开发…最近一直在自学…嗯。”
“完了吗？”
“说完了。” 当时我就在想，完了。脑袋空白。</p>
<p>“电子信息工程的是吗？那你先解释下傅里叶变换吧。”
简直惊呆，我这是面的前端吗？第一个问题就这么脑子转不过来了，都好久没有看专业书。
“嗯，有个复杂信号…呃经过傅里叶变换...分解...单频率信号...嗯...”
七零八落我也不知道我说了什么。</p>
<p>“CSS的优先级知道吗？解释一下。”
“呃，是特指度？先是ID，然后是class，然后是标签名....”
“确定最后是标签名吗？”
“呃嗯...确定。”
虽然最后是对了，但是答得很是不自然。</p>
<p>“嗯，如果这有一个数组，我想删除数组中的重复元素应该怎么做？”
啊，WTF，居然问了算法。曾经想过这个思路的，但是已经好久没有写过C，而且这还是用JS实现。可是我JS的书都还没有看完。
“呃，数组嘛，那就从第一个开始依次遍历咯…有重复的话就标记。”
“每个都遍历一遍？如何标记？时间复杂度如何？”
哎，为了看前端的东西，算法好久没有碰过，我要说什么……
(<strong>更新</strong>：
面试的时候对JS不是很熟悉，还是按着原来写C的思路来处理数组，加上心里有点紧张，思路一时打不开。最近几天又继续啃了《JavaScript高级程序设计》，发现 JavaScript 在数组方面处理真心很强大，贴去除数组中重复元素的函数如下：</p>
<pre class="hljs"><code>function uniqueArray (<span class="hljs-type">array</span>) {
    <span class="hljs-keyword">var</span> <span class="hljs-literal">result</span> = [];
    <span class="hljs-type">array</span>.sort(compare);  // 此处不知道如果数组中元素很多的话，先给数组排序效率会不会高点？
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> <span class="hljs-type">array</span> ) {
        <span class="hljs-keyword">if</span> ( <span class="hljs-literal">result</span>.indexOf(<span class="hljs-type">array</span>[i]) == -<span class="hljs-number">1</span>) {
            <span class="hljs-literal">result</span>.push(<span class="hljs-type">array</span>[i]);
        };
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">result</span>;
}
function compare (value1, value2) {
     <span class="hljs-keyword">return</span> value2 - value1;
}</code></pre><p>)</p>
<p>“学过排序吗？介绍下二分法？快速排序？冒泡排序？”
“只学过冒泡…冒泡就是这样的……”</p>
<p>(<strong>更新</strong>：一个非常好玩的各种排序算法的<a href="http://jsdo.it/norahiko/oxIy/fullscreen">动画演示</a>，当初学算法的时候要是有这么直观的动画就好了。
快排的思想如下：</p>
<blockquote>
<p>（1）在数据集之中，选择一个元素作为&quot;基准&quot;（pivot）。
（2）所有小于&quot;基准&quot;的元素，都移到&quot;基准&quot;的左边；所有大于&quot;基准&quot;的元素，都移到&quot;基准&quot;的右边。
（3）对&quot;基准&quot;左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
```language-javascript
var quickSort = function(arr) {
　　if (arr.length &lt;= 1) { return arr; }
　　var pivotIndex = Math.floor(arr.length / 2);
　　var pivot = arr.splice(pivotIndex, 1)[0]; //取得基准元素的值
　　var left = [];
　　var right = [];
　　for (var i = 0; i &lt; arr.length; i++){
　　　　if (arr[i] &lt; pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}
　　return quickSort(left).concat([pivot], quickSort(right));   //递归调用
};</p>
</blockquote>
<p>```
快速排序最差的情况时间复杂度是O(n^2)。</p>
<p>“我看你笔试试卷上JS异步编程那题写了点代码，那么解释下Ajax?&quot;
噢，真是哪壶不开提哪壶。真是惭愧，笔试试卷上的代码是我考试时候翻手机里那本《JavaScript权威指南》，在里面随便抄了一点。我写了什么？我也不知道。
昨晚才真正在图书馆接触到了Ajax，书还没来得及认真看。只能凭靠记忆力一点点说。
“Ajax嘛，异步JS和XML…可以在不重新加载整个页面情况下更新页面的某个部分……”
“那么如何用JS实现Ajax？”
噢。昨天看书才看到这点，还没有实现过。
“呃…新命名一个变量（其实是对象）XMLhttprequest……然后接收服务器返回的数据……”
靠，我到底在说什么。
“不好意思，我不会写。”</p>
<p>“好吧，咱们的面试到此结束。你有什么问题吗？”
嗯，我知道我这样肯定没戏了，索性就随便说点吧。
“不好意思，笔试完后我没想过我能进面试，就没有做面试准备，所以这次表现得很糟糕。我是不是基础很不扎实？跨行是不是不容易？”
后来知道，那位面试官也是通信工程转过去的，而且他还开玩笑的说是因为考研没考上。</p>
<hr>
<blockquote>
<p>Desperado, ah, you ain&#39;t gettin&#39; no younger.
亡命之徒啊，你已经不年轻了
Your pain and your hunger, they&#39;re drivin&#39; you home.
你的痛苦和饥饿，它们在把你赶回原点
Freedom, oh, freedom. That&#39;s just some people talkin&#39;
自由，噢自由。那只是有些人说的
You&#39;re a prisioner walking through this world all alone.
你是孤独闯世界的囚犯</p>
</blockquote>
<p>面完百度后，一直循环在听“亡命之徒”，而心情沮丧得就和上次考完雅思口语一样。
是的，因为我压根没想到我能进面试。
是的，我一定是太不自信。
这个面试官也一定和上次口语考官一样想吧，这个人啥都没准备啥都不会还敢来面试（考试）？</p>
<p>跟妈妈打了电话，想想还是不用太沮丧，虽然是百度，但这是你的第一次面试，所以经验缺乏，应答不自然是正常的。
内功不深厚，肚子里没货，怎么倒腾也是倒不出东西的吧。</p>
<p>对于面试：</p>
<ol>
<li>一定一定要准备好一个<strong>精彩的自我介绍</strong>。</li>
<li>一定一定得<strong>有自信</strong>，不要认为自学非科班项目经验少就会低人一等，要对自己的能力有信心（自己接电话时就是太不自信了，心里貌似就是有一个暗示，觉得BAT那么高大上的公司怎么进得去），不要过分仰视那些大公司，否则自己永远也进不去。</li>
<li>试着写个好简历，然后多投递下简历，增加宝贵笔试、面试经验，以后面试时能更加从容面对。</li>
</ol>
<p>对于能力提升：</p>
<ol>
<li>夯实<code>HTML&amp;CSS</code>的基础知识。
多写读书笔记，多总结经验，这样才能在真正需要它们的时候运用自如。</li>
<li>必须立刻继续<code>JavaScript</code>的学习。
之前断断续续看过一点JS的知识，但是最近倒腾网站就转移了很多注意力到服务器端，导致什么都不精，自己也找不到了方向。一本「JavaScript高级程序设计」啃来啃去。</li>
<li>开始<code>Ajax</code>、<code>jQuery</code>的认真学习。
你看看，连写个异步编程都不会。接下来还有Node.js呢。</li>
<li><strong>不要好高骛远，不要赶潮流耍花招。</strong>
之前真是过于浮躁，看了很多新技术的书，但连最基础的东西都没学好。</li>
</ol>
<p><blockquote>
    让你自己成为一个持续学习和思考的人，并只写你真正思考和总结之后的产物，其他一切就会随之而来。
</blockquote>
加油吧，希望能在通往大牛的道路上越走越远。</p>
]]></description><link>/2014-11-04-baidu-interview-thought/index.html</link><guid isPermaLink="true">/2014-11-04-baidu-interview-thought/index.html</guid><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Tue, 04 Nov 2014 08:13:00 GMT</pubDate></item><item><title><![CDATA[Ali校招笔试题思考]]></title><description><![CDATA[<h1 id="ali-">Ali校招笔试题思考</h1>
<p>昨晚搭着末班车，参加了阿里今年的实习生在线笔试。
回忆之前惨不忍睹的内推面试，玩了整整一个寒假后接到了不期而至的面试电话，连之前一些基础的还算熟悉的题都答得不流畅自然一气呵成，我就知道我悲剧了。
痛定思痛，作为一个即将毕业的大四老鸟（只是说年龄...)，在被各种鄙视，各种蜚语，各种不确定存在的黑暗时期，依旧不屈不挠地学习思考着，我都要被自己感动了。
笔试题只有一个小时，13道题，一开始是单项选择和不定项选择，考了AMD编码规范、闭包、setTimeout的异步、前端安全及一些我认为蛮有意思的小题，挺考基础的，不是太难，但要细心，我居然也慢悠悠做，时间就那么过去了一半。后来看到了六大道问答题，基本是编程，涉及CSS3、原生JS、事件处理、Ajax等，就渐渐慌了，写代码的手居然有了渐冻症的感觉，心理素质有待提高。
于是在有差不多一半大题没完成的情况下，被迫交了卷。交卷后才灵感突现，猛然想起了那些题的解法，还是代码经验不够啊。为了防止再出现这样的情况，在这里贴下题目思路和解答。</p>
<hr>
<p>关于CSS，有题是用<code>HTML&amp;CSS</code>实现一个九宫格，外边框为1px，内部无边框。之前没有做过九宫格布局，当时又很捉急居然被卡住了。交完卷后突然在想，这不就是考<code>float</code>的嘛。
遂编码如下：</p>
<pre class="hljs"><code><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>九宫格<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
      <span class="hljs-tag">ul</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">list-style</span>:<span class="hljs-value"> none</span></span>;
          <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">158px</span></span></span>;
          <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">158px</span></span></span>;
      }</span>
      <span class="hljs-tag">li</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">50px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">50px</span></span></span>;
          <span class="hljs-comment">/<em>box-sizing: border-box;</em>/</span>
          <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#888</span></span></span>;
          <span class="hljs-rule"><span class="hljs-attribute">float</span>:<span class="hljs-value"> left</span></span>;
      }</span>
      <span class="hljs-class">.one</span>,<span class="hljs-class">.four</span>, <span class="hljs-class">.seven</span><span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">border-left</span>:<span class="hljs-value"> <span class="hljs-number">3px</span> solid red</span></span>;
          <span class="hljs-comment">/<em>z-index: 2;</em>/</span>
      }</span>
      <span class="hljs-class">.one</span>, <span class="hljs-class">.two</span>, <span class="hljs-class">.three</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">border-top</span>:<span class="hljs-value"> <span class="hljs-number">3px</span> solid red</span></span>;
      }</span>
      <span class="hljs-class">.three</span>, <span class="hljs-class">.six</span>, <span class="hljs-class">.nine</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">border-right</span>:<span class="hljs-value"> <span class="hljs-number">3px</span> solid red</span></span>;
      }</span>
      <span class="hljs-class">.seven</span>, <span class="hljs-class">.eight</span>, <span class="hljs-class">.nine</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">border-bottom</span>:<span class="hljs-value"> <span class="hljs-number">3px</span> solid red</span></span>;
      }</span>

    </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>
    HTML CSS 九宫格 外边框1px 内部无边框
    <span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;list&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;two&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;three&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;four&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;five&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;six&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;seven&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;eight&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;nine&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre><p>其实就是每个盒子固定宽高，父元素也固定宽高，分别为盒子宽高的3倍+左右（或上下）两边的边框宽度，然后都浮动起来。内部无边框外部有边框也容易实现，只要把最外圈的盒子按顺序设定 <code>border-top</code>、<code>border-bottom</code>、<code>border-left</code>、<code>border-right</code>即可。
思考：</p>
<ul>
<li>一开始把父元素刚好设为盒子宽高的3倍，盒子设定为<code>box-sizing: border-box</code>后，发现边框自动隐藏了，所以要体现有边框还是不能这样；</li>
<li>该题不难，其实还可以拓展成N宫格，<code>父元素的宽高 = N*盒子宽高 + 2*border-width</code>，相当于做个图片墙。</li>
</ul>
<p>JS跨浏览器事件处理：给你个超链接按钮，用户点击后不进行链接跳转，而是提示“用户名不能为空”，要尽可能兼容更多的浏览器。
这题考的也就是跨浏览器的事件处理啦，之前看过《JavaScript高级程序设计》时候，专门有一小节讲跨浏览器事件处理，给出了完整的解决方案，自己也用心写了<code>Code Snippet</code>笔记，但是实践少，考试时做的不太顺利，这里重新整理下贴下代码。
（Ghost Gist 托管，若无显示请戳 <a href="https://gist.github.com/githubzbl/8170f1e96e7bf3c66ca5">跨浏览器事件处理Gist</a>）</p>
<script src="https://gist.github.com/githubzbl/8170f1e96e7bf3c66ca5.js"></script>

<p>思考：</p>
<ul>
<li>事件处理很简单，关键就在兼容浏览器，这里就得照顾到IE；</li>
<li>当时考试时居然把<code>&lt;script&gt;</code>标签及其里面的代码写到了<code>&lt;head&gt;</code>里面，导致<code>document.getElementById(&#39;btn&#39;)</code>返回的一直是<code>undefined</code>，现在想想给自己跪了，<code>DOM</code>都没准备好哪来的<code>getElementById()</code>。</li>
</ul>
<p>JS统计字符串中出现次数最多的字符并打印统计信息。
这题当时看的时候居然看成<em>找出现最多的字符串</em>，心想天哪噜大阿里真厉害前端还考字符子串问题，这算法……，时间紧迫，遂想都没想直接跳过了。交卷后仔细回想才发现是<em>找字符</em>啊！再给自己跪下*2。
在老道那本《Good Parts》里有个gist是去计算一段文本中每个单词的出现次数，因为每个单词是用空格符隔开，所以思路也可以迁移到单个字符。思考后编码如下：
（Ghost Gist 托管，若无显示请戳 <a href="https://gist.github.com/githubzbl/a0ab1b7dd4f0128e9d6d">字符计数</a>）</p>
<p><script src="https://gist.github.com/githubzbl/a0ab1b7dd4f0128e9d6d.js"></script>
思考：</p>
<ul>
<li>将字符串分成单个字符很简单，甚至不用<code>RegExp</code>；</li>
<li>分成单个字符后存入一个对象，巧妙的是对象的属性即为该字符，属性值为该字符在字符串中出现的次数；</li>
<li>最后简单的用<code>for in</code>遍历属性排序，当然老道说<code>for in</code>不好，不知道这个地方需不需要改善。</li>
</ul>
<p>JS 给定一个http接口，传入一个员工id，返回员工的详细信息，接口形式为：<code>http://localhost/query?id=</code>，要求在前端实现一个根据一批员工id，通过ajax查询员工信息的功能。
Ajax show time, finally.
之前只写过几个Ajax，并不是太熟练，所以这题拿不准。
既然给了URL，一般就是要考<code>RegExp</code>啦，但是这个只要根据<code>id</code>查询就好，是不是只用<code>url.split(&#39;=&#39;)</code>，然后就知道ID了呢？
HTTP接口应该也就是写个函数模块吧。暂时给思路如下，待完善。</p>
<pre class="hljs"><code> $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>{
   <span class="hljs-keyword">var</span> id = url.split(<span class="hljs-string">&#39;=&#39;</span>)[<span class="hljs-number">1</span>];
   $(<span class="hljs-string">&#39;.btn&#39;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
        $.ajax({
            url: <span class="hljs-string">&#39;<a href="http://localhost/query?id=">http://localhost/query?id=</a>&#39;</span>,
            type: <span class="hljs-string">&#39;GET&#39;</span>,
            dataType: <span class="hljs-string">&#39;html&#39;</span>,
            data: {param1: id},
        })
        .done(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;success&quot;</span>);
        })
        .fail(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;error&quot;</span>);
        })
        .always(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;complete&quot;</span>);
        });
    });
  });</code></pre><hr>
<p>差不多就这些了，想到新思路再来更新吧。前端坑是很多，但也很有趣，感觉自己终于入门了呢。
还是那句，希望自己在成为大牛的道路上越走越远。</p>
<hr>
<p>续：觉得做的一般也收到了面试通知。但阿里又说“针对2015届招聘已结束，无论面试结果如何我们都不能承诺您能加入”。伤心归伤心，毕竟迟了那么点。
但再怎么着也要执着走下去。
<strong>“It&#39;s never too late to start.”</strong></p>
]]></description><link>/2014-11-04-alibaba-interview-thought/index.html</link><guid isPermaLink="true">/2014-11-04-alibaba-interview-thought/index.html</guid><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Tue, 04 Nov 2014 08:13:00 GMT</pubDate></item><item><title><![CDATA[oh My Ghostium]]></title><description><![CDATA[<p><img src="http://zbl-ghost-backup.qiniudn.com/oh-my-ghostium.jpg" alt="oh my ghostium"></p>
<p>之前装了Wordpress扔在大洋彼岸一个Arizona搬瓦工的VPS后就再没去理过它，想想也有半年了。<br>后来分析觉得，首先肯定是自己懒惰浮躁，静不下来写东西。其次是博客页面没有漂亮到让我有一种打开就想写的冲动。<br>但是他们说<strong><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/">为什么你应该（从现在开始就）写博客</a></strong>，于是紧跟大牛的步伐，虽然没有什么牛逼技术可以跟别人分享，但是看看大牛写的技术文章谢谢心得也是一种进步。于是就开始了<em>万劫不复的折腾深渊</em>...<br>在谷歌搜寻平台的时候看到了一个同是F2E的一个博客<a href="http://luolei.org">罗磊的独立博客</a>，瞬间被大Banner的设计吸引到，看了很久后拖到了网页末尾，扫到了一行字<em>本博客基于拽酷炫的 GHOST</em>。<br>比较了<em>Ghost/Jekyll/Octo/Hexo</em> 等等之后，认为<strong><a href="https://ghost.org">Ghost</a></strong>还是最适合我： </p>
<ol>
<li>基于 <strong>Node.js</strong> 的博客平台。</li>
<li><strong>Just a blogging platform.</strong>简单简洁，响应式设计。</li>
<li>免费，<strong>支持完全的自定义</strong>。</li>
</ol>
<p>DigitalOcean很贴心的有Ghost的APP安装镜像包，安装后直接打开<code>http://your.domain/2368</code>就会看到第一次登陆的窗口，设置好Blog Title，用户名，密码就可以愉快的开始体验Ghost了。<br>又过了几天，手贱浏览了很多搭建在Ghost的博客，发现大家怎么都这样啊，使用默认的Casper主题已到审美疲劳。<br>那么在连博文都没写几篇的情况下，继续<em>万劫不复的折腾深渊</em> 咯。  </p>
<p>很喜欢<a href="https://medium.com/">Medium</a>那个网站的设计风格，漂亮的排版和字体，恰当的行高，带有震撼般视觉冲击的大Banner图片...<sup><a href="#fn1" id="ref1">1</a></sup>  感觉一切的设计都如此恰到好处（一股浓浓的高逼格气息扑面而来）。</p>
<p>谷歌搜索类Medium的Ghost主题，<br> <strong><a href="http://ghostium.oswaldoacauan.com/">Ghostium</a>, a medium-like theme.</strong><br>先给作者<a href="https://twitter.com/oswaldoacauan">@oswaldoacauan</a>点赞，心中想要的样式全都有。
安装完在网站上跑了一会后，发现有些细节地方还是不尽如我意。<br>那么，还是自己动手丰衣足食，开始<em>万劫不复的折腾深渊</em> 第四弹。
一边看<a href="http://themes.ghost.org/v0.5.3/docs/about">Ghost Developer Documentation</a>、<a href="http://handlebarsjs.com/">Handelbars.js Guide</a>，一边用自学的一点点 HTML&amp;CSS&amp;JS 来调试和修改原主题。</p>
<hr>
<p>####HTML</p>
<ul>
<li>修改Drawer侧栏的导航（Navigation.hbs），增加Links如下:<pre class="hljs"><code><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/timeline/&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-clock-o&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Timeline
<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/wiki/&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-coffee&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Wiki
<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/book/&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-camera-retro&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Portfolio
<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/about/&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-comment-o&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>About Me
<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span></span></code></pre></li>
<li>在博客文章内容页（post.hbs）删除了分享到G+图标，增加了分享到微博图标：  <pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;#&quot;</span> <span class="hljs-attribute">data-action</span>=<span class="hljs-value">&quot;share-weibo&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-fw fa-lg fa-weibo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span></code></pre></li>
</ul>
<hr>
<p>####CSS(main.css)  </p>
<ul>
<li><p>字体类型及大小<br>原来的字体太小，而且因为主题原作者不说汉语，故默认在主题内显示的汉字为宋体，且行高较小，不方便阅读。<br>搜索后发现这么几篇文章：<a href="https://ruby-china.org/topics/14005">web中文字体应用指南</a>、<a href="http://lepture.com/zh/2014/chinese-fonts-and-yue-css">適合閱讀的中文字體</a>、<a href="http://informationarchitects.net/blog/the-web-is-all-about-typography-period/">網頁上95%的內容其實都是&quot;typography“</a>。<br>于是根据自己的喜好，同时照顾到广大Mac、Windows用户，字体样式如下：</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> 文章内容 衬线字体 </em>/</span>
<span class="hljs-comment">/<em> &quot;Xin Gothic&quot; 信黑体；&quot;STXihei&quot; 华文细黑；&quot;Hiragino Sans GB&quot; 冬青黑体 </em>/</span>
<span class="hljs-tag">body</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">font</span>:<span class="hljs-value"> <span class="hljs-number">400</span> <span class="hljs-number">20px</span>/<span class="hljs-number">1.62</span> <span class="hljs-string">&quot;Lora&quot;</span>, Georgia, <span class="hljs-string">&quot;Xin Gothic&quot;</span>, <span class="hljs-string">&quot;STXihei&quot;</span>, Cambria, <span class="hljs-string">&quot;Droid Sans Fallback&quot;</span>, <span class="hljs-string">&quot;Microsoft YaHei&quot;</span>, sans-serif</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#fff</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#333</span>
  </span></span></span>}
<span class="hljs-comment">/<em> 文章标题、按钮等 非衬线 </em>/</span><br><span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">font-family</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Lato&quot;</span>,<span class="hljs-string">&quot;Myriad Pro&quot;</span>,<span class="hljs-string">&quot;Lucida Grande&quot;</span>,<span class="hljs-string">&quot;Lucida Sans Unicode&quot;</span>,<span class="hljs-string">&quot;Lucida Sans&quot;</span>,Geneva,Verdana,sans-serif</span></span>;}</span>
<span class="hljs-comment">/<em> Footer底部字体 Optima更为优雅低调 </em>/</span>
<span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">font-family</span>:<span class="hljs-value"> Optima, sans-serif</span></span>;}</span></code></pre><p>我选择了<strong>Lato &amp; Lora</strong>搭配，同为 Transitional Fonts <sup><a href="#fn2" id="ref2">2</a></sup></p>
</li>
<li><p>主页（index.hbs）的封面/边距/文章摘要 </p>
<ul>
<li>原来的<code>cover</code>大概占据了页面的30%，看起来图片有点喧宾夺主，经过反复折腾后，觉得25%的比例最不错。  <pre class="hljs"><code><span class="hljs-class">.cover</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value"> relative</span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">top</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">left</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">25%</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">z-index</span>:<span class="hljs-value"> <span class="hljs-number">100</span>
</span></span></span>}</code></pre></li>
</ul>
</li>
<li><p>主页右侧文章内容距顶端太近。中文内容会感觉一块块的，特别突兀，调整<code>padding</code>，使内边距更大。反复比较后，6%看起来最自然。</p>
<pre class="hljs"><code>  <span class="hljs-class">.wrapper-container</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value"> relative</span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">6%</span> <span class="hljs-number">10%</span> <span class="hljs-number">40px</span> <span class="hljs-number">185px</span></span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">max-width</span>:<span class="hljs-value"> <span class="hljs-number">910px</span>
  </span></span></span>}</code></pre><ul>
<li>主页右侧的文章摘要(post/list.hbs)原来为  <pre class="hljs"><code><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">section</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;description&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;post-item-excerpt&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span></span><span class="hljs-expression">{{<span class="hljs-variable">excerpt</span> <span class="hljs-variable">words</span>=<span class="hljs-string">&quot;35&quot;</span>}}</span><span class="xml">&amp;hellip;<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-title">section</span>&gt;</span></span></code></pre>如果是英文内容恰好，但是对于中文内容，Ghost貌似对这个支持不太好（因为是按空格来计算word数量），所以显示的摘要往往会过多，查看文档后发现有另一种<code>character</code>字符数计数方式。很高兴地修改如下:<pre class="hljs"><code><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">section</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;description&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;post-item-excerpt&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span></span><span class="hljs-expression">{{<span class="hljs-variable">excerpt</span> <span class="hljs-variable">characters</span>=<span class="hljs-string">&quot;140&quot;</span>}}</span><span class="xml">&amp;hellip;<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-title">section</span>&gt;</span></span></code></pre></li>
</ul>
</li>
<li><p>全局导航栏(drawer.hbs)<br>  每个导航栏(.drawer-list-item)字体过小，且挨得太近。参考了一下我最喜欢的<strong>Medium</strong>设计后，修改如下：</p>
<pre class="hljs"><code>  <span class="hljs-class">.drawer-list-item</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">font-family</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Lato&quot;</span>,<span class="hljs-string">&quot;Myriad Pro&quot;</span>,<span class="hljs-string">&quot;Lucida Grande&quot;</span>,<span class="hljs-string">&quot;Lucida Sans Unicode&quot;</span>,<span class="hljs-string">&quot;Lucida Sans&quot;</span>,Geneva,Verdana,sans-serif</span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">font-weight</span>:<span class="hljs-value"> <span class="hljs-number">600</span></span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> .<span class="hljs-number">9em</span></span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#9c9c9c</span></span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"> <span class="hljs-number">2.2</span></span></span>;
  }</span></code></pre></li>
<li><p>博客内容分页(post.hbs)<br>  对于作者的头像<code>.post-author-avatar</code>，原作者可能了为了保证质量，头像不被随意拉伸，</p>
<pre class="hljs"><code><span class="hljs-class">.post-author-avatar</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">border-radius</span>:<span class="hljs-value"> <span class="hljs-number">100%</span> </span></span></span>}</code></pre><p>采取了长宽度100%，但是四个角自然圆角，所以如果传的头像是矩形就会出现椭圆形的效果，但是个人觉得还是圆形头像更精致。所以为了保证无论上传何种比例的图片，得到的都是圆形的头像，那么就采用固定长宽度（此处在看Ghost后台时候，发现默认的作者头像就是圆形，查看源代码发现使用的是<code>js-model-image</code>，涉及到JS还未深入研究）。   </p>
<pre class="hljs"><code>  <span class="hljs-class">.post-author-avatar</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">80px</span></span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">80px</span></span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> block</span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">margin-bottom</span>:<span class="hljs-value"> <span class="hljs-number">10px</span>
  </span></span></span>}</code></pre></li>
</ul>
<p><strong>优化</strong>：<br>对于谷歌字体在国内<del>访问速度不佳</del>无法访问，使用了<a href="http://libs.useso.com/">360网站卫士加速库</a></p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;//fonts.useso.com/css?family=<em>*</em>&quot;</span>&gt;</span></code></pre><p>大体地方修改完毕，把修改后主题上传到VPS，重启Ghost服务（因Ghost无法实时探测到<code>content/theme/</code>内容改变）。<br>Well done.</p>
<hr>
<p><strong>Roadmaps：</strong>  </p>
<ul>
<li><input type="checkbox" disabled checked /> 微博官方的分享按钮太花哨，想使用FontAwesome的图标但还未解决如何触发微博分享；(使用一个JS函数解决)  </li>
<li><input type="checkbox" disabled> 把博客内容页面<code>post</code>样式从<code>main.css</code>中分离出来，方便以后Ghost升级做所见即所得；</li>
<li><input type="checkbox" disabled> 在<code>post</code>页面加入一个返回顶部的小箭头；</li>
<li><input type="checkbox" disabled checked> Ghost不支持Markdown中的<code>footnote</code>，也就是脚注语法，但个人觉得这是挺实用的一项功能，试着自己写原生JavaScript来支持它；<br>ps.官方说此功能在后台编辑器的RoadMap中，以后会更新。暂使用HTML解决如下：<pre class="hljs"><code>The <span class="hljs-keyword">sentence</span> leading up <span class="hljs-built_in">to</span> <span class="hljs-operator">the</span> notation.&lt;sup&gt;&lt;<span class="hljs-operator">a</span> href=<span class="hljs-string">&quot;#fn1&quot;</span> id=<span class="hljs-string">&quot;ref1&quot;</span>&gt;<span class="hljs-number">1</span>&lt;/<span class="hljs-operator">a</span>&gt;&lt;/sup&gt;
&lt;sup id=<span class="hljs-string">&quot;fn1&quot;</span>&gt;<span class="hljs-number">1.</span> Here is <span class="hljs-operator">the</span> notation that <span class="hljs-operator">the</span> <span class="hljs-keyword">sentence</span> above leads up <span class="hljs-built_in">to</span>.&lt;<span class="hljs-operator">a</span> href=<span class="hljs-string">&quot;#ref1&quot;</span>&gt;↩&lt;/<span class="hljs-operator">a</span>&gt;&lt;/sup&gt;</code></pre></li>
<li><input type="checkbox" disabled> 在<code>post</code>页面应用类似于Medium文章打开后顶部为震撼图片的大Banner；</li>
<li><input type="checkbox" disabled> 学习使用JS-model-image 自动切割Avatar及Logo；</li>
<li><input type="checkbox" disabled> Navigation各种链接网页的相关建设及完善；</li>
<li><input type="checkbox" disabled> 博文搜索；</li>
<li><input type="checkbox" disabled> 画个网站结构图 site-map。</li>
</ul>
<hr>
<p>你问我为何要如此折腾？哈，你不知道吗——</p>
<blockquote class=pullquote>
参差多态，实乃幸福本源。
</blockquote>

<hr>
<p> <sup id="fn1">1. 知乎：<a href="http://zhi.hu/1Ed2">怎样评价Medium的设计</a> <a href="#ref1">↩</a></sup><br><sup id="fn2">2.  <a href="https://www.codeschool.com/courses/fundamentals-of-design">Foundamental of Design by Code School</a> <a href="#ref2">↩</a></sup></p>
]]></description><link>/2016-10-21-oops-devops/index.html</link><guid isPermaLink="true">/2016-10-21-oops-devops/index.html</guid><category><![CDATA[ghost]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Mon, 03 Nov 2014 06:40:00 GMT</pubDate></item></channel></rss>