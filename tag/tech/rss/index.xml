<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[undefined - ZBL's Doodle]]></title><description><![CDATA[Thoughts, ideas, codes, all by myself]]></description><link>http://zhangbinliu.me/</link><generator>Ghost</generator><lastBuildDate>Sun, 04 Nov 2018 15:29:42 GMT</lastBuildDate><atom:link href="http://zhangbinliu.me/tag/undefined/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Uber 高性能 Web App 优化实践]]></title><description><![CDATA[<p>原文 <a href="https://eng.uber.com/m-uber/">Building m.uber: ENGINEERING A HIGH-PERFORMANCE WEB APP FOR THE GLOBAL MARKET</a></p>
<p><strong>Performance matters on mobile.</strong></p>
<p>又是一篇关于性能优化的实践。</p>
<p>m.uber 团队对 m.uber，他们的超级轻量 web app 做了一些性能优化的工作。</p>
<p>范围全面，从代码到打包到部署到缓存，都有涉及。</p>
<h2 id="tl-dr">TL;DR</h2>
<h3 id="performance-tools">Performance Tools</h3>
<ul>
<li>Preact over React</li>
<li>Webpack  <a href="https://webpack.js.org/guides/code-splitting-async/">dynamic bundle splitting</a> &amp; <a href="https://webpack.js.org/guides/tree-shaking/">tree-shaking capabilities </a></li>
<li>Tiny Libraries &amp; Minimal Dependencies</li>
<li><a href="https://www.npmjs.com/package/source-map-explorer">source-map-explorer</a></li>
</ul>
<p>下面是正文：</p>
<h3 id="smaller-faster-how-we-built-it">Smaller, faster: how we built it</h3>
<h4 id="-">技术栈</h4>
<p>代码层面：ES2015+，使用 Babel 编译；</p>
<p>框架：<code>Preact</code> + <code>Webpack</code>；</p>
<p>设计的痛点是，在保证类 Native App 丰富体验的同时，最小化客户端体积。所以 Preact + <a href="https://webpack.github.io/">Webpack</a> 的 <a href="https://webpack.js.org/guides/code-splitting-async/">dynamic bundle splitting</a> 和 <a href="https://webpack.js.org/guides/tree-shaking/">tree-shaking capabilities </a> 功能完美搭配。</p>
<h4 id="initial-server-render-">Initial server render 首次服务端渲染</h4>
<p>因为在所有核心打包的 JS 全部被下载前，客户端或浏览器都不能开始渲染 markup 标记。</p>
<p>为了更快首屏渲染，m.uber 在首次浏览器请求时候会返回服务端渲染好的 Preact，且 <code>state</code> 及 <code>markup</code> 都嵌到行内，全部都是字符串，所以这些内容一旦被客户端下载，就可以立马加载出来。</p>
<h4 id="serve-bundles-on-demand-">Serve bundles on demand 按需打包加载</h4>
<p>m.uber 中大部分 JS 都是用来做一些辅助功能，这些都是没有必要一次性加载的，所以他们用了 Webpack 的 <code>Code Splitting</code> 工具按需加载代码。</p>
<p>（这个我在 Accounts 项目也实践过，一个巨大的 JS 文件拆分成了三个小的 JS 文件，不过也需要考虑每个 HTTP 请求时间。）</p>
<blockquote>
<p>We use a <em>splitPage</em> function that returns the ancillary bundle wrapped in an asynchronous component.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Example: settings page</span>
<span class="hljs-keyword">const</span> AsyncSettings = splitPage(
 {load: () =&gt; <span class="hljs-preprocessor"><span class="hljs-keyword">import</span>(‘../../screens/settings’)}
);</span>

<span class="hljs-comment">// 当且仅当 <code>AsyncSettings</code> 被 Parent Component render() 调用，</span>
<span class="hljs-comment">// setting bundle js 才会被下载.</span></code></pre><h4 id="tiny-libraries-">Tiny Libraries 更小的库</h4>
<p>m.uber 本意上是希望在 2G 网下也能飞快，所以打包后的体积也很重要。</p>
<p>他们 App 核心部分（叫车功能）在 gzipped &amp; minified 后只有 50kB 大小，所以在典型 2G 网（50kB/s, 500ms 延时）下，也能三秒内开始交互。</p>
<p>以下是优化前后的打包和依赖的对比。</p>
<p><img src="https://eng.uber.com/wp-content/uploads/2017/06/image4-3.png" alt="bundle size"></p>
<p>​</p>
<h4 id="preact-over-react">Preact over React</h4>
<p>体积原因， Preact (3kB GZip/minified)  &lt; React (45kB).</p>
<p>Preact 除了不支持 <code>PropTypes</code> 和合成事件外，还是可以的。</p>
<p>Preact 据说在组件和元素回收可能有点点问题，不过他们还是正在解决的吧... 反正 uber 的人觉得他们用着还不错。</p>
<h4 id="minimal-dependencies-">Minimal Dependencies 最小化依赖</h4>
<p>为了对付前端打包一个明显的<strong>依赖膨胀（dependency bloat）</strong>，Uber 的人对安装的 npm 包特别挑剔。</p>
<p>他们推荐使用 <code>Just</code> 那个包，或者参考它的 npm package 思想：一个函数只做一件事，且无其他任何依赖。（去 Just GitHub 看，包作者就是写这篇文章的人...）</p>
<p>与服务器端进行数据传输代价高昂，所以一些特别大的库，比如 <code>Moment</code> 这种超大的库就是不需要被下载的（但是我在想的是，他们是自己实现了一套类似 Moment 的东西吗？）</p>
<p>推荐了 <a href="https://www.npmjs.com/package/source-map-explorer">source-map-explorer</a>  工具来分析加载的依赖。这样的话能很直观的知道以后从哪块开始进行代码层面的优化。</p>
<p>于是我用这个工具来分析了下自己的项目 <code>creator-main-js</code>。</p>
<p><img src="/content/images/m_uber/creator-js-source-map-explorer.png" alt="creator-js-source-map-explorer"></p>
<h4 id="conditional-feature-set">Conditional Feature Set</h4>
<p>首次加载会调用 <code>window.performance</code> API，然后基于结果来考虑在该设备上是加载还是隐藏交互地图。</p>
<p>相当于是渐进增强的思想吧。</p>
<h4 id="minimal-render-calls">Minimal render Calls</h4>
<p>和 React 一样，Preact 每次 <code>render</code> Virtual DOM 都是有代价的。</p>
<p>所以优化方法也和 React 一样，尽可能地多用 <code>shouldComponentUpdate</code> 最小化 <code>render</code> 的调用。</p>
<h4 id="caching">Caching</h4>
<h5 id="service-workers">Service Workers</h5>
<p>又见 service workers，截获 URL 请求，修改网络和本地磁盘资源获取变为配置好的获取逻辑。</p>
<p>Uber 把首次 HTML 响应和 JS 包都用 SW 缓存了，所以就算间歇性断网 m.uber 也还是能渲染内容。</p>
<p>SW 也极大程度上降低了加载时间。 磁盘 I/O 性能在不同的 OS 和设备上都很不一样，就算从磁盘缓存拿数据也是<a href="https://github.com/w3c/ServiceWorker/blob/master/implementation_considerations.md#racing-allowed">特别慢</a>。SW 支持从浏览器缓存加载所有内容。</p>
<p>m.uber 客户端在每次 build 后都会安装一个新的 SW。</p>
<p>Webpack 每次都会生成动态打包名，build 环节会把新的打包名直接写到 service worker 模块里面。</p>
<p>一旦安装，会首先缓存核心 JS 库，然后 lazy-loading 缓存 HTML 及一些辅助的按需加载的 JS 包。</p>
<h5 id="local-storage">Local Storage</h5>
<p>Uber 的人觉得每次把经常变化的响应数据缓存到 SW 不太好，他们就把这些都扔到了浏览器 <code>localStorage</code>.</p>
<p>m.uber 每隔几秒就会从服务器端拉 ride status，再把这些最新的 status data 都放在 <code>localStorage</code> 中，当乘客返回 App 时候，就能立马重新渲染页面，而不需要等待 API 链路耗时。</p>
<p>每次的 status data 很小且体积有限，所以存储的更新很快，可依赖性也好。</p>
<p>他们最后终于意识到，其实并不需要类似 <code>indexedDB</code> 这样的本地异步存储 API。</p>
<h4 id="styling">Styling</h4>
<h5 id="styletron">Styletron</h5>
<p>m.uber 的样式都是用的 css-in-js，写成了 JS 对象形式，放在每个组件中。</p>
<p>他们使用了 <a href="https://github.com/rtsao/styletron">Styletron</a> 动态生成样式，这样的好处是，可以像 JS 一样，更灵活地动态打包切割、异步加载样式。</p>
<p>Styletron 可以通过创建原子样式(atomic stylesheet)，减少重复的样式声明，性能好像也不错， <a href="https://github.com/necolas/react-native-web/tree/master/benchmarks">best-in-class rendering performance</a>. 。</p>
<p>这个倒是可以考虑弄下，<code>create-react-app</code> 貌似不支持 <code>css-in-modules</code> 这种方式。我自己的脚手架<a href="https://github.com/cool4zbl/rocket">Rocket</a> 参考 <code>arc</code> 的 <strong>Atomic</strong> 思想，使用了 <code>styled-component</code>，不过看上面那个对比，性能好像有点低。</p>
<h5 id="svgs">SVGs</h5>
<blockquote>
<p>Used <a href="https://github.com/svg/svgo">SVGO</a> together with manual optimizations to further shorten the paths.</p>
<p>Replace polylines with basic shapes.</p>
<p>View box dimensions with suitable divisors to avoid expensive decimals in paths.</p>
</blockquote>
<p>为了节省空间，对于图标形式的图片尽量用 SVG 格式，然后在 <code>render</code> 方法中引入它们。</p>
<p>使用 <a href="https://github.com/svg/svgo">SVGO</a>、多使用简单图形、view box 使用合适的维度避免昂贵的数学计算开销。</p>
<p>整个 App 体积下降明显！</p>
<h5 id="fonts">Fonts</h5>
<p>谨慎使用字体大小和颜色，其实可以完全减少自定义字体，不用向视觉设计妥协了。</p>
<h4 id="error-handling">Error Handling</h4>
<ul>
<li>没有使用很大的错误监控的库，而是拓展了 <code>window.onerror</code> ，向服务器端发送客户端错误信息。</li>
<li>给 Preact <code>render</code> &amp; <code>shouldComponentUpdate</code> 方法包了一层，检测生命周期方法错误。</li>
<li>因为这样的设计，所以 CDN-hosted 文件抛出来的错误并不会给 <code>window.onerror</code> 提供什么有效信息，除非正确设置 CORS 头部。但就算是设置了 CORS，异步事件发生的错误还是并不能被跟踪到。于是他们把所有的事件监听都包了一层，允许错误通过 <code>try/catch</code> 传到父模块。</li>
</ul>
<h3 id="next-steps">Next Steps</h3>
<p>感觉 Uber 对于 UX 真的是做了大量的工夫，但是他们并没有因此而停止步伐。</p>
<ul>
<li>正打算确定一个方案：组件仅仅接受扁平化的基本数据类型和数组类型集合属性，最小化 <code>render</code>调用。这样的话就可以用 <code>React.pureComponent</code> （这里自动包含了 <code>SCU</code>）。<code>render</code>方法也可以专注于生成 HTML markup，而不需要处理一大堆逻辑和其他没什么意义的任务。把 API 响应转换为扁平的能被服务端逻辑代理的基本数据结构 (see <a href="https://github.com/paularmstrong/normalizr">normalizr</a>) ，或者用 <code>mapStateToProps</code>。<del>神奇的是，Creator 项目的 <code>WorkStore</code> 也用了类似 normalizr 的数据结构存储</del>（后来为了方便维护还是改用了 Redux...）。</li>
<li>把 <code>actions</code> &amp; <code>reducers</code> 结合起来，更容易分开打包。</li>
<li>对所有请求使用  <a href="https://en.wikipedia.org/wiki/HTTP/2">HTTP/2</a>  ，用 push notifications 代替 polling APIs.</li>
<li>另外，Uber 人正在考虑把 m.uber 的架构抽象出一个开源架构，成为未来轻量级 Uber Web App的基础。这让我想起了之前看过的 <a href="https://github.com/DDFE/DDFE-blog/issues/4">滴滴 Web App 架构</a>，同样是打车软件，滴滴 FE team 在 Web App 架构上也是做了大量工夫，值得参考学习。</li>
</ul>
<p>纵观这些方案，可以说把 Google 一直在推的 <strong><a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">PRPL Patterns</a></strong> 做到了极致。</p>
<p>以上。</p>
]]></description><link>/2017-07-10-m-uber-performance-optimazation/index.html</link><guid isPermaLink="true">/2017-07-10-m-uber-performance-optimazation/index.html</guid><category><![CDATA[tech]]></category><category><![CDATA[frontend]]></category><category><![CDATA[optimization]]></category><dc:creator><![CDATA[cool4ZBL]]></dc:creator><pubDate>Sun, 09 Jul 2017 16:00:00 GMT</pubDate></item><item><title><![CDATA[从十个 React 迷你设计模式谈开去]]></title><description><![CDATA[<p>很早之前就一直在读的一篇文章，<a href="https://hackernoon.com/10-react-mini-patterns-c1da92f068c5">10 个React Mini 设计模式</a>，一边做 <code>Creator</code> 项目，也一边终于把它精读完。</p>
<p>结合自己的开发时候的项目经验，做了点笔记。</p>
<p><code>Creator</code> 项目是一个多端（Web + Mobile）React SPA，且有一些表单填写和复杂的交互组件。</p>
<p><del>自己单独封装了一个很简单的基于 Node <code>EventEmitter</code> 的 <code>Store</code>，开发过程中收获很大，这些细节之后可以细说。</del> 产品那边后来又加了「置顶」功能，类似双向数据通信的 <code>EventEmitter</code> 逻辑有点太乱了，所以还是狠心花时间升级成了 <code>Redux</code> + <code>Immutable.js</code> + <code>Normalizr</code> 技术栈，果然省心很多。</p>
<p>原文作者说你是不是天天写 React, 写着写着发现自己可能经常用来实现需求的，也总是那么几个方法，往大了讲其实就是开发中的 <strong>设计模式</strong>。在这里我们称为 <strong>Mini Patterns</strong>。</p>
<h2 id="-1-sending-data-down-and-up-">#1 Sending data down and up 数据流</h2>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*J5XOQh2WKIl0NFTAMvcVbQ.png" alt="Data-flow"></p>
<ul>
<li>这里是父子通信的 React 数据流，ParentComponent  通过 <code>props</code> 传给 ChildComponent 值，ChildComponent 通过 <code>props</code> 传过来的一些 function 回调 parent 的一些方法。</li>
<li>组件间通信，还可以使用事件发布/订阅模式，及 <code>this.context</code> 黑魔法，或者第三方解决方案（Redux / MobX）</li>
</ul>
<h2 id="-2-fixing-html-s-inputs">#2 Fixing HTML’s inputs</h2>
<blockquote>
<p>If I’m building a site that will have a lot of user inputs, one of the first things I do is fix this.</p>
<p>You don’t need to keep working with the somewhat ass-about nature of HTML’s user input elements.</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/800/1*WTUJjlFOOnetc5NpbykN0w.png" alt="User Inputs"></p>
<ul>
<li><p>如果需要有大量 user inputs，最好是自己实现一套相关组件。</p>
</li>
<li><p>所以在 Creator 中基本自己实现了 <code>input</code>，<code>Select</code> 等组件。需求简单所以实现得也是很简单，其实 <code>Select</code> 组件仍然需要优化，比如自定义 <code>option</code> 样式，多选等等。</p>
</li>
<li><p>Input 最好通过 React 合成事件 <code>onChange</code> 返回一个值，而不是通过一个原生 JS <code>Event</code> 实例。React  基于 Virtual DOM 实现了一个 <code>SyntheticEvent</code> （合成事件）层，我们所定义的事件处理器会收到一个 <code>SyntheticEvent</code> 对象的实例，这个实例和原生的浏览器事件拥有一样的接口。而如果要访问原生事件对象的话，需要使用 <code>nativeEvent</code> 属性。React 官方建议说这会造成一定的性能问题。</p>
</li>
<li><p>在返回 <code>onChange</code> 的值之前确保一下是不是和输入的类型匹配。比如 <code>typeof props.value === &#39;number&#39;</code> 的话，在返回 <code>e.target.value</code> 前需要确保也是数字类型。</p>
</li>
<li><p>这里项目中有个选择证件类型的 <code>Select</code> 组件，与后端默认 身份证 = 0 / 护照 = 1，但是在 <code>e.target.value</code> 时候忘记 convert 了。所以还是需要记得判断下 <code>option</code> 的值类型。</p>
<pre class="hljs"><code>let {<span class="hljs-keyword">name</span>, <span class="hljs-keyword">value</span>} = e.<span class="hljs-type">target</span>
<span class="hljs-keyword">value</span> = isNaN(<span class="hljs-keyword">Number</span>(<span class="hljs-keyword">value</span>)) ? <span class="hljs-keyword">value</span> : <span class="hljs-keyword">Number</span>(<span class="hljs-keyword">value</span>)</code></pre><p>​</p>
</li>
<li><p>一堆单选按钮在功能上和一个 <code>&lt;select&gt;</code> 组件是一样的。没有必要把它们完全不一样地来对待，因为它们仅仅是 UI 不一样。其实可能只需要一个 <code>&lt;PickOneFromMany /&gt;</code> 组件就好，通过 <code>ui=&quot;radio&quot;</code> 或者<code>ui=&quot;dropdown&quot;</code> 来区分功能。</p>
</li>
<li><p><strong>React Form 与 HTML 的不同</strong></p>
<ul>
<li><code>value/checked</code> 设置后用户输入无效，相当于设置了 value，即变成了受控组件 controlled component.</li>
<li><code>textarea</code> 的值要设置在 value 属性</li>
<li><code>select</code> 的<code>value</code> 属性可以是数组，不建议使用 <code>option</code> 的 <code>selected</code> 属性</li>
<li><code>input/textarea</code> 的 <code>onChange</code> 每次输入都会触发，即使不失去焦点</li>
<li><code>radio/checkbox</code>  点击后触发 <code>onChange</code></li>
</ul>
<p>​</p>
</li>
</ul>
<h2 id="-3-binding-labels-to-inputs-with-unique-ids">#3 Binding labels to inputs with unique IDs</h2>
<blockquote>
<p>if you care about your users, you’ll bind your <code>&lt;label&gt;</code> elements to your <code>&lt;input&gt;</code>s via an <code>id</code>/<code>for</code> combo.</p>
<p>You <em>could</em> generate a random ID for each input/label pair, but then your client-rendered HTML won’t match your server-rendered HTML. Checksum error! That’s no good.</p>
<p>So, instead you can create a little module that gives an incrementing ID, and use that in an <code>Input</code> component like so:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Input Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.id = getNextId();

    <span class="hljs-keyword">this</span>.onChange = <span class="hljs-keyword">this</span>.onChange.bind(<span class="hljs-keyword">this</span>);
  }

  onChange(e) {
    <span class="hljs-keyword">this</span>.props.onChange(e.target.value);
  }

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;label htmlFor={<span class="hljs-keyword">this</span>.id}&gt;
        {<span class="hljs-keyword">this</span>.props.label}

        &lt;input
          id={<span class="hljs-keyword">this</span>.id}
          value={<span class="hljs-keyword">this</span>.props.value}
          onChange={<span class="hljs-keyword">this</span>.onChange}
          /&gt;
      &lt;/label&gt;
    );
  }
}

<span class="hljs-comment">// elementIdCreator.js</span>
let count = <span class="hljs-number">1</span>;

export const resetId = () =&gt; {
  count = <span class="hljs-number">1</span>;
}

export const getNextId = () =&gt; {
  <span class="hljs-keyword">return</span> <code>element-id-${count++}</code>;
}</code></pre><ul>
<li>用户体验相关，自动给表单的 <code>label</code>/<code>input</code> 加上一对一的 id.</li>
<li><code>getNextId()</code> 创建了一个闭包, 这里会返回一个计数器。</li>
</ul>
<h2 id="-4-controlling-css-with-props">#4 Controlling CSS with props</h2>
<p>使用 <code>props</code> 进行样式控制的三种方法</p>
<ol>
<li><p>使用主题 ( Using themes ). (Used in Proj Creator)</p>
<p><code>&lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt;</code></p>
<p>Tip: Do your best to only require one theme per component.</p>
<p>这种可能适合页面主题定制化。</p>
<p>Creator 中的 <code>&lt;Button /&gt;</code> 本来是用 theme 做区分，但是好像设计那边看起来就是一个主题，豆瓣绿经典款，所以后来改为了使用下面两种方式。</p>
<p>​</p>
</li>
<li><p>使用标志 (Using flags) (Used in Proj Creator)</p>
<p><code>&lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt;</code></p>
</li>
</ol>
<pre class="hljs"><code>  <span class="hljs-comment">// Creator Project:</span>
   Button.propTypes = {
     size: PropTypes.oneOf([
       <span class="hljs-string">&#39;sm&#39;</span>,
       <span class="hljs-string">&#39;md&#39;</span>,
       <span class="hljs-string">&#39;lg&#39;</span>,
       <span class="hljs-string">&#39;row&#39;</span>
     ]),
     status: PropTypes.oneOf(<span class="hljs-built_in">Object</span>.values(BUTTON_STATUS)),
     type: PropTypes.oneOf([
       <span class="hljs-string">&#39;submit&#39;</span>,
       <span class="hljs-string">&#39;save&#39;</span>,
       <span class="hljs-string">&#39;cancel&#39;</span>
     ])
   }

   <span class="hljs-comment">// Use className to control styles</span>
  <span class="hljs-keyword">const</span> cls = classNames(<span class="hljs-string">&#39;btn&#39;</span>, {
    [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn</code></span>]: <span class="hljs-literal">true</span>,
    [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${size}&lt;/span&gt;</code></span>]: !!size,
    [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${status}&lt;/span&gt;</code></span>]: !!status,
    [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${type}&lt;/span&gt;</code></span>]: !!type
  }, props.className)</code></pre><ol>
<li><p>Setting values.</p>
<p>直接设置 inline CSS 属性值。</p>
<p><code>&lt;Icon width=&quot;25&quot; height=&quot;25&quot; type=&quot;search&quot; /&gt;</code></p>
</li>
</ol>
<p> <strong>举个栗子</strong></p>
<p>   <img src="https://cdn-images-1.medium.com/max/800/1*Kx1jOQONhFZPnGe72Fd4tQ.png" alt="creating-a-link-component"></p>
<pre class="hljs"><code>   <span class="hljs-comment">// Link.js</span>
   <span class="hljs-keyword">const</span> Link = (props) =&gt; {
     <span class="hljs-keyword">let</span> className = <code>link link--${props.theme}-theme</code>;

     <span class="hljs-keyword">if</span> (!props.underline) className += <span class="hljs-string">&#39; link--no-underline&#39;</span>;

     <span class="hljs-keyword">return</span> &lt;a href={props.href} className={className}&gt;{props.children}&lt;/a&gt;;
   };

   Link.propTypes = {
     theme: PropTypes.oneOf([
       <span class="hljs-string">&#39;default&#39;</span>, <span class="hljs-comment">// primary color, no underline</span>
       <span class="hljs-string">&#39;blend&#39;</span>, <span class="hljs-comment">// inherit surrounding styles</span>
       <span class="hljs-string">&#39;primary-button&#39;</span>, <span class="hljs-comment">// primary color, solid block</span>
     ]),
     underline: PropTypes.<span class="hljs-keyword">bool</span>,
     href: PropTypes.<span class="hljs-keyword">string</span>.isRequired,
     children: PropTypes.oneOfType([
       PropTypes.element,
       PropTypes.array,
       PropTypes.<span class="hljs-keyword">string</span>,
     ]).isRequired,
   };

   Link.defaultProps = {
     theme: <span class="hljs-string">&#39;default&#39;</span>,
     underline: <span class="hljs-keyword">false</span>,
   };</code></pre><pre class="hljs"><code>   <span class="hljs-comment">// Link.css</span>
   <span class="hljs-class">.link--default-theme</span>,
   <span class="hljs-class">.link--blend-theme</span><span class="hljs-pseudo">:hover</span> {
     <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#D84315</span>;
   }

   <span class="hljs-class">.link--blend-theme</span> {
     <span class="hljs-attribute">color</span>: inherit;
   }

   <span class="hljs-class">.link--default-theme</span><span class="hljs-pseudo">:hover</span>,
   <span class="hljs-class">.link--blend-theme</span><span class="hljs-pseudo">:hover</span> {
     <span class="hljs-attribute">text-decoration</span>: underline;
   }

   <span class="hljs-class">.link--primary-button-theme</span> {
     <span class="hljs-attribute">display</span>: inline-block;
     <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span> <span class="hljs-number">25px</span>;
     <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;
     <span class="hljs-attribute">background</span>: <span class="hljs-hexcolor">#D84315</span>;
     <span class="hljs-attribute">color</span>: white;
   }

   <span class="hljs-class">.link--no-underline</span> {
     <span class="hljs-attribute">text-decoration</span>: none;
   }</code></pre><blockquote>
<p>JavaScript is easy, but with CSS you pay for your sins — once you’ve started a mess, it’s not easy to back out of.</p>
<p>True fact: fighting CSS specificity is the number one cause of death among web developers.</p>
<p>just guess how many CSS rules are combined to make this round circle with a number in it?</p>
<p>Twenty three rules.</p>
<p>That’s <em>not </em>including the styles inherited from eleven other rules.</p>
<p>The line-height alone is overridden nine times.</p>
</blockquote>
<p>   嗯，这里原文作者用 CSS specificity 优先级举了个例子。比如他说你现在可以去看看 medium 顶端导航上大 Title 的CSS 样式，
   光是 <code>line-height</code> 特么的就重写了九次！！！</p>
<p>   <img src="https://cdn-images-1.medium.com/max/800/1*lQzlIf8PPqeLUS5VOvTH4Q.png" alt="line-height-css-rules"></p>
<p>   ​</p>
<p>   这 <code>line-height</code> 要是一只猫的话，现在也早死了吧。</p>
<p>   React 的话，就好办了。</p>
<ul>
<li>控制组件的 classes ；<ul>
<li>移掉所有的全局 resets 然后都把它们扔到 Button.scss 中；</li>
<li>可以用 <code>all: unset</code> 去掉所有浏览器初始样式。</li>
</ul>
</li>
</ul>
<h2 id="-5-the-switching-component">#5 The switching component</h2>
<p>The switching component, rendering one of many components.
开关组件，每次只渲染众多组件中的一个。有点类似路由组件。</p>
<blockquote>
<p>This may be a <code>&lt;Page&gt;</code> component that displays one of many pages. Or tabs in a tab set, or different modals in a modal component.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">import</span> HomePage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./HomePage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> AboutPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./AboutPage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> UserPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./UserPage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> FourOhFourPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./FourOhFourPage.jsx&#39;</span>;

<span class="hljs-keyword">const</span> PAGES = {
  home: HomePage,
  about: AboutPage,
  user: UserPage,
};

<span class="hljs-keyword">const</span> Page = (props) =&gt; {
  <span class="hljs-keyword">const</span> Handler = PAGES[props.page] || FourOhFourPage;

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Handler</span> {<span class="hljs-attribute">...props</span>} /&gt;</span>
};

Page.propTypes = {
    page: PropTypes.oneOf(Object.keys(PAGES)).isRequired,
};

// Usage

<span class="hljs-tag">&lt;<span class="hljs-title">Page</span> <span class="hljs-attribute">page</span>=<span class="hljs-value">&quot;home&quot;</span> /&gt;</span></span></code></pre><p>If you replace the keys <code>home</code>, <code>about</code> and <code>user</code> with <code>/</code>, <code>/about</code>, and <code>/user</code>, you’ve got yourself half a router.</p>
<p>(Future post idea: removing <code>react-router</code>.)</p>
<p>这里 Creator 中还是使用了 <code>react-router</code> 作为 SPA 路由。而且用的是 <code>HashRouter</code>，这样的话一个个路径都可以由 <code>location.hash</code> 无刷新跳转。</p>
<p>个人觉得这是 <code>react-router</code> + <code>webpack</code> 两者结合来解决打包路径问题的最佳方案。</p>
<pre class="hljs"><code><span class="hljs-regexp">//</span> Route.jsx
import React from <span class="hljs-string">&#39;react&#39;</span>
import IntroPage from <span class="hljs-string">&#39;../Page/IntroPage&#39;</span>
import ApplyFormPage from <span class="hljs-string">&#39;../Page/ApplyFormPage&#39;</span>
import AddWorksPage from <span class="hljs-string">&#39;../Page/AddWorksPage&#39;</span>
import ApplyDonePage from <span class="hljs-string">&#39;../Page/ApplyDonePage&#39;</span>
import MyWorksPage from <span class="hljs-string">&#39;../Page/MyWorksPage&#39;</span>

const defaultHeader = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &lt;h1&gt;创作者认证申请&lt;/h1&gt;
const routes = [
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/&#39;</span>,
    <span class="hljs-attribute">exact</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;IntroPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/intro&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;IntroPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step1&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;ApplyFormPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step2&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;AddWorksPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step3&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;ApplyDonePage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/myworks&#39;</span>,
    <span class="hljs-attribute">header</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &lt;h1&gt;管理我的作品&lt;/h1&gt;,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;MyWorksPage /&gt;)
  }
]
export default routes</code></pre><pre class="hljs"><code>// App.js
import {
  HashRouter,
  Route
} from &#39;react-router-dom&#39;
import routes from &#39;./Route&#39;

const App = () =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-title">HashRouter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;App&#39;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">&#39;creator-wrapper&#39;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;header&#39;</span>&gt;</span>
          { routes.map((route, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-title">Route</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{index}</span> <span class="hljs-attribute">path</span>=<span class="hljs-value">{route.path}</span>
              <span class="hljs-attribute">exact</span>=<span class="hljs-value">{route.exact}</span>
              <span class="hljs-attribute">component</span>=<span class="hljs-value">{route.header}</span>
            /&gt;</span>
          )) }
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;main&#39;</span>&gt;</span>
          { routes.map((route, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-title">Route</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{index}</span> <span class="hljs-attribute">path</span>=<span class="hljs-value">{route.path}</span>
              <span class="hljs-attribute">exact</span>=<span class="hljs-value">{route.exact}</span>
              <span class="hljs-attribute">component</span>=<span class="hljs-value">{route.main}</span> /&gt;</span>
          )) }
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        { isMobile ? Footer() : Sidebar() }
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">HashRouter</span>&gt;</span>
)</code></pre><h2 id="-6-reaching-into-a-component">#6 Reaching into a component</h2>
<p>深入研究下组件</p>
<h3 id="render">render</h3>
<p>React Virtual DOM ==&gt; render ==&gt; DOM</p>
<pre class="hljs"><code>ReactComponent render(
  ReactElement <span class="hljs-keyword">element</span>,
  DOMElement container,
  [<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>]</span>
)</code></pre><blockquote>
<p>Render a ReactElement into the DOM in the supplied <code>container</code> and return a <a href="more-about-refs.html">reference</a> to the component (or returns <code>null</code> for <a href="reusable-components.html#stateless-functions">stateless components</a>).</p>
<p><code>ReactDOM.render()</code> controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React’s DOM diffing algorithm for efficient updates.</p>
</blockquote>
<ul>
<li><code>render()</code> 即把 <code>ReactElement</code> 插入到 DOM.</li>
<li>有状态组件 =&gt; <code>refs</code>，无状态组件 =&gt; <code>null</code></li>
<li>组件初次渲染之后再次更新，会使用 ReactDOM Diff algorithm</li>
<li>装载完后，如果有 callback 则执行</li>
<li><code>ReactDOM.render()</code> 不会影响 Container Node，只会影响 Container Node 的 Children Nodes. （可能是被覆盖替换啊..）</li>
</ul>
<pre class="hljs"><code>const myApp = &lt;App /&gt;   <span class="hljs-comment">// Just a <code>ReactElement</code>(object).</span>

const myAppInstance = ReactDOM.<span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">(&lt;App /&gt;, document.getElementById(<span class="hljs-string">&#39;root&#39;</span>)</span></span>)
myAppInstance.<span class="hljs-function"><span class="hljs-title">doSth</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// The ref returned from ReactDOM.render</span></code></pre><p>这里利用 <code>render</code> 方法得到了 App 组件的实例，就可以用它做点什么了。</p>
<p>但是如果在组件内，JSX 并不会返回一个组件的实例。组件内只是一个 <code>ReactElement</code>, 轻量级的 DOM，告诉 React 加载的组件应该长什么样。</p>
<blockquote>
<p>Keep in mind, however, that the JSX doesn&#39;t return a component instance! It&#39;s just a <strong>ReactElement</strong>: a lightweight representation that tells React what the mounted component should look like.</p>
</blockquote>
<h3 id="ref">ref</h3>
<p>Hmmm, 一个神奇的属性。</p>
<h4 id="the-ref-callback-attribute">The <code>ref</code> Callback Attribute</h4>
<ul>
<li>可以给任意 React 组件加上 <code>ref</code> prop. 组件被调用时候会新建一个该组件实例，而 <code>ref</code> 会指向这个实例。</li>
</ul>
<ul>
<li>也可以是一个 inline callback function，会在组件加载后立即执行。</li>
</ul>
<pre class="hljs"><code>  // <span class="hljs-type">ES5</span>

  render: function() {
    <span class="hljs-keyword">return</span> (
      &lt;<span class="hljs-type">TextInput</span>
        <span class="hljs-keyword">ref</span>={function(input) {
          <span class="hljs-keyword">if</span> (input != null) {
            input.focus();
          }
        }} /&gt;
    );
  },

  // <span class="hljs-keyword">or</span> <span class="hljs-type">ES6</span> arrow function way:
  render() {
    <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">TextInput</span> <span class="hljs-keyword">ref</span>={ c =&gt; this._input = c } /&gt;
  }
  componentDidMount() {
    this._input.focuse()
  }</code></pre><p>  ​</p>
<blockquote>
<p> When attaching a ref to a DOM component like <code>&lt;div /&gt;</code>, you get the DOM node back; when attaching a ref to a composite component like <code>&lt;TextInput /&gt;</code>, you&#39;ll get the React class instance.</p>
</blockquote>
<ul>
<li><code>refs</code> in <code>ReactComponent</code> =&gt; 得到 ReactComponent 实例，就可以调用相关实例方法了（继续 findDOMNode(refs) 就可以得到 DOM 节点，使用 DOM 方法）。</li>
<li><code>refs</code> in <code>DOM</code>  =&gt; 得到 DOM 节点，就可以使用 DOM 方法。</li>
<li><em>Note:</em> Note that when the referenced component is unmounted and whenever the ref changes, the old ref will be called with <code>null</code> as an argument. This prevents memory leaks in the case that the instance is stored, as in the first example. Also note that when writing refs with inline function expressions as in the examples here, React sees a different function object each time so on every update, ref will be called with <code>null</code> immediately before it&#39;s called with the component instance.</li>
<li>为防止内存泄露，当引用组件被卸载或者 <code>ref</code> 改变的时候，<code>ref = null</code>.</li>
<li>如果用 inline callback function，这里每次都会生成一个不同的 function object，所以当组件每次更新的时候，<code>ref</code> 都会被设置为 <code>null</code> 直到组件实例再次调用它。</li>
<li>其实这里也可以反映出，React 组件定义的时，如果 <code>props</code> 中用的是箭头函数，或者 <code>bind</code> 方法生成的函数，如<code>&lt;Button onClick={()=&gt;{handleClick}} /&gt;</code> 或者 <code>&lt;Button onClick={this.handleClick.bind(this)} /&gt;</code> React Diff 算法在比较的时候，会认为两次的 function object 引用对象是不相等的，所以每次都会重新渲染，这对于性能优化会有影响</li>
</ul>
<h4 id="the-ref-string-attribute-legacy-">The ref String Attribute <em>legacy</em></h4>
<p>要获取一个 React 组件的引用，既可以使用 this 来获取当前 ReactComponent，也可以使用 <code>ref</code> 来获取子组件的引用。</p>
<pre class="hljs"><code>&lt;input <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;myInput&quot;</span> /&gt;

// used <span class="hljs-keyword">in</span> componentDidMount()
<span class="hljs-keyword">var</span> input = this.refs.myInput;
<span class="hljs-keyword">var</span> inputValue = input.value;
<span class="hljs-keyword">var</span> inputRect = input.getBoundingClientRect();</code></pre><h4 id="refs-">refs 使用</h4>
<ul>
<li>DOM 操作</li>
</ul>
<blockquote>
<p>Performing DOM measurements almost always requires reaching out to a &quot;native&quot; component such as <code>&lt;input /&gt;</code> and accessing its underlying DOM node using a ref. Refs are one of the only practical ways of doing this reliably.</p>
</blockquote>
<ul>
<li>对于 <code>stateless component</code>， <code>findDOMNode()</code> &amp; <code>ref</code> 返回的都是 <code>null</code>，因为它只是函数执行，并不返回一个实例 <code>a backing instance</code>。要用的话只能自己去手动包一层 component.</li>
</ul>
<h4 id="an-example">An example</h4>
<p>Like adding <code>autofucus</code> to the input to pease your users in an easy way.</p>
<p>很简单很实用的 <code>autofucus</code> 功能。</p>
<p>The React Way</p>
<pre class="hljs"><code><span class="hljs-comment">// Child Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Compnent</span> {</span>
  focus() {
    <span class="hljs-keyword">this</span>.input.focus()
  }
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;input ref={(el)=&gt; <span class="hljs-keyword">this</span>.input = el} /&gt;
    )
  }
}

<span class="hljs-comment">// Parent Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SignInModal</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Component</span> {</span>
  componentDidMount() {
    <span class="hljs-keyword">this</span>.<span class="hljs-type">InputComponent</span>.focus(); <span class="hljs-comment">// 拿到 Input 组件的引用，就可以调用 Input 组件方法</span>
  }

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;
        &lt;label&gt;<span class="hljs-type">User</span> name: &lt;/label&gt;
        &lt;<span class="hljs-type">Input</span>
          ref={comp =&gt; { <span class="hljs-keyword">this</span>.<span class="hljs-type">InputComponent</span> = comp; }}
        /&gt;
      &lt;/div&gt;
    )
  }
}</code></pre><h2 id="-7-almost-components">#7 Almost-components</h2>
<blockquote>
<p>Don’t prematurely componentize. Components aren’t like teaspoons; you <em>can </em>have too many.</p>
<p>What I am saying: “take something that you <em>don’t</em> think should be a component, and make it a bit more like its own component (if it can be).”</p>
</blockquote>
<p>让那些你觉得不应该成为一个组件的东西，长得更像组件一点（如果它可以的话）。</p>
<h2 id="-8-components-for-formatting-text">#8 Components for formatting text</h2>
<p>用来做格式化的组件，也就是可以写工具组件。</p>
<p>其实这就是 HOC 高阶组件。一开始接触高阶组件觉得挺难理解的，后来读了下 <code>Redux</code> &amp; <code>react-redux</code> 源码，写了一些 redux middlewares，觉得好理解多了。无非也就是函数式编程的应用。
高阶函数：参数是函数，且返回函数的函数。=&gt; 高阶组件：参数是组件，且返回组件的组件。</p>
<pre class="hljs"><code><span class="hljs-comment">// Here’s a &lt;Price&gt; component that takes a number and returns a pretty string, with or without decimals and a ‘$’ sign.</span>

<span class="hljs-keyword">const</span> Price = (props) =&gt; {
  <span class="hljs-keyword">const</span> price = props.children.toLocaleString(<span class="hljs-string">&#39;en&#39;</span>, {
    style: props.showSymbol ? <span class="hljs-string">&#39;currency&#39;</span> : undefined,
    currency: props.showSymbol ? <span class="hljs-string">&#39;USD&#39;</span> : undefined,
    maximumFractionDigits: props.showDecimals ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>,
  });

  <span class="hljs-keyword">return</span> &lt;span className={props.className}&gt;{price}&lt;/span&gt;
};

Price.propTypes = {
  className: React.PropTypes.string,
  children: React.PropTypes.number,
  showDecimals: React.PropTypes.<span class="hljs-built_in">bool</span>,
  showSymbol: React.PropTypes.<span class="hljs-built_in">bool</span>,
};

Price.defaultProps = {
  children: <span class="hljs-number">0</span>,
  showDecimals: <span class="hljs-keyword">true</span>,
  showSymbol: <span class="hljs-keyword">true</span>,
};

<span class="hljs-keyword">const</span> Page = () =&gt; {
  <span class="hljs-keyword">const</span> lambPrice = <span class="hljs-number">1234.567</span>;
  <span class="hljs-keyword">const</span> jetPrice = <span class="hljs-number">999999.99</span>;
  <span class="hljs-keyword">const</span> bootPrice = <span class="hljs-number">34.567</span>;

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;p&gt;One lamb <span class="hljs-keyword">is</span> &lt;Price className=<span class="hljs-string">&quot;expensive&quot;</span>&gt;{lambPrice}&lt;/Price&gt;&lt;/p&gt;
      &lt;p&gt;One jet <span class="hljs-keyword">is</span> &lt;Price showDecimals={<span class="hljs-keyword">false</span>}&gt;{jetPrice}&lt;/Price&gt;&lt;/p&gt;
      &lt;p&gt;Those gumboots will <span class="hljs-literal">set</span> ya back &lt;Price showDecimals={<span class="hljs-keyword">false</span>} showSymbol={<span class="hljs-keyword">false</span>}&gt;{bootPrice}&lt;/Price&gt; bucks.&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre><p>这里当然可以很简单的用更少代码的普通函数来实现</p>
<pre class="hljs"><code><span class="hljs-comment">// could just easily use a function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberToPrice</span><span class="hljs-params">(num, options = {})</span> </span>{
  <span class="hljs-keyword">const</span> showSymbol = options.showSymbol !== <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">const</span> showDecimals = options.showDecimals !== <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">return</span> num.toLocaleString(<span class="hljs-string">&#39;en&#39;</span>, {
    style: showSymbol ? <span class="hljs-string">&#39;currency&#39;</span> : <span class="hljs-literal">undefined</span>,
    currency: showSymbol ? <span class="hljs-string">&#39;USD&#39;</span> : <span class="hljs-literal">undefined</span>,
    maximumFractionDigits: showDecimals ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>,
  });
}

<span class="hljs-keyword">const</span> Page = () =&gt; {
  <span class="hljs-keyword">const</span> lambPrice = <span class="hljs-number">1234.567</span>;
  <span class="hljs-keyword">const</span> jetPrice = <span class="hljs-number">999999.99</span>;
  <span class="hljs-keyword">const</span> bootPrice = <span class="hljs-number">34.567</span>;

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;p&gt;One lamb <span class="hljs-keyword">is</span> &lt;span className=<span class="hljs-string">&quot;expensive&quot;</span>&gt;{numberToPrice(lambPrice)}&lt;/span&gt;&lt;/p&gt;
      &lt;p&gt;One jet <span class="hljs-keyword">is</span> {numberToPrice(jetPrice, { showDecimals: <span class="hljs-literal">false</span> })}&lt;/p&gt;
      &lt;p&gt;Those gumboots will <span class="hljs-keyword">set</span> ya back {numberToPrice(bootPrice, { showDecimals: <span class="hljs-literal">false</span>, showSymbol: <span class="hljs-literal">false</span> })} bucks.&lt;/p&gt;
    &lt;/div&gt;
  );</code></pre><h2 id="-9-the-store-is-the-component-s-servant">#9 The store is the component’s servant</h2>
<p>用 <code>store</code> 来管理组件复杂度。</p>
<p>My suggestion:</p>
<ol>
<li>Work out the general structure of your components and the data they will require</li>
<li>Design your store to support those requirements</li>
<li>Do whatever you need to do to your incoming data to make it fit into the store.</li>
</ol>
<p>原文作者推荐使用单个模块来管理所有 Incoming data，所有的数据处理放在一起做，单元测试什么的也变简单了。</p>
<pre class="hljs"><code><span class="hljs-comment">// react/redux way</span>

<span class="hljs-tag">fetch</span>(<span class="hljs-built_in"><code>/api/search?${queryParams}</code></span>)
  <span class="hljs-class">.then</span>(response =&gt; response.<span class="hljs-function">json</span>())
  <span class="hljs-class">.then</span>(normalizeSearchResultsApiData) <span class="hljs-comment">// the do-it-all data massager</span>
  <span class="hljs-class">.then</span>(normalData =&gt; {
      <span class="hljs-comment">// dispatch normalData to the store here</span>
});</code></pre><p><strong>这里推荐徐飞在 QCon 上分享的 <a href="https://zhuanlan.zhihu.com/p/26426054">单页引用的数据流方案探索</a></strong></p>
<h2 id="-10-importing-components-without-relative-paths">#10 Importing components without relative paths</h2>
<p>Turn</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../../../Button/Button.jsx&#39;</span>;
<span class="hljs-keyword">import</span> Icon <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../../../Icon/Icon.jsx&#39;</span>;
<span class="hljs-keyword">import</span> Footer <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../Footer/Footer.jsx&#39;</span>;</code></pre><p>Into</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {Button, Icon, Footer} <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;Components&#39;</span>;</code></pre><p>更灵活方便使用组件。</p>
<p>使用 <code>Webpack2</code> 可以直接配置</p>
<pre class="hljs"><code><span class="hljs-regexp">//</span> exports all components wherever they are
<span class="hljs-regexp">//</span> <span class="hljs-attribute">Ref</span>: Webpack <span class="hljs-built_in">require</span>.context
<span class="hljs-regexp">//</span> <span class="hljs-attribute">https</span>:<span class="hljs-regexp">//</span>webpack.github.io/docs/context.html

<span class="hljs-regexp">//</span> ./{xxx}/yyy/index.js =&gt; import { yyy } from <span class="hljs-string">&#39;components&#39;</span>
const req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#39;.&#39;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/.\/[^/</span>]+\<span class="hljs-regexp">/[^/</span>]+\<span class="hljs-regexp">/index.js$/</span>)

req.keys().forEach(<span class="hljs-function"><span class="hljs-params">(key)</span> =&gt;</span> {
  const componentName = key.replace(<span class="hljs-regexp">/^.+\/([^/</span>]+)\<span class="hljs-regexp">/index.js/</span>, <span class="hljs-string">&#39;$1&#39;</span>)
  <span class="hljs-built_in">module</span>.exports[componentName] = req(key).default
})</code></pre><p>Creator 中因为用的 <code>create-react-app</code> CLI，无法自己配置 Webpack，所以并没有用到...</p>
<p>以上就是一些含金量很高迷你设计模式，最好是开发的时候参照这些要点，能用上就用上，熟能生巧。</p>
<p>END</p>
]]></description><link>/2017-06-28-10-react-mini-patterns-note/index.html</link><guid isPermaLink="true">/2017-06-28-10-react-mini-patterns-note/index.html</guid><category><![CDATA[tech]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[cool4ZBL]]></dc:creator><pubDate>Tue, 27 Jun 2017 16:00:00 GMT</pubDate></item><item><title><![CDATA[Fun with Codemod & AST]]></title><description><![CDATA[<h2 id="tl-dr">TL;DR</h2>
<ul>
<li>Facebook 为了解决「大型代码库」迁移，基于 AST 造了个工具 <strong>Codemod</strong></li>
<li>基于 Codemod 又构建了 JavaScript 代码迁移专用的工具 <strong>jscodeshift</strong> 和 <strong>React-codemod</strong></li>
<li>理解这些工具背后的原理有助于从一个单纯的「API 使用者」变成一个工程师般的「创造者」</li>
<li>Demo Time！Let&#39;s write a codemod</li>
<li>一些有价值的参考</li>
</ul>
<hr>
<h2 id="-">背景</h2>
<p>作为一个自信而自豪的前端弄潮儿（F2E），我们总是希望能够在这个每天都在飞速迭代的行业，与时渐进。</p>
<p>前端们是一群不安分的人，大家喜爱新框架、新语法，而 JavaScript 也是一门非常灵活的语言，它提供给我们的 API 也在与时渐进。比如，当 <code>ES2015 / ES2016 / ES2017…</code> 出来的时候，那些新语法糖，简洁漂亮，且更易于理解逻辑，于是我们都想去尝试下。</p>
<p>但是尝试归尝试，对于新项目尝试起来成本很低，只需要把新功能都用新语法编写就好。</p>
<p>而创建新项目的同时，其实我们也在维护着一些已有的旧项目。如果你还并没怎么理它们，可能它们还活得不错。但是一旦 PM 心情好想加个新功能，或者你哪天心情好想去更新下代码库，然后看到自己之前写的那些代码，那些现在其实可以更优雅漂亮的代码，是不是手里特痒痒特想把它们更新了？</p>
<p>执行力强的小伙伴可能说干就干了。嗯，就假设我们有个项目，里面使用的是用<code>ES5</code> 版 <code>React</code> 作为 <code>UI View</code>层，然后它大概四个页面<code>(Page)</code>，每个页面包含大概四个组件<code>(Component)</code>，然后你从某个看起来比较小、不容易出错的<code>Component</code> 入手，开始一行一行改写代码，嗯，<code>var React = require(&#39;react’)</code> 改为 <code>import React from &#39;react’</code>， <code>var API = ‘/j/app/xxx’</code> 改为 <code>const API = ‘/j/app/xxx’</code>，<code>var foo</code> 改为 <code>let foo</code>，<code>function () {…}</code> 改为 <code>() =&gt; {…}</code>，<code>module.exports = React.createClass({…})</code> 改为 <code>export default class MyComponent extends React.Component {…}</code> …</p>
<p>天哪，有完没完，一个组件改完下来，你已经感到身体被掏空，望了望 <code>Components</code> 列表，更不用说，重新 <code>build</code> 过的测试还没过。你陷入了绝望...</p>
<p>那么有没有更快一点的办法呢？</p>
<p>稍微有点经验的前端儿可能想到「正则表达式匹配替换」。Bash <code>Awk | Sed</code> 命令，或者 Vim <code>:%s/var/let/g</code>。可是如果需要有些变量是 <code>const</code> 类型，有些是 <code>let</code>，而有些保持 <code>var</code> 不变怎么办？再比如说以下这段很常见的代码：</p>
<pre class="hljs"><code><span class="hljs-tag">merge</span>(a, {<span class="hljs-attribute">b</span>: <span class="hljs-number">1</span>}, c);  <span class="hljs-comment">// Old</span>

<span class="hljs-comment">// 需要变为</span>

({..<span class="hljs-class">.a</span>, <span class="hljs-tag">b</span>: <span class="hljs-tag">1</span>, ..<span class="hljs-class">.c</span>});  <span class="hljs-comment">// New</span></code></pre><p>这里光是这个函数的 <code>arguments</code> 就可能有多种形式，比如 <code>variable</code>，一个匿名函数返回的 Object 或者 <code>Plain Object</code> 那种。</p>
<p>所以这里已经相当于是一个 <code>Context-non-free</code> 的问题，也就是说，<strong>上下文语义</strong>很重要。</p>
<p>这样的话，无论再怎么强大的<code>RegExp</code> 也无能为力。因为正则的本质，其实是根据一定的 <code>Pattern</code> 来匹配字符串，但是在真正的代码里，所有的字符串都有语义，都有上下文，这里的正则表达式会既复杂又无用。
所以，我们得<strong>升一个维度</strong>思考问题。</p>
<h2 id="codemod">Codemod</h2>
<p>对「代码库的批量迁移更新」，其实也是程序员的一个需求，所以，很感恩地，已经有一群懒惰又聪明的程序员造出了工具：<strong>Codemod</strong>，将「大型仓库代码的批量迁移」自动化，省时省力。</p>
<p>好吧，所以 <strong>Codemod</strong> 到底是什么呢？</p>
<p>官方文档这样写着：</p>
<blockquote>
<p>Codemod is a tool/library to assist you with large-scale codebase refactors that can be partially automated but still require human oversight and occasional intervention.</p>
</blockquote>
<p>这样看来，可以很好的解决我们的需求了。</p>
<p>基于 Codemod，又出现了针对 JavaScript 代码迁移的工具 <a href="https://github.com/facebook/jscodeshift">Facebook jscoodeshift</a>.</p>
<p>基于 <strong>jscodeshift</strong>，又构建了迁移一般 JavaScript 代码（比如 ES5 -&gt; ES2015) 的工具 <a href="https://github.com/cpojer/js-codemod">js-codemod</a> 和迁移 React 相关项目的 <a href="https://github.com/reactjs/react-codemod">react-codemod</a>。</p>
<p>嗯，这么看来，我们的事情就变得容易多了。</p>
<p>根据上面那些工具的官方文档，我们只需要按顺序执行以下命令：</p>
<pre class="hljs"><code>&gt; npm i -g jscodeshift
&gt; git clone https:<span class="hljs-comment">//github.com/reactjs/react-codemod.git</span>
&gt; git clone https:<span class="hljs-comment">//github.com/cpojer/js-codemod.git</span>
&gt; jscodeshift -t react-codemod/transforms/<span class="hljs-keyword">class</span>.js --<span class="hljs-keyword">mixin</span>-<span class="hljs-keyword">module</span>-name=react-addons-<span class="hljs-keyword">pure</span>-render-<span class="hljs-keyword">mixin</span> --flow=<span class="hljs-literal">true</span> --<span class="hljs-keyword">pure</span>-component=<span class="hljs-literal">true</span> --remove-runtime-proptypes=<span class="hljs-literal">false</span> src/register/component/myComponent.jsx
&gt; jscodeshift -t js-codemod/transforms/no-vars.js ./src/register/component/myComponent.jsx</code></pre><p>然后，再次 <code>git status</code> 一下或者直接打开刚才 transform 的 <code>myComponent.jsx</code> 文件查看，你会发现，Wow，神奇般，你的代码都成为了它们应该成为的样子！</p>
<p>这里暂时以我之前做的 Accounts 项目为例：</p>
<p><a href="https://github.intra.douban.com/accounts/accounts/pull/553/files#diff-b2286efdea6a62288250264e82bd948b">https://github.intra.douban.com/accounts/accounts/pull/553/files#diff-b2286efdea6a62288250264e82bd948b</a></p>
<p>基本步骤如下：</p>
<ol>
<li><p>因为是第一次使用 <code>codemod</code>，所以比较谨慎，一个一个 <code>component</code> 来；</p>
</li>
<li><p>先用 <code>react-codemod</code> 转，把大部头代码迁移；</p>
</li>
<li><p>然后 <code>js-codemod</code> 小步更新整理；</p>
</li>
<li><p>然后再根据一些自己的 Code Style 做些细节上的修改。比如使用 <code>standard-format</code> 工具格式化代码，符合我个人写的代码风格。</p>
</li>
<li><p>毕竟 JS 太过于灵活，每个人写代码时候风格和结构都是各异的，有时候的转换还是会出现一些与想象中不一致的结果，官方文档也是说仍然需要人工干预，所以会根据 transform 后的结果手动修改下代码细节；</p>
</li>
<li><p>一切组件迁移就绪，<code>npm run test</code> 测试通过以后，重新 <code>build</code> 运行</p>
<p>​</p>
</li>
</ol>
<p>这里我把已有的十几个组件和页面文件，全部使用上面的工具进行了更新。</p>
<p>然后当你重新 <code>build</code> 后，你会发现测试仍然通过，组件功能仍然 work，但是代码库却是使用新语法糖进行了大规模彻彻底底地更新！简直太神奇了！🤓
那么，它是怎么做到的呢？</p>
<p>这里就要好好深究下这个工具了。</p>
<h2 id="jscodeshift">jscodeshift</h2>
<p>让我们来重新读一下 jscodeshift 的<a href="https://github.com/facebook/jscodeshift#jscodeshift-">文档</a>。</p>
<blockquote>
<p>jscodeshift is a toolkit for running codemods over multiple JS files. It provides:</p>
</blockquote>
<ul>
<li>A runner, which executes the provided transform for each file passed to it. It also outputs a summary of how many files have (not) been transformed.</li>
<li>A wrapper around recast, providing a different API. Recast is an AST-to-AST transform tool and also tries to preserve the style of original code as much as possible.</li>
</ul>
<p>那么这里就出现了两个关键的概念：<em>Runner</em> 及 <em>AST</em>。</p>
<ul>
<li><strong>Runner</strong></li>
<li><blockquote>
<p>A runner/worker feature that can apply transforms to thousands of files in parallel.
-- <a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.sg03sd9eq">CPojer Effective JavaScript Codemods</a></p>
</blockquote>
</li>
<li><p><strong>AST</strong>，Abstract Syntax Tree，抽象语法分析树。</p>
</li>
</ul>
<p>为了更好理解以上概念，先来看一下之前运行 jscodeshift 命令过程。</p>
<p>我们先是把一个里面包含了 JS 代码的源文件传给了它，然后它读取了源代码，又根据写好的 <code>transform.js</code> 对源代码进行了相应的变换，最后输出了变换后的 JS 代码，覆盖了原文件。</p>
<p>这个过程简单的说，就是：
<code>SourceCode =&gt; codemod =&gt; ObjectCode</code></p>
<p>那么再详细一点，根据 jscodeshift 作者之一的 CPojer 在一次 JSConf 上对这个工具的介绍，jscodeshift 操作基本是按以下过程：</p>
<p><code>Parse =&gt; Find =&gt; Create =&gt; Update =&gt; Print</code></p>
<ol>
<li><strong>Parse</strong>: SourceCode =&gt; AST （Tree Nodes)</li>
<li><strong>Find</strong>: Find the Nodes we want to replace         // Transform</li>
<li><strong>Create</strong>: Create the New Nodes we want to insert  // Transform</li>
<li><strong>Update</strong>: Update the AST at the right location    // Transform</li>
<li><strong>Print</strong>: Print it back into JavaScript Source with proper formatting and should like human wrote this.</li>
</ol>
<h3 id="-parse-ast-">第一步，将源代码解析 (parse) 成 AST.</h3>
<p>现在我们先回到语言的本质。</p>
<p>我们知道自然语言（Natural Language)，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。</p>
<p>而在计算机编程语言 (Programming Language)，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。</p>
<p>不同的语言，都会配之不同的<strong>语法分析器</strong>（parser）。</p>
<p>对于自然语言，我们的大脑就是一个 Parser。对于编程语言，语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。</p>
<p>什么是<strong>语法树</strong>？摘自 Wiki 一段：</p>
<blockquote>
<p>计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>
</blockquote>
<p>这么说其实还是有点抽象，我们先打开 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">wiki</a> 看到 wikipedia 这个图，</p>
<p><img src="../content/images/codemod_ast/ast_tree.png" alt="AST Tree"></p>
<p>前端er 一定会觉得很相似，这里不就是 DOM 语法树的终极抽象版本吗，只是把一个个 DOM Nodes 换成了一个个更加无语义的字符 Token。</p>
<p>FB 有一个很棒的工具 <a href="http://astexplorer.net/">ASTExplorer</a>，可以用来更形象地展示。</p>
<p>比如说，我们现在就只有一个很简单的表达式<code>a+b</code>，这里是 recast Parser 解析后的 AST 结构：</p>
<p><img src="../content/images/codemod_ast/a+b_ast_tree.png" alt="a + b AST Tree"></p>
<p>看上去特别复杂。注意那些蓝色字体 <code>File</code>, <code>Programme</code>,<code>ExpressionStatement</code>,<code>Identifier</code>… 这些都是 AST Nodes，其他的都是和这个 Node 相关的数据。</p>
<p>根据前文可以知道，每种语言的 AST 都是不同的。有专门的 Parser 来生成 AST。</p>
<p>关于 <a href="https://en.wikipedia.org/wiki/Parsing#Parser">Parser</a> 又是一门很深的学问了。</p>
<p>在 ASTExplorer.net 上可以看到有很多 parser，比较著名的有 <a href="https://github.com/jquery/esprima/blob/master/src/parser.ts">Esprima(jQuery)</a>，Uglify-JS, Babylon(Babel), Acorn(Tern / Webpack), 及 jscodeshift 使用的 recast。</p>
<p>虽然有很多 Parser，但是基本上，一个 parser 的结构都差不多，对源代码进行词法分析，生成 Tokens，对 Tokens 进行语法分析，然后生成 AST。</p>
<p><img src="../content/images/codemod_ast/parser.png" alt="Parser"></p>
<p>具体可以参考看下 <a href="http://esprima.org/demo/parse.html#">Esprima Parse Demo</a>。</p>
<p>生成的 AST 都遵循一个统一标准 <a href="https://github.com/estree/estree/blob/master/es5.md">ESTree</a> or <a href="parser API https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API">Mozilla SpiderMonkey</a>，也就是说都会返回一个 ESTree Compatible AST。</p>
<h3 id="-ast-find-nodes-create-new-nodes-update-nodes-">第二三四步，对生成的 AST 进行操作修改 (Find Nodes &amp; Create New Nodes &amp; Update Nodes)</h3>
<p>Wiki 有介绍说，parse AST 的代码基本是使用<code>Visitor Pattern</code>（游客模式），如：</p>
<pre class="hljs"><code><span class="hljs-comment">// recast</span>
<span class="hljs-keyword">var</span> ast = recast.parse(src);
recast.visit(ast, {
visitIdentifier: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(path)</span> </span>{
    <span class="hljs-comment">// do something with path</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
});</code></pre><p>这其实也很容易理解，AST 就是一个树形结构，然后解析它的话就是以一个游客一样遍历这棵树。</p>
<p>但是这个模式在前端中还是用得比较少的，所以 <code>js-codeshift</code> 基于 <a href="https://github.com/facebook/jscodeshift#collections-and-traversal">Collections</a> 概念，很贴心的给这些 Parser API 继续包了一层，提供了一个不一样的前端友好型 API.</p>
<pre class="hljs"><code><span class="hljs-comment">// jscodeshift</span>
<span class="hljs-tag">jscodeshift</span>(src)
    <span class="hljs-class">.find</span>(jscodeshift.Identifier)
      <span class="hljs-class">.forEach</span>(<span class="hljs-function">function</span>(path) {
      <span class="hljs-comment">// do something with path</span>
});

<span class="hljs-comment">// Provide jQuery-likely and F2E-friendly Syntax API</span>
<span class="hljs-comment">// Manipulate AST nodes conveniently.</span></code></pre><p>读这段代码的时候，一下子觉得又似曾相识。这不就和使用 <code>jQuery</code> 操作 DOM 一样嘛。</p>
<p>可以对比下 “普通 Parser” 与 jscodeshift 操纵 AST 的区别：</p>
<p>可以看到如果使用 <a href="http://esprima.org/">esprima</a> ，AST Traverse / Walk 基本是 <code>visitor pattern</code>.
<a href="https://github.intra.douban.com/zhangbinliu/ast_demo/tree/esprima">https://github.intra.douban.com/zhangbinliu/ast_demo/tree/esprima</a></p>
<h3 id="-">第五步，输出转换后的代码</h3>
<p>据 jscodeshift 创造者之一 CPojer 说，根据转换后的 AST，以及一些输出 <a href="https://github.com/benjamn/recast/blob/52a7ec3eaaa37e78436841ed8afc948033a86252/lib/options.js#L61">Options</a>（比如是否单引号、tab 宽度是多少、需不需要去掉尾部分号…），是一个挺困难的过程。</p>
<p>但是最终，jscodeshift 的输出 API 却简洁明了，只要一行代码即可搞定。</p>
<pre class="hljs"><code><span class="hljs-class">.toSource</span>({<span class="hljs-attribute">quote</span>: <span class="hljs-string">&#39;single&#39;</span>}); <span class="hljs-comment">// sets strings to use single quotes in transformed code.</span></code></pre><p>（其实 Recast 在这做了<a href="(https://github.com/benjamn/recast/blob/master/lib/printer.js">大量的工作</a> )）</p>
<p>经过这五个步骤，一次 jscodeshift 的转换过程就算完成啦。</p>
<h2 id="demo-time-write-a-codemod-transform">DEMO TIME!  Write a codemod transform</h2>
<pre class="hljs"><code>jscodeshift -t &lt;transform.js&gt; /<span class="hljs-keyword">to</span>/<span class="hljs-type">file</span>/path</code></pre><p>我们来写<code>transform.js</code>，也就是说，你打算使用 jscodeshift 对源代码进行何种变换，这里面就是变换函数。</p>
<p>现在考虑一个 ES5 -&gt; ES6 的经典问题：</p>
<h4 id="problem-">Problem:</h4>
<p><code>
// Before
&#39;Hello, &#39; + name + &#39;, I am a string.&#39;
// After
<code>Hello, ${name}, I am a string.</code>
</code></p>
<h4 id="solution-">Solution:</h4>
<ol>
<li>Simplify， 简化问题，考虑一个最简单的情况</li>
</ol>
<p><code>
// Before
a + b
// After
<code>${a}${b}</code>
</code></p>
<p><code>a + b</code> AST:</p>
<p><img src="../content/images/codemod_ast/a+b_ast_tree.png" alt="`a + b` AST"></p>
<p><code>${a}${b}</code> AST:</p>
<p><img src="../content/images/codemod_ast/a+b_tmpl_ast.png" alt="`${a}${b}`"></p>
<p>对比两个 AST 可以发现，我们只需要</p>
<ol>
<li>读入需转换的代码，找到 <code>BinaryExpression</code></li>
<li>保存 <code>BinaryExpression</code> 左右两边的值（node.left &amp; node.right)</li>
<li>生成一个为 <code>TemlateLiteral</code> Node，<code>quasis</code> 是一个包含了三个 <code>TemplateElement</code> 的数组，<code>cookde &amp; raw keys</code> 都是 <code>&#39;&#39;</code>， <code>expressions</code> 是一个包含 node.left, node.right 值的数组。</li>
<li>然后将它返回输出；</li>
</ol>
<p>这里贴下我的 Solution Example:</p>
<ol>
<li><p><a href="http://astexplorer.net/#/gist/33b63b7dc8da6d9ea4936c631adc994d/7905ef5b30dfc0cb3c811af8a8960f11014ef402">http://astexplorer.net/#/gist/33b63b7dc8da6d9ea4936c631adc994d/7905ef5b30dfc0cb3c811af8a8960f11014ef402</a></p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformer</span>(<span class="hljs-params">file, api</span>) </span>{
<span class="hljs-keyword">const</span> j = api.jscodeshift;
<span class="hljs-keyword">const</span> root = j(file.source)

<span class="hljs-keyword">const</span> toTempLiteral = (p) =&gt; {
 <span class="hljs-keyword">const</span> quasis = [
  j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-literal">false</span>),
  j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-literal">false</span>),
  j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-literal">true</span>),
 ]

 <span class="hljs-keyword">const</span> tempLiteral = j.templateLiteral(quasis, [p.node.left, p.node.right])

 <span class="hljs-keyword">return</span> tempLiteral
}

<span class="hljs-keyword">return</span> root
 .find(j.BinaryExpression, {operator : <span class="hljs-string">&#39;+&#39;</span>})
   .replaceWith(toTempLiteral)
 .toSource()
}</code></pre></li>
<li><p><a href="http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/55c4910295973b3a4d09770d94cec73d5096daa4">http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/55c4910295973b3a4d09770d94cec73d5096daa4</a></p>
</li>
</ol>
<pre class="hljs"><code><span class="hljs-literal">export</span> <span class="hljs-keyword">default</span> function transformer(file, api) {
  <span class="hljs-keyword">const</span> j = api.jscodeshift;
  <span class="hljs-keyword">const</span> root = j(file.source)

  <span class="hljs-keyword">const</span> toTempLiteral = (p) =&gt; {
    <span class="hljs-keyword">const</span> quasis = [
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">false</span>),
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">false</span>),
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">true</span>),
    ]

    <span class="hljs-keyword">const</span> extractNodes = (node) =&gt; {
     <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">&#39;BinaryExpression&#39;</span> &amp;&amp; node.<span class="hljs-literal">operator</span> === <span class="hljs-string">&#39;+&#39;</span>) {
         <span class="hljs-keyword">return</span> [...extractNodes(node.left), ...extractNodes(node.right)]
     }
     <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> [node] }
    }

    <span class="hljs-keyword">const</span> tempLiteral = j.templateLiteral(quasis, extractNodes(p.node))

    <span class="hljs-keyword">return</span> tempLiteral
  }

  <span class="hljs-keyword">return</span> root
    .find(j.BinaryExpression, {<span class="hljs-literal">operator</span> : <span class="hljs-string">&#39;+&#39;</span>})
      .replaceWith(toTempLiteral)
    .toSource()
}</code></pre><ol>
<li><a href="http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/cf3c898c5fe494d08a978dd1a3a3e56fc42828a8">http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/cf3c898c5fe494d08a978dd1a3a3e56fc42828a8</a></li>
</ol>
<pre class="hljs"><code><span class="hljs-literal">export</span> <span class="hljs-keyword">default</span> function transformer(file, api) {
  <span class="hljs-keyword">const</span> j = api.jscodeshift;
  <span class="hljs-keyword">const</span> root = j(file.source)

  <span class="hljs-keyword">const</span> toTempLiteral = (p) =&gt; {
    <span class="hljs-keyword">const</span> quasis = [
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">false</span>),
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">false</span>),
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">true</span>),
    ]

    <span class="hljs-keyword">const</span> extractNodes = (node) =&gt; {
     <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">&#39;BinaryExpression&#39;</span> &amp;&amp; node.<span class="hljs-literal">operator</span> === <span class="hljs-string">&#39;+&#39;</span>) {
         <span class="hljs-keyword">return</span> [...extractNodes(node.left), ...extractNodes(node.right)]
     }
     <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> [node] }
    }

    <span class="hljs-keyword">const</span> tempLiteral = j.templateLiteral(quasis, extractNodes(p.node))

    <span class="hljs-keyword">return</span> tempLiteral
  }

  <span class="hljs-keyword">return</span> root
    .find(j.BinaryExpression, {<span class="hljs-literal">operator</span> : <span class="hljs-string">&#39;+&#39;</span>})
      .replaceWith(toTempLiteral)
    .toSource()
}</code></pre><p>官方没有太详细的 transform 编写指导，可以多谷歌或者学习已编写好的 transform：<code>react-codemod/tranform</code> 或者 <code>js-codemod/transform</code>。</p>
<p>我个人觉得写 JS-Codeshift Transform | Babel-Plugin 本质其实就是对比两棵语法树，像解谜一样，看看如何「又好又快」变换成这样。</p>
<p>剩下的一开始如何读取源 JS 代码并解析成语法树，具体在 AST 上 traverse &amp; find &amp; create &amp; update （这里我猜测其实是一个递归遍历节点树的过程？），及之后如何按一定的 code style 生成我们需要的代码，都是透明且不关心的。</p>
<h2 id="-">总结 &amp; 开脑洞</h2>
<ul>
<li><p>总结下基本处理流程：
<img src="../content/images/codemod_ast/process.png" alt="Process"></p>
</li>
<li><p>AST 是很有用的一个抽象概念。一旦你理解了这些规则，唯一的限制就是解析器和你的想象力。</p>
</li>
<li>纯 AST parse 太过于理论，既然是工程师，还是需要自己动手写点什么来解决自己实际遇到的问题。</li>
<li>可以继续拓展到「语法高亮」、「关键字匹配」、「代码格式化」、「作用域判断」、以及「代码压缩」、「Babel 插件」等等。</li>
<li>渐渐深入底层进行分析，让自己对这门语言有了更多、更深入的了解，可以更好地成为产品「创造者」，而不单纯是「使用者」。</li>
<li><strong>Write JavaScript that writes JavaScript! The best editor is JavaScript. Cool!</strong></li>
</ul>
<h2 id="-">思考</h2>
<ul>
<li>可以在一个 codemod transform 里面同时进行两个变换吗？个人觉得可能会很复杂且效果不太好，因为有些 transform 并不是正交的。🤔</li>
</ul>
<h2 id="refs-">Refs:</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=d0pOgY8__JM">CPojer’s Talk</a></li>
<li><a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.s5kdne4xl">Effective JavaScript Codemods</a></li>
<li><a href="https://survivejs.com/blog/codemod-interview/">Codemod Interview</a></li>
<li><a href="https://vramana.github.io/blog/2015/12/21/codemod-tutorial/">How to write a codemod</a> 结合 CPojer’s Talk, 这个虽很长但很有用！</li>
<li><a href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/">Understanding Babel Plugin</a></li>
<li><a href="http://tech.meituan.com/abstract-syntax-tree.html">AST 在美团的应用</a></li>
<li><a href="http://imweb.io/topic/57b13b4f93d9938132cc8dfd">imweb</a></li>
</ul>
]]></description><link>/2017-02-15-fun-with-codemod-and-ast/index.html</link><guid isPermaLink="true">/2017-02-15-fun-with-codemod-and-ast/index.html</guid><category><![CDATA[tech]]></category><category><![CDATA[programming]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[cool4ZBL]]></dc:creator><pubDate>Tue, 14 Feb 2017 17:21:00 GMT</pubDate></item><item><title><![CDATA[移动环境下的 SEO]]></title><description><![CDATA[<p>真的有很久很久没来理这个博客，距离上一篇文章的发布日期是两年前。
毕业工作后来了豆瓣，最近对移动环境（主要是浏览器及微信）的 SEO 相关进行了下研究，正好在这里分享一下。</p>
<p>以下，Enjoy。</p>
<hr>
<h3 id="1-seo-search-engine-optimazition">1. SEO：Search Engine Optimazition</h3>
<p>产品：搜索引擎优化，促进内容网站信息分享／传播，提高目标转化率，留存率</p>
<p>工程：为各类页面实现统一的信息分享、传播，提高搜索排名（search ranking）</p>
<p>个人觉得：</p>
<ul>
<li>豆瓣是一个内容网站，拥有一些 UGC 优质内容，SEO 间接帮助用户分享。
且分享率越高，也会提高搜索排名。</li>
<li>M 站的目前面向<strong> 人（User） </strong>的 UX 比较完善，但是仍需要丰富一些细节，让 <strong>Search Engine</strong> 的 UX 更好，更好地理解 M 站。</li>
</ul>
<h3 id="2-seo-">2. 前端在 SEO 中的位置</h3>
<ul>
<li><strong>帮助产品进行TDK （Title / Description / Keyword）优化</strong></li>
<li><strong>添加一些 Social Meta Tag （Facebook / Twitter / G+ / WeChat / Weibo）</strong></li>
<li>页面内容优化（HTML5 标签语义化、唯一的 H1 标题、img 设置 <code>alt</code> 属性，不需要爬虫跟踪的链接加 <code>nofollow</code>）</li>
<li>URL 优化 (<strong>canonical</strong>，标签表示页面的唯一性)<ul>
<li>在搜索引擎里，<strong>只有链接完全一样，才会认为是同一个链接</strong>，如果链接带上参数，虽然访问到的内容还是一样，但是在搜索引擎看来确是不同的链接，页面抓取也会出现多次，从而导致多个链接，内容一样。</li>
<li>因此 URL 中最好是不要带上查询参数。但为了产品统计数据，总需要 <code>?from=xxx&amp;refer=xxx</code>等参数，所以使用 <code>canonical</code>标签来确保链接唯一性，避免权重分散、流失。</li>
<li>比如 <code>m.douban.com/group/topics[?start=xxx]</code>均视为同一个页面这里的 <code>?start=xxx</code>是一个分页查询参数，所以为了确保这些页面都能继承 m.douban.group/toics 这个 url  的权重，在<code>head</code>中增加了<code>canonical</code>标签</li>
</ul>
</li>
<li>Meta robots</li>
<li>Sitemap</li>
</ul>
<h3 id="3-">3. 具体实现</h3>
<blockquote>
<p><strong>统一 SNS 抓取</strong></p>
<p>提供一个 mako 函数，统一分享的标题、图片、描述</p>
<ul>
<li>Open Graph</li>
<li>Twitter Card</li>
</ul>
<p><strong>实现统一的分享接口</strong></p>
<p>可变的图片、标题、描述</p>
<ul>
<li><p>微信 （iOS、Android 系统分享菜单、微信内置分享）</p>
</li>
<li><ul>
<li>外部调用分享可能会抓取标题、第一个图片地址（Open Graph）</li>
<li>调用内置分享可用第三个链接 (API 跨子域)</li>
</ul>
</li>
<li><p>微博</p>
</li>
</ul>
<p>参考链接：</p>
<p><a href="https://developers.facebook.com/docs/sharing/opengraph">https://developers.facebook.com/docs/sharing/opengraph</a></p>
<p><a href="https://dev.twitter.com/cards/overview">https://dev.twitter.com/cards/overview</a></p>
<p><a href="http://github.intra.douban.com/frodo/Talion/blob/master/views/j/wechat/__init__.py">http://github.intra.douban.com/frodo/Talion/blob/master/views/j/wechat/<strong>init</strong>.py</a> </p>
<p>— From <a href="https://paper.dropbox.com/doc/-SEO-UVIgU3WYPUeiJv3nOPP0N">Douban FE Dropbox</a></p>
</blockquote>
<h3 id="-">实现方案</h3>
<h4 id="1-seo_meta-mako-widget">1. 增加了 <code>seo_meta()</code> Mako widget</h4>
<p> <a href="http://github.intra.douban.com/frodo/Talion/blob/master/templates/card/widgets.html#L527">http://github.intra.douban.com/frodo/Talion/blob/master/templates/card/widgets.html#L527</a></p>
<pre class="hljs"><code><span class="xml"></span>&lt;%<span class="perl">def name=<span class="hljs-string">&quot;seo_meta(title, desc, image=None, url=None, type=None, rating_count=None, rating_val=None, wechat_timeline_title=None,wechat_chat_title=None, wechat_desc=None, wechat_image=None)&quot;</span>&gt;
    &lt;%
        from douban.image.qiniu import qiniu_proxy_url

        default_title = <span class="hljs-string">&#39;豆瓣&#39;</span>
        default_desc = <span class="hljs-string">&#39;读书、看电影、涨知识、学穿搭...，加入兴趣小组，获得达人们的高质量生活经验，找到有相同爱好的小伙伴。&#39;</span>
        default_image = static(<span class="hljs-string">&#39;/pics/icon/m_logo_180.png&#39;</span>)
        default_url = <span class="hljs-string">&#39;<a href="http://m.douban.com/">http://m.douban.com/</a>&#39;</span>
        default_type = <span class="hljs-string">&#39;article&#39;</span>
        image = qiniu_proxy_url(image, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>, mode=<span class="hljs-string">&#39;1&#39;</span>) <span class="hljs-keyword">if</span> image <span class="hljs-keyword">else</span> <span class="hljs-string">&#39;&#39;</span>
    </span>%&gt;<span class="xml">
    <span class="hljs-comment">&lt;!-- Schema.org markup for Google+ --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;name&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ title or default_title }&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ desc or default_desc }&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span>&gt;</span>
</span><span class="perl">    % <span class="hljs-keyword">if</span> rating_count:</span><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;reviewCount&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ rating_count }&quot;</span>&gt;</span>
</span><span class="perl">    % endif</span><span class="xml">
</span><span class="perl">    % <span class="hljs-keyword">if</span> rating_val:</span><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;ratingValue&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ rating_val }&quot;</span>&gt;</span>
</span><span class="perl">    % endif</span><span class="xml">
    <span class="hljs-comment">&lt;!-- Twitter meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;twitter:card&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;summary&quot;</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- Open Graph meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ title or default_title }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ desc or default_desc }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:site_name&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;豆瓣(手机版)&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:url&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ url or default_url }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:type&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;image/png&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:width&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;300&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:height&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;300&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:type&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ type or default_type }&quot;</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- Wechat meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:timeline_title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_timeline_title or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:chat_title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_chat_title or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_desc or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span> /&gt;</span>
    </span>&lt;%<span class="perl">block filter=<span class="hljs-string">&quot;collect_js&quot;</span>&gt;
    ;(function () {
        window.setMeta = function (name, val) {
          var meta = document.querySelectorAll(<span class="hljs-string">&#39;meta[property=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;], meta[name=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;]&#39;</span>)
          <span class="hljs-keyword">if</span> (!meta.<span class="hljs-keyword">length</span>) {
            meta = document.createElement(<span class="hljs-string">&#39;meta&#39;</span>)
            meta.name = name
            document.head.appendChild(meta)
          }
         meta[<span class="hljs-number">0</span>].content = val || <span class="hljs-string">&#39;&#39;</span>
        }
        window.getMeta = function (name) {
          var meta = document.querySelectorAll(<span class="hljs-string">&#39;meta[property=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;], meta[name=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;]&#39;</span>)
          <span class="hljs-keyword">if</span> (!meta.<span class="hljs-keyword">length</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;&#39;</span>
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> meta[<span class="hljs-number">0</span>].content
          }
        }
        setMeta(<span class="hljs-string">&#39;og:url&#39;</span>, location.href)
        !getMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>, document.title)
        !getMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>, document.title)
        !getMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>, getMeta(<span class="hljs-string">&#39;og:description&#39;</span>))
    })();
    &lt;<span class="hljs-regexp">/%block&gt;
&lt;/</span><span class="hljs-variable">%def</span>&gt;</span></code></pre><h4 id="2-m-seo-meta-tags">2. 给 m 站大部分页面增加了 SEO Meta Tags</h4>
<p>之前分享出去抓不到自定义的 description 和 image ，现默认分享到 weixin 的 title 、 description 、image 值都和 Open Graph 一样，也可以自定义。</p>
<p>默认情况下</p>
<ul>
<li><code>og:title</code>， <code>og:description</code> 和之前的 title, description 一样；</li>
</ul>
<ul>
<li><code>og:url</code> ： 当前页面 url；</li>
<li><code>og:image</code>：<ul>
<li>小组帖子页和单个日记页如有图片，则为第一张图片的 src url，没有的话为现在默认的分享 icon src url；</li>
<li>条目页的均为该条目的 image src url；</li>
<li>相册页为该相册第一张 image src；</li>
<li>豆列、标签页为默认的分享 icon src</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Hashtag 页</strong></p>
<ul>
<li>image: 运营头图 || 豆 icon；</li>
<li>title: { hashtag_name} - 豆瓣；</li>
<li>description: 运营描述 || &#39;有关#{ hashtag_name }#的话题讨论，豆瓣用户参与的精彩话题&#39;；</li>
</ul>
</li>
<li><p><strong>单条广播页</strong></p>
<ul>
<li>微信聊天、朋友圈：image =  广播第一张图 || 豆 icon；</li>
<li>微信聊天页： title = XXX 的豆瓣广播; description = 广播文字内容的前十五个字 || 默认的 m 站描述；</li>
<li>微信朋友圈： title = 广播文字内容前十五个字 || XXX 的豆瓣广播</li>
</ul>
</li>
<li><p>关于 image 图片规格：</p>
<p>为了使抓取的图片更优雅，不被压缩变形，使用「七牛图片服务」进行剪裁。</p>
<p>默认 <code>og:image</code> 等 image 均会被以 <code>width = height = 300</code> 进行处理。</p>
<ul>
<li><a href="http://github.intra.douban.com/frodo/Talion/tree/23fe149cc3186f15195634cca774861d3ce9efca">Talion</a>/<a href="http://github.intra.douban.com/frodo/Talion/tree/23fe149cc3186f15195634cca774861d3ce9efca/libs">libs</a>/<strong>image.py</strong></li>
<li><a href="http://github.intra.douban.com/frodo/Talion/blob/23fe149cc3186f15195634cca774861d3ce9efca/libs/image.py#L11">http://github.intra.douban.com/frodo/Talion/blob/23fe149cc3186f15195634cca774861d3ce9efca/libs/image.py#L11</a></li>
<li><code>from douban.image.qiniu import qiniu_proxy_url</code></li>
</ul>
<p>​</p>
</li>
</ul>
<p>效果截屏：</p>
<p><a href="http://github.intra.douban.com/frodo/Talion/pull/253">http://github.intra.douban.com/frodo/Talion/pull/253</a></p>
<h4 id="3-">3. 统一分享接口（微信重度使用患者）</h4>
<ul>
<li><a href="http://github.intra.douban.com/frodo/Talion/blob/master/static/js/card/weixin.js#L52">weixin.js</a>、 <a href="https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html#.E5.88.86.E4.BA.AB.E6.8E.A5.E5.8F.A3">微信 JSSDK 文档</a></li>
</ul>
<pre class="hljs"><code>
wx.onMenuShareTimeline($.extend({}, shareData,{
    title: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>) || <span class="hljs-built_in">document</span>.title,
    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        wxShareStat.target = <span class="hljs-string">&#39;timeline&#39;</span>;
        $.get(<span class="hljs-string">&#39;/j/wechat/shared&#39;</span>, wxShareStat);
    },
    cancel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
}));

wx.onMenuShareAppMessage($.extend({}, shareData,{
    title: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>) || <span class="hljs-built_in">document</span>.title,
    desc: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>) || <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;og:description&#39;</span>),
    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        wxShareStat.target = <span class="hljs-string">&#39;friend&#39;</span>;
        $.get(<span class="hljs-string">&#39;/j/wechat/shared&#39;</span>, wxShareStat);
    },
    cancel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
}));</code></pre><p>  结合使用 <code>meta[name=&quot;weixin:image&quot;]</code></p>
<pre class="hljs"><code>&lt;meta property=<span class="hljs-string">&quot;weixin:timeline_title&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_timeline_title <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
&lt;meta property=<span class="hljs-string">&quot;weixin:chat_title&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_chat_title <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
&lt;meta property=<span class="hljs-string">&quot;weixin:description&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_desc <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
&lt;meta property=<span class="hljs-string">&quot;weixin:image&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ image <span class="hljs-keyword">or</span> default_image }</span>&quot;</span> /&gt;</code></pre><ul>
<li><p>自定义微信分享到聊天、朋友圈的显示内容，文案<code>setMeta()</code>, <code>getMeta()</code></p>
</li>
<li><p><strong>Tips:</strong> 如果没有设置 <code>wx.onMenuShareTimeline()</code>/ <code>wx.onMenuShareAppMessage()</code> 中的 title / imgUrl / desc 参数，微信内置浏览器默认抓取对应的<code>og:xxx</code> 相关。</p>
</li>
<li><p><strong>Bugs:</strong> 通过 Safari Extension 分享出来的永远抓的是 <code>apple-touch-icon</code> 😂</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;<a href="https://img3.doubanio.com/f/talion/315ba4fc82e5cdb5c50ef1d9f88c8aa2c5c0c4ba/pics/icon/m_logo_76.png">https://img3.doubanio.com/f/talion/315ba4fc82e5cdb5c50ef1d9f88c8aa2c5c0c4ba/pics/icon/m_logo_76.png</a>&quot;</span>&gt;</span></code></pre><p>微信分享效果图：
<img src="&#39;/content/images/seo_in_mobile/seo_1.png&#39;" alt="after_seo_1">
<img src="&#39;/content/images/seo_in_mobile/seo_2.png&#39;" alt="after_seo_2">
<img src="&#39;/content/images/seo_in_mobile/seo_3.png&#39;" alt="after_seo_3"></p>
<h3 id="further-reading-resource">Further Reading &amp; Resource</h3>
<ol>
<li>Sitemap &amp; <a href="http://baiduseoguide.com/news/20141128113.html">Deadlink</a></li>
<li>Social Meta Tag Cheatsheet</li>
<li>Google SEO TOP1: Baidu Baike 😂</li>
<li><a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/MetaTags.html">Apple Safari supported meta tags</a></li>
<li><a href="http://static.googleusercontent.com/media/www.google.com/en//webmasters/docs/search-engine-optimization-starter-guide.pdf">Google SEO search-engine-optimization-starter-guide</a></li>
<li>Google 结构化数据标记辅助工具</li>
<li><a href="http://www.hobo-web.co.uk/seo-tutorial/">SEO Tutorial</a></li>
<li><a href="http://www.ghugo.com/jd-seo/">京东 SEO</a></li>
<li>SEO Tools<ul>
<li><a href="https://www.google.com/webmasters/">Google Webmasters Search Console</a></li>
<li><a href="https://varvy.com/tools/">Varvy SEO tool</a></li>
<li><a href="http://keywordtool.io/">Keyword Tool</a></li>
</ul>
</li>
</ol>
]]></description><link>/2016-05-20-seo-in-mobile/index.html</link><guid isPermaLink="true">/2016-05-20-seo-in-mobile/index.html</guid><category><![CDATA[SEO]]></category><category><![CDATA[shares]]></category><category><![CDATA[tech]]></category><dc:creator><![CDATA[cool4ZBL]]></dc:creator><pubDate>Thu, 19 May 2016 18:21:00 GMT</pubDate></item><item><title><![CDATA[Ali校招笔试题思考]]></title><description><![CDATA[<h1 id="ali-">Ali校招笔试题思考</h1>
<p>昨晚搭着末班车，参加了阿里今年的实习生在线笔试。
回忆之前惨不忍睹的内推面试，玩了整整一个寒假后接到了不期而至的面试电话，连之前一些基础的还算熟悉的题都答得不流畅自然一气呵成，我就知道我悲剧了。
痛定思痛，作为一个即将毕业的大四老鸟（只是说年龄...)，在被各种鄙视，各种蜚语，各种不确定存在的黑暗时期，依旧不屈不挠地学习思考着，我都要被自己感动了。
笔试题只有一个小时，13道题，一开始是单项选择和不定项选择，考了AMD编码规范、闭包、setTimeout的异步、前端安全及一些我认为蛮有意思的小题，挺考基础的，不是太难，但要细心，我居然也慢悠悠做，时间就那么过去了一半。后来看到了六大道问答题，基本是编程，涉及CSS3、原生JS、事件处理、Ajax等，就渐渐慌了，写代码的手居然有了渐冻症的感觉，心理素质有待提高。
于是在有差不多一半大题没完成的情况下，被迫交了卷。交卷后才灵感突现，猛然想起了那些题的解法，还是代码经验不够啊。为了防止再出现这样的情况，在这里贴下题目思路和解答。</p>
<hr>
<p>关于CSS，有题是用<code>HTML&amp;CSS</code>实现一个九宫格，外边框为1px，内部无边框。之前没有做过九宫格布局，当时又很捉急居然被卡住了。交完卷后突然在想，这不就是考<code>float</code>的嘛。
遂编码如下：</p>
<pre class="hljs"><code><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>九宫格<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
      <span class="hljs-tag">ul</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">list-style</span>:<span class="hljs-value"> none</span></span>;
          <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">158px</span></span></span>;
          <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">158px</span></span></span>;
      }</span>
      <span class="hljs-tag">li</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">50px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">50px</span></span></span>;
          <span class="hljs-comment">/<em>box-sizing: border-box;</em>/</span>
          <span class="hljs-rule"><span class="hljs-attribute">background-color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#888</span></span></span>;
          <span class="hljs-rule"><span class="hljs-attribute">float</span>:<span class="hljs-value"> left</span></span>;
      }</span>
      <span class="hljs-class">.one</span>,<span class="hljs-class">.four</span>, <span class="hljs-class">.seven</span><span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">border-left</span>:<span class="hljs-value"> <span class="hljs-number">3px</span> solid red</span></span>;
          <span class="hljs-comment">/<em>z-index: 2;</em>/</span>
      }</span>
      <span class="hljs-class">.one</span>, <span class="hljs-class">.two</span>, <span class="hljs-class">.three</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">border-top</span>:<span class="hljs-value"> <span class="hljs-number">3px</span> solid red</span></span>;
      }</span>
      <span class="hljs-class">.three</span>, <span class="hljs-class">.six</span>, <span class="hljs-class">.nine</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">border-right</span>:<span class="hljs-value"> <span class="hljs-number">3px</span> solid red</span></span>;
      }</span>
      <span class="hljs-class">.seven</span>, <span class="hljs-class">.eight</span>, <span class="hljs-class">.nine</span> <span class="hljs-rules">{
          <span class="hljs-rule"><span class="hljs-attribute">border-bottom</span>:<span class="hljs-value"> <span class="hljs-number">3px</span> solid red</span></span>;
      }</span>

    </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>
    HTML CSS 九宫格 外边框1px 内部无边框
    <span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;list&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;two&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;three&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;four&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;five&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;six&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;seven&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;eight&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;nine&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre><p>其实就是每个盒子固定宽高，父元素也固定宽高，分别为盒子宽高的3倍+左右（或上下）两边的边框宽度，然后都浮动起来。内部无边框外部有边框也容易实现，只要把最外圈的盒子按顺序设定 <code>border-top</code>、<code>border-bottom</code>、<code>border-left</code>、<code>border-right</code>即可。
思考：</p>
<ul>
<li>一开始把父元素刚好设为盒子宽高的3倍，盒子设定为<code>box-sizing: border-box</code>后，发现边框自动隐藏了，所以要体现有边框还是不能这样；</li>
<li>该题不难，其实还可以拓展成N宫格，<code>父元素的宽高 = N*盒子宽高 + 2*border-width</code>，相当于做个图片墙。</li>
</ul>
<p>JS跨浏览器事件处理：给你个超链接按钮，用户点击后不进行链接跳转，而是提示“用户名不能为空”，要尽可能兼容更多的浏览器。
这题考的也就是跨浏览器的事件处理啦，之前看过《JavaScript高级程序设计》时候，专门有一小节讲跨浏览器事件处理，给出了完整的解决方案，自己也用心写了<code>Code Snippet</code>笔记，但是实践少，考试时做的不太顺利，这里重新整理下贴下代码。
（Ghost Gist 托管，若无显示请戳 <a href="https://gist.github.com/githubzbl/8170f1e96e7bf3c66ca5">跨浏览器事件处理Gist</a>）</p>
<script src="https://gist.github.com/githubzbl/8170f1e96e7bf3c66ca5.js"></script>

<p>思考：</p>
<ul>
<li>事件处理很简单，关键就在兼容浏览器，这里就得照顾到IE；</li>
<li>当时考试时居然把<code>&lt;script&gt;</code>标签及其里面的代码写到了<code>&lt;head&gt;</code>里面，导致<code>document.getElementById(&#39;btn&#39;)</code>返回的一直是<code>undefined</code>，现在想想给自己跪了，<code>DOM</code>都没准备好哪来的<code>getElementById()</code>。</li>
</ul>
<p>JS统计字符串中出现次数最多的字符并打印统计信息。
这题当时看的时候居然看成<em>找出现最多的字符串</em>，心想天哪噜大阿里真厉害前端还考字符子串问题，这算法……，时间紧迫，遂想都没想直接跳过了。交卷后仔细回想才发现是<em>找字符</em>啊！再给自己跪下*2。
在老道那本《Good Parts》里有个gist是去计算一段文本中每个单词的出现次数，因为每个单词是用空格符隔开，所以思路也可以迁移到单个字符。思考后编码如下：
（Ghost Gist 托管，若无显示请戳 <a href="https://gist.github.com/githubzbl/a0ab1b7dd4f0128e9d6d">字符计数</a>）</p>
<p><script src="https://gist.github.com/githubzbl/a0ab1b7dd4f0128e9d6d.js"></script>
思考：</p>
<ul>
<li>将字符串分成单个字符很简单，甚至不用<code>RegExp</code>；</li>
<li>分成单个字符后存入一个对象，巧妙的是对象的属性即为该字符，属性值为该字符在字符串中出现的次数；</li>
<li>最后简单的用<code>for in</code>遍历属性排序，当然老道说<code>for in</code>不好，不知道这个地方需不需要改善。</li>
</ul>
<p>JS 给定一个http接口，传入一个员工id，返回员工的详细信息，接口形式为：<code>http://localhost/query?id=</code>，要求在前端实现一个根据一批员工id，通过ajax查询员工信息的功能。
Ajax show time, finally.
之前只写过几个Ajax，并不是太熟练，所以这题拿不准。
既然给了URL，一般就是要考<code>RegExp</code>啦，但是这个只要根据<code>id</code>查询就好，是不是只用<code>url.split(&#39;=&#39;)</code>，然后就知道ID了呢？
HTTP接口应该也就是写个函数模块吧。暂时给思路如下，待完善。</p>
<pre class="hljs"><code> $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>{
   <span class="hljs-keyword">var</span> id = url.split(<span class="hljs-string">&#39;=&#39;</span>)[<span class="hljs-number">1</span>];
   $(<span class="hljs-string">&#39;.btn&#39;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
        $.ajax({
            url: <span class="hljs-string">&#39;<a href="http://localhost/query?id=">http://localhost/query?id=</a>&#39;</span>,
            type: <span class="hljs-string">&#39;GET&#39;</span>,
            dataType: <span class="hljs-string">&#39;html&#39;</span>,
            data: {param1: id},
        })
        .done(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;success&quot;</span>);
        })
        .fail(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;error&quot;</span>);
        })
        .always(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;complete&quot;</span>);
        });
    });
  });</code></pre><hr>
<p>差不多就这些了，想到新思路再来更新吧。前端坑是很多，但也很有趣，感觉自己终于入门了呢。
还是那句，希望自己在成为大牛的道路上越走越远。</p>
<hr>
<p>续：觉得做的一般也收到了面试通知。但阿里又说“针对2015届招聘已结束，无论面试结果如何我们都不能承诺您能加入”。伤心归伤心，毕竟迟了那么点。
但再怎么着也要执着走下去。
<strong>“It&#39;s never too late to start.”</strong></p>
]]></description><link>/2014-12-01-alibaba-interview/index.html</link><guid isPermaLink="true">/2014-12-01-alibaba-interview/index.html</guid><category><![CDATA[interview]]></category><category><![CDATA[tech]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[cool4ZBL]]></dc:creator><pubDate>Mon, 01 Dec 2014 12:13:00 GMT</pubDate></item><item><title><![CDATA[写在百度电面后]]></title><description><![CDATA[<h1 id="-">写在百度电面后</h1>
<p>Desperado.</p>
<figure>
<img src="http://zbl-ghost-backup.qiniudn.com/blogcover_roadtothesky_2880x900.jpg" alt="road to the sky">
<figcaption>Road to the sky.</figcaption>
</figure>


<p>睡得昏昏沉沉的早上，突然接到了电话，在从惊呆到真呆中，就这么面完了百度。</p>
<hr>
<p>“先作下自我介绍吧！”
自我介绍？天，简历里面不是写了吗？噢，我写了什么？
“呃，我叫XXX，是电子科大电子信息工程的大四学生...呃，我喜欢互联网及互联网开发…最近一直在自学…嗯。”
“完了吗？”
“说完了。” 当时我就在想，完了。脑袋空白。</p>
<p>“电子信息工程的是吗？那你先解释下傅里叶变换吧。”
简直惊呆，我这是面的前端吗？第一个问题就这么脑子转不过来了，都好久没有看专业书。
“嗯，有个复杂信号…呃经过傅里叶变换...分解...单频率信号...嗯...”
七零八落我也不知道我说了什么。</p>
<p>“CSS的优先级知道吗？解释一下。”
“呃，是特指度？先是ID，然后是class，然后是标签名....”
“确定最后是标签名吗？”
“呃嗯...确定。”
虽然最后是对了，但是答得很是不自然。</p>
<p>“嗯，如果这有一个数组，我想删除数组中的重复元素应该怎么做？”
啊，WTF，居然问了算法。曾经想过这个思路的，但是已经好久没有写过C，而且这还是用JS实现。可是我JS的书都还没有看完。
“呃，数组嘛，那就从第一个开始依次遍历咯…有重复的话就标记。”
“每个都遍历一遍？如何标记？时间复杂度如何？”
哎，为了看前端的东西，算法好久没有碰过，我要说什么……
(<strong>更新</strong>：
面试的时候对JS不是很熟悉，还是按着原来写C的思路来处理数组，加上心里有点紧张，思路一时打不开。最近几天又继续啃了《JavaScript高级程序设计》，发现 JavaScript 在数组方面处理真心很强大，贴去除数组中重复元素的函数如下：</p>
<pre class="hljs"><code>function uniqueArray (<span class="hljs-type">array</span>) {
    <span class="hljs-keyword">var</span> <span class="hljs-literal">result</span> = [];
    <span class="hljs-type">array</span>.sort(compare);  // 此处不知道如果数组中元素很多的话，先给数组排序效率会不会高点？
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> <span class="hljs-type">array</span> ) {
        <span class="hljs-keyword">if</span> ( <span class="hljs-literal">result</span>.indexOf(<span class="hljs-type">array</span>[i]) == -<span class="hljs-number">1</span>) {
            <span class="hljs-literal">result</span>.push(<span class="hljs-type">array</span>[i]);
        };
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">result</span>;
}
function compare (value1, value2) {
     <span class="hljs-keyword">return</span> value2 - value1;
}</code></pre><p>)</p>
<p>“学过排序吗？介绍下二分法？快速排序？冒泡排序？”
“只学过冒泡…冒泡就是这样的……”</p>
<p>(<strong>更新</strong>：一个非常好玩的各种排序算法的<a href="http://jsdo.it/norahiko/oxIy/fullscreen">动画演示</a>，当初学算法的时候要是有这么直观的动画就好了。
快排的思想如下：</p>
<blockquote>
<p>（1）在数据集之中，选择一个元素作为&quot;基准&quot;（pivot）。
（2）所有小于&quot;基准&quot;的元素，都移到&quot;基准&quot;的左边；所有大于&quot;基准&quot;的元素，都移到&quot;基准&quot;的右边。
（3）对&quot;基准&quot;左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
```language-javascript
var quickSort = function(arr) {
　　if (arr.length &lt;= 1) { return arr; }
　　var pivotIndex = Math.floor(arr.length / 2);
　　var pivot = arr.splice(pivotIndex, 1)[0]; //取得基准元素的值
　　var left = [];
　　var right = [];
　　for (var i = 0; i &lt; arr.length; i++){
　　　　if (arr[i] &lt; pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}
　　return quickSort(left).concat([pivot], quickSort(right));   //递归调用
};</p>
</blockquote>
<p>```
快速排序最差的情况时间复杂度是O(n^2)。</p>
<p>“我看你笔试试卷上JS异步编程那题写了点代码，那么解释下Ajax?&quot;
噢，真是哪壶不开提哪壶。真是惭愧，笔试试卷上的代码是我考试时候翻手机里那本《JavaScript权威指南》，在里面随便抄了一点。我写了什么？我也不知道。
昨晚才真正在图书馆接触到了Ajax，书还没来得及认真看。只能凭靠记忆力一点点说。
“Ajax嘛，异步JS和XML…可以在不重新加载整个页面情况下更新页面的某个部分……”
“那么如何用JS实现Ajax？”
噢。昨天看书才看到这点，还没有实现过。
“呃…新命名一个变量（其实是对象）XMLhttprequest……然后接收服务器返回的数据……”
靠，我到底在说什么。
“不好意思，我不会写。”</p>
<p>“好吧，咱们的面试到此结束。你有什么问题吗？”
嗯，我知道我这样肯定没戏了，索性就随便说点吧。
“不好意思，笔试完后我没想过我能进面试，就没有做面试准备，所以这次表现得很糟糕。我是不是基础很不扎实？跨行是不是不容易？”
后来知道，那位面试官也是通信工程转过去的，而且他还开玩笑的说是因为考研没考上。</p>
<hr>
<blockquote>
<p>Desperado, ah, you ain&#39;t gettin&#39; no younger.
亡命之徒啊，你已经不年轻了
Your pain and your hunger, they&#39;re drivin&#39; you home.
你的痛苦和饥饿，它们在把你赶回原点
Freedom, oh, freedom. That&#39;s just some people talkin&#39;
自由，噢自由。那只是有些人说的
You&#39;re a prisioner walking through this world all alone.
你是孤独闯世界的囚犯</p>
</blockquote>
<p>面完百度后，一直循环在听“亡命之徒”，而心情沮丧得就和上次考完雅思口语一样。
是的，因为我压根没想到我能进面试。
是的，我一定是太不自信。
这个面试官也一定和上次口语考官一样想吧，这个人啥都没准备啥都不会还敢来面试（考试）？</p>
<p>跟妈妈打了电话，想想还是不用太沮丧，虽然是百度，但这是你的第一次面试，所以经验缺乏，应答不自然是正常的。
内功不深厚，肚子里没货，怎么倒腾也是倒不出东西的吧。</p>
<p>对于面试：</p>
<ol>
<li>一定一定要准备好一个<strong>精彩的自我介绍</strong>。</li>
<li>一定一定得<strong>有自信</strong>，不要认为自学非科班项目经验少就会低人一等，要对自己的能力有信心（自己接电话时就是太不自信了，心里貌似就是有一个暗示，觉得BAT那么高大上的公司怎么进得去），不要过分仰视那些大公司，否则自己永远也进不去。</li>
<li>试着写个好简历，然后多投递下简历，增加宝贵笔试、面试经验，以后面试时能更加从容面对。</li>
</ol>
<p>对于能力提升：</p>
<ol>
<li>夯实<code>HTML&amp;CSS</code>的基础知识。
多写读书笔记，多总结经验，这样才能在真正需要它们的时候运用自如。</li>
<li>必须立刻继续<code>JavaScript</code>的学习。
之前断断续续看过一点JS的知识，但是最近倒腾网站就转移了很多注意力到服务器端，导致什么都不精，自己也找不到了方向。一本「JavaScript高级程序设计」啃来啃去。</li>
<li>开始<code>Ajax</code>、<code>jQuery</code>的认真学习。
你看看，连写个异步编程都不会。接下来还有Node.js呢。</li>
<li><strong>不要好高骛远，不要赶潮流耍花招。</strong>
之前真是过于浮躁，看了很多新技术的书，但连最基础的东西都没学好。</li>
</ol>
<p><blockquote>
    让你自己成为一个持续学习和思考的人，并只写你真正思考和总结之后的产物，其他一切就会随之而来。
</blockquote>
加油吧，希望能在通往大牛的道路上越走越远。</p>
]]></description><link>/2014-11-04-baidu-interview-thought/index.html</link><guid isPermaLink="true">/2014-11-04-baidu-interview-thought/index.html</guid><category><![CDATA[interview]]></category><category><![CDATA[tech]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[cool4ZBL]]></dc:creator><pubDate>Tue, 04 Nov 2014 08:13:00 GMT</pubDate></item><item><title><![CDATA[Oh My Ghostium]]></title><description><![CDATA[<p>之前装了Wordpress扔在大洋彼岸一个Arizona搬瓦工的VPS后就再没去理过它，想想也有半年了。<br>后来分析觉得，首先肯定是自己懒惰浮躁，静不下来写东西。其次是博客页面没有漂亮到让我有一种打开就想写的冲动。<br>但是他们说<strong><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/">为什么你应该（从现在开始就）写博客</a></strong>，于是紧跟大牛的步伐，虽然没有什么牛逼技术可以跟别人分享，但是看看大牛写的技术文章谢谢心得也是一种进步。于是就开始了<em>万劫不复的折腾深渊</em>...<br>在谷歌搜寻平台的时候看到了一个同是F2E的一个博客<a href="http://luolei.org">罗磊的独立博客</a>，瞬间被大Banner的设计吸引到，看了很久后拖到了网页末尾，扫到了一行字<em>本博客基于拽酷炫的 GHOST</em>。<br>比较了<em>Ghost/Jekyll/Octo/Hexo</em> 等等之后，认为<strong><a href="https://ghost.org">Ghost</a></strong>还是最适合我： </p>
<ol>
<li>是基于 <strong>Node.js</strong> 的博客平台。</li>
<li><strong>Just a blogging platform.</strong>简单简洁，响应式设计。</li>
<li>免费，<strong>支持完全的自定义</strong>。</li>
</ol>
<p>DigitalOcean很贴心的有Ghost的APP安装镜像包，安装后直接打开<code>http://your.domain/2368</code>就会看到第一次登陆的窗口，设置好Blog Title，用户名，密码就可以愉快的开始体验Ghost了。<br>又过了几天，手贱点开了很多Ghost类的博客，发现大家怎么都这样啊，使用默认的Casper主题已到审美疲劳。<br>在连博文都没写几篇的情况下，那么就继续<em>万劫不复的折腾深渊</em> 咯。  </p>
<p>很喜欢<strong><a href="https://medium.com/">Medium</a></strong>那个网站的设计风格，漂亮的排版和字体，恰当的行高，带有震撼般视觉冲击的大Banner图片...<a href="知乎[怎样评价Medium的设计](http://zhi.hu/1Ed2)">^1</a></p>
<p>感觉一切的设计都如此恰到好处（一股浓浓的高逼格气息扑面而来）。
谷歌搜索类Medium的Ghost主题，
<b> <strong><a href="http://ghostium.oswaldoacauan.com/">Ghostium</a></strong>, a medium-like theme.
</b>
先给作者<a href="https://twitter.com/oswaldoacauan">@oswaldoacauan</a>各种点赞，想要的样式全都有。
但是在网站上跑了一会后，发现有些细节地方还是不尽入我意。<br>那么，还是自己动手丰衣足食，开始<em>万劫不复的折腾深渊</em> 第四弹。
一边看<a href="http://themes.ghost.org/v0.5.3/docs/about">Ghost Developer Documentation</a>、<a href="http://handlebarsjs.com/">Handelbars.js Guide</a>，一边用自学的一点点 HTML&amp;CSS&amp;JS 来调试和修改原主题。</p>
<hr>
<p><strong>- HTML</strong></p>
<ol>
<li>修改Drawer侧栏的导航（Navigation.hbs），增加Links如下:</li>
</ol>
<pre class="hljs"><code><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;/&quot;</span> <span class="hljs-attribute">data-pjax</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-home&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Home
  <span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/timeline/&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-clock-o&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Timeline
  <span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/wiki/&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-coffee&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Wiki
  <span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/book/&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-camera-retro&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Portfolio
  <span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/about/&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-comment-o&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>About Me
  <span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;</span></span></span><span class="hljs-expression">{{@<span class="hljs-variable">blog.url</span>}}</span><span class="xml"><span class="hljs-tag"><span class="hljs-value">/rss/&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-rss&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Subscribe to Feed
  <span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-divider&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item drawer-list-title&quot;</span>&gt;</span>
  Follow me
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;<a href="http://twitter.com/cool4zbl">http://twitter.com/cool4zbl</a>&quot;</span> <span class="hljs-attribute">target</span>=<span class="hljs-value">&quot;_blank&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-twitter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Twitter
  <span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;drawer-list-item&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;<a href="http://github.com/githubzbl">http://github.com/githubzbl</a>&quot;</span> <span class="hljs-attribute">target</span>=<span class="hljs-value">&quot;_blank&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-github&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span>Github
  <span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span></span></code></pre><ol>
<li>在博客文章内容页（post.hbs）删除了分享到G+图标，增加了分享到微博图标：  <pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;#&quot;</span> <span class="hljs-attribute">data-action</span>=<span class="hljs-value">&quot;share-weibo&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">i</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;fa fa-fw fa-lg fa-weibo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span></code></pre></li>
</ol>
<p>CSS(main.css)  </p>
<ol>
<li>字体类型及大小。<br>原来的字体太小，而且因为主题原作者不说汉语，所以默认在主题内显示的汉字为宋体，且行高较小，不方便阅读。发现这么几篇文章：<a href="https://ruby-china.org/topics/14005">web中文字体应用指南</a>//<a href="http://lepture.com/zh/2014/chinese-fonts-and-yue-css">適合閱讀的中文字體</a>//<a href="http://informationarchitects.net/blog/the-web-is-all-about-typography-period/">網頁上95%的內容其實都是&quot;typography“</a> 
特别是第二篇。于是根据自己的喜好，同时照顾到广大Mac、Windows用户，字体样式如下：  <pre class="hljs"><code><span class="hljs-comment">/<em> 文章内容 衬线字体 </em>/</span>
<span class="hljs-tag">body</span> {
 <span class="hljs-attribute">font</span>: <span class="hljs-number">400</span> <span class="hljs-number">20px</span>/<span class="hljs-number">1.62</span> <span class="hljs-string">&quot;Lora&quot;</span>, Georgia, <span class="hljs-string">&quot;Xin Gothic&quot;</span>, <span class="hljs-string">&quot;STXihei&quot;</span>, Cambria, <span class="hljs-string">&quot;Droid Sans Fallback&quot;</span>, <span class="hljs-string">&quot;Microsoft YaHei&quot;</span>, sans-serif;
 <span class="hljs-attribute">background</span>: <span class="hljs-hexcolor">#fff</span>;
 <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#333</span>
}
<span class="hljs-comment">/<em> 文章标题、按钮等 非衬线 </em>/</span><br><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Lato&quot;</span>,<span class="hljs-string">&quot;Myriad Pro&quot;</span>,<span class="hljs-string">&quot;Lucida Grande&quot;</span>,<span class="hljs-string">&quot;Lucida Sans Unicode&quot;</span>,<span class="hljs-string">&quot;Lucida Sans&quot;</span>,Geneva,Verdana,sans-serif;
<span class="hljs-comment">/<em> Footer底部字体 Optima更为优雅低调 </em>/</span>
<span class="hljs-attribute">font-family</span>: Optima, sans-serif;</code></pre></li>
</ol>
<p>注：&quot;Xin Gothic&quot; 信黑体；&quot;STXihei&quot; 华文细黑；&quot;Hiragino Sans GB&quot; 冬青黑体<br><strong>Lato &amp; Lora</strong> 同为 Transitional Fonts。<a href="https://www.codeschool.com/courses/fundamentals-of-design">Foundamentals of Design by code school</a></p>
<ol>
<li><p>主页（index.hbs）的封面/边距/文章摘要  </p>
<ul>
<li>原来的<code>cover</code>大概占据了页面的30%，看起来图片有点喧宾夺主，经过反复折腾后，觉得25%的比例最不错。  <pre class="hljs"><code><span class="hljs-class">.cover</span> <span class="hljs-rules">{
<span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value"> relative</span></span>;
<span class="hljs-rule"><span class="hljs-attribute">top</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
<span class="hljs-rule"><span class="hljs-attribute">left</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
<span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">25%</span></span></span>;
<span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>;
<span class="hljs-rule"><span class="hljs-attribute">z-index</span>:<span class="hljs-value"> <span class="hljs-number">100</span>
</span></span></span>}</code></pre></li>
<li><p>主页右侧文章内容偏上，如果是英文内容还好，但是中文的话感觉一块块的，特别突兀，调整<code>padding</code>，使内边距更大。反复比较后，6%看起来最自然。</p>
<pre class="hljs"><code><span class="hljs-class">.wrapper-container</span> <span class="hljs-rules">{
<span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value"> relative</span></span>;
<span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">6%</span> <span class="hljs-number">10%</span> <span class="hljs-number">40px</span> <span class="hljs-number">185px</span></span></span>;
<span class="hljs-rule"><span class="hljs-attribute">max-width</span>:<span class="hljs-value"> <span class="hljs-number">910px</span>
</span></span></span>}</code></pre><ul>
<li>主页右侧的文章摘要(post/list.hbs)原来为<br><code>&lt;section itemprop=&quot;description&quot; class=&quot;post-item-excerpt&quot;&gt;
&lt;p&gt;{{excerpt words=&quot;35&quot;}}&amp;hellip;&lt;/p&gt;
&lt;/section&gt;</code></li>
</ul>
<p>如果是英文内容还好，但是对于中文内容，Ghost貌似对这个支持不太好（因为是按空格来计算word数量），所以显示的摘要往往会过多，查看文档后发现有另一种<code>character</code>字符数计数方式。很高兴地修改如下：<br><code>&lt;section itemprop=&quot;description&quot; class=&quot;post-item-excerpt&quot;&gt;
&lt;p&gt;{{excerpt characters=&quot;140&quot;}}&amp;hellip;&lt;/p&gt;
&lt;/section&gt;</code></p>
</li>
</ul>
</li>
<li><p>全局导航栏(drawer.hbs)<br> 每个导航栏(.drawer-list-item)字体过小，且挨得太近。参考了一下我最喜欢的<strong>Medium</strong>设计后，修改如下：  </p>
<pre class="hljs"><code>  <span class="hljs-class">.drawer-list-item</span> <span class="hljs-rules">{
 <span class="hljs-rule"><span class="hljs-attribute">font-family</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Lato&quot;</span>,<span class="hljs-string">&quot;Myriad Pro&quot;</span>,<span class="hljs-string">&quot;Lucida Grande&quot;</span>,<span class="hljs-string">&quot;Lucida Sans Unicode&quot;</span>,<span class="hljs-string">&quot;Lucida Sans&quot;</span>,Geneva,Verdana,sans-serif</span></span>;
 <span class="hljs-rule"><span class="hljs-attribute">font-weight</span>:<span class="hljs-value"> <span class="hljs-number">600</span></span></span>;
 <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> .<span class="hljs-number">9em</span></span></span>;
 <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#9c9c9c</span></span></span>;
 <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"> <span class="hljs-number">2.2</span></span></span>;
 }</span></code></pre></li>
<li><p>博客内容分页(post.hbs)<br> 对于作者的头像<code>.post-author-avatar</code>，原作者可能了为了保证质量，头像不被随意拉伸，<code>language-css .post-author-avatar { width: 100%; height: 100%; border-radius: 100% }</code>，采取了长宽度100%，但是四个角自然圆角，所以如果传的头像是矩形就会出现椭圆形的效果，但是个人觉得还是圆形头像更精致。所以为了保证无论上传何种比例的图片，得到的都是圆形的头像，那么就采用固定长宽度（此处在看Ghost后台时候，发现默认的作者头像就是圆形，查看源代码发现使用的是<code>js-model-image</code>，涉及到JS还未深入研究）。   </p>
<pre class="hljs"><code> <span class="hljs-class">.post-author-avatar</span> <span class="hljs-rules">{
 <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">80px</span></span></span>;
 <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">80px</span></span></span>;
 <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> block</span></span>;
 <span class="hljs-rule"><span class="hljs-attribute">margin-bottom</span>:<span class="hljs-value"> <span class="hljs-number">10px</span>
 </span></span></span>}</code></pre></li>
</ol>
<hr>
<p>大体地方修改完毕，把修改后主题上传到VPS，重启Ghost服务（Ghost无法实时探测到<code>content/theme/</code>内容改变）。<br>Well done.</p>
<p>优化：<br>对于谷歌字体在国内<del>访问速度不佳</del>无法访问，使用了<a href="http://libs.useso.com/">360网站卫士加速库</a> <code>language-html &lt;link href=&quot;//fonts.useso.com/css?family=***&quot;&gt;</code></p>
<p>待解决问题：</p>
<ul>
<li>微博官方的分享按钮太花哨，想使用FontAwesome的图标但还未解决如何触发微博分享；  </li>
<li>把博客内容页面<code>post</code>样式从<code>main.css</code>中分离出来，方便以后Ghost升级做<em>所见即所得</em> (but we highly recommend keeping your post styles in a separate file (post.css) from other styles for your theme (style.css) so that you will quickly be able to take advantage of this feature in the future.)；  </li>
<li>在<code>post</code>页面加入一个返回顶部的小箭头；  </li>
<li>在<code>post</code>页面应用类似于Medium文章打开后顶部为震撼图片的大Banner。 </li>
<li>学习使用JS-model-image 自动切割Avatar及Logo  </li>
<li>Navigation各种链接网页的相关建设及完善  </li>
<li>博文搜索  </li>
<li>画个网站结构图 site-map</li>
</ul>
]]></description><link>/2014-11-03-oh-my-ghostium/index.html</link><guid isPermaLink="true">/2014-11-03-oh-my-ghostium/index.html</guid><category><![CDATA[tech]]></category><category><![CDATA[frontend]]></category><category><![CDATA[thoughts]]></category><dc:creator><![CDATA[cool4ZBL]]></dc:creator><pubDate>Sun, 02 Nov 2014 16:00:00 GMT</pubDate></item></channel></rss>