<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[undefined - ZBL's Doodle]]></title><description><![CDATA[Thoughts, ideas]]></description><link>http://zhangbinliu.me/</link><generator>Ghost</generator><lastBuildDate>Mon, 07 Aug 2017 18:18:07 GMT</lastBuildDate><atom:link href="http://zhangbinliu.me/tag/undefined/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Fun with Codemod & AST]]></title><description><![CDATA[<h2 id="tl-dr">TL;DR</h2>
<ul>
<li>Facebook 为了解决「大型代码库」迁移，基于 AST 造了个工具 <strong>Codemod</strong></li>
<li>基于 Codemod 又构建了 JavaScript 代码迁移专用的工具 <strong>jscodeshift</strong> 和 <strong>React-codemod</strong></li>
<li>理解这些工具背后的原理有助于从一个单纯的「API 使用者」变成一个工程师般的「创造者」</li>
<li>Demo Time！Let&#39;s write a codemod</li>
<li>一些有价值的参考</li>
</ul>
<hr>
<h2 id="-">背景</h2>
<p>作为一个自信而自豪的前端弄潮儿（F2E），我们总是希望能够在这个每天都在飞速迭代的行业，与时渐进。
前端们是一群不安分的人，大家喜爱新框架、新语法，而 JavaScript 也是一门非常灵活的语言，它提供给我们的 API 也在与时渐进。比如，当 <code>ES2015 / ES2016 / ES2017…</code> 出来的时候，那些新语法糖，简洁漂亮，且更易于理解逻辑，于是我们都想去尝试下。
但是尝试归尝试，对于新项目尝试起来成本很低，只需要把新功能都用新语法编写就好。
而创建新项目的同时，其实我们也在维护着一些已有的旧项目。如果你还并没怎么理它们，可能它们还活得不错。但是一旦 PM 心情好想加个新功能，或者你哪天心情好想去更新下代码库，然后看到自己之前写的那些代码，那些现在其实可以更优雅漂亮的代码，是不是手里特痒痒特想把它们更新了？
执行力强的小伙伴可能说干就干了。嗯，就假设我们有个项目，里面使用的是用<code>ES5</code> 版 <code>React</code> 作为 <code>UI View</code>层，然后它大概四个页面<code>(Page)</code>，每个页面包含大概四个组件<code>(Component)</code>，然后你从某个看起来比较小、不容易出错的<code>Component</code> 入手，开始一行一行改写代码，嗯，<code>var React = require(&#39;react’)</code> 改为 <code>import React from &#39;react’</code>， <code>var API = ‘/j/app/xxx’</code> 改为 <code>const API = ‘/j/app/xxx’</code>，<code>var foo</code> 改为 <code>let foo</code>，<code>function () {…}</code> 改为 <code>() =&gt; {…}</code>，<code>module.exports = React.createClass({…})</code> 改为 <code>export default class MyComponent extends React.Component {…}</code> …
天哪，有完没完，一个组件改完下来，你已经感到身体被掏空，望了望 <code>Components</code> 列表，更不用说，重新 <code>build</code> 过的测试还没过。你陷入了绝望...</p>
<p>那么有没有更快一点的办法呢？
稍微有点经验的前端儿可能想到「正则表达式匹配替换」。Bash <code>Awk | Sed</code> 命令，或者 Vim <code>:%s/var/let/g</code>。可是如果需要有些变量是 <code>const</code> 类型，有些是 <code>let</code>，而有些保持 <code>var</code> 不变怎么办？再比如说以下这段很常见的代码：</p>
<pre class="hljs"><code><span class="hljs-tag">merge</span>(a, {<span class="hljs-attribute">b</span>: <span class="hljs-number">1</span>}, c);  <span class="hljs-comment">// Old</span>

<span class="hljs-comment">// 需要变为</span>

({..<span class="hljs-class">.a</span>, <span class="hljs-tag">b</span>: <span class="hljs-tag">1</span>, ..<span class="hljs-class">.c</span>});  <span class="hljs-comment">// New</span></code></pre><p>这里光是这个函数的 <code>arguments</code> 就可能有多种形式，比如 <code>variable</code>，一个匿名函数返回的 Object 或者 <code>Plain Object</code> 那种。
所以这里已经相当于是一个 <code>Context-non-free</code> 的问题，也就是说，<strong>上下文语义</strong>很重要。
这样的话，无论再怎么强大的<code>RegExp</code> 也无能为力。因为正则的本质，其实是根据一定的 <code>Pattern</code> 来匹配字符串，但是在真正的代码里，所有的字符串都有语义，都有上下文，这里的正则表达式会既复杂又无用。
所以，我们得<strong>升一个维度</strong>思考问题。</p>
<h2 id="codemod">Codemod</h2>
<p>对「代码库的批量迁移更新」，其实也是程序员的一个需求，所以，很感恩地，已经有一群懒惰又聪明的程序员造出了工具：<strong>Codemod</strong>，将「大型仓库代码的批量迁移」自动化，省时省力。</p>
<p>好吧，所以 <strong>Codemod</strong> 到底是什么呢？
官方文档这样写着：</p>
<blockquote>
<p>Codemod is a tool/library to assist you with large-scale codebase refactors that can be partially automated but still require human oversight and occasional intervention.</p>
</blockquote>
<p>这样看来，可以很好的解决我们的需求了。
基于 Codemod，又出现了针对 JavaScript 代码迁移的工具 <a href="https://github.com/facebook/jscodeshift">Facebook jscoodeshift</a>，
基于 <strong>jscodeshift</strong>，又构建了迁移一般 JavaScript 代码（比如 ES5 -&gt; ES2015) 的工具 <a href="https://github.com/cpojer/js-codemod">js-codemod</a> 和迁移 React 相关项目的 <a href="https://github.com/reactjs/react-codemod">react-codemod</a>。</p>
<p>嗯，这么看来，我们的事情就变得容易多了。
根据上面那些工具的官方文档，我们只需要按顺序执行以下命令：</p>
<pre class="hljs"><code>&gt; npm i -g jscodeshift
&gt; git clone https:<span class="hljs-comment">//github.com/reactjs/react-codemod.git</span>
&gt; git clone https:<span class="hljs-comment">//github.com/cpojer/js-codemod.git</span>
&gt; jscodeshift -t react-codemod/transforms/<span class="hljs-keyword">class</span>.js --<span class="hljs-keyword">mixin</span>-<span class="hljs-keyword">module</span>-name=react-addons-<span class="hljs-keyword">pure</span>-render-<span class="hljs-keyword">mixin</span> --flow=<span class="hljs-literal">true</span> --<span class="hljs-keyword">pure</span>-component=<span class="hljs-literal">true</span> --remove-runtime-proptypes=<span class="hljs-literal">false</span> src/register/component/myComponent.jsx
&gt; jscodeshift -t js-codemod/transforms/no-vars.js ./src/register/component/myComponent.jsx</code></pre><p>然后，再次 <code>git status</code> 一下或者直接打开刚才 transform 的 <code>myComponent.jsx</code> 文件查看，你会发现，Wow，神奇般，你的代码都成为了它们应该成为的样子！</p>
<p>这里暂时以我之前做的 Accounts 项目为例：
<a href="https://github.intra.douban.com/accounts/accounts/pull/553/files#diff-b2286efdea6a62288250264e82bd948b">https://github.intra.douban.com/accounts/accounts/pull/553/files#diff-b2286efdea6a62288250264e82bd948b</a></p>
<p>基本步骤如下：</p>
<ol>
<li>因为是第一次使用 <code>codemod</code>，所以比较谨慎，一个一个 <code>component</code> 来；</li>
<li>先用 <code>react-codemod</code> 转，把大部头代码迁移；</li>
<li>然后 <code>js-codemod</code> 小步更新整理；</li>
<li>然后再根据一些自己的 Code Style 做些细节上的修改。比如使用 <code>standard-format</code> 工具格式化代码，符合我个人写的代码风格。</li>
<li>毕竟 JS 太过于灵活，每个人写代码时候风格和结构都是各异的，有时候的转换还是会出现一些与想象中不一致的结果，官方文档也是说仍然需要人工干预，所以会根据 transform 后的结果手动修改下代码细节；</li>
<li>一切组件迁移就绪，<code>npm run test</code> 测试通过以后，重新 <code>build</code> 运行</li>
</ol>
<p>这里我把已有的十几个组件和页面文件，全部使用上面的工具进行了更新。
然后当你重新 <code>build</code> 后，你会发现测试仍然通过，组件功能仍然 work，但是代码库却是使用新语法糖进行了大规模彻彻底底地更新！简直太神奇了！🤓
那么，它是怎么做到的呢？
这里就要好好深究下这个工具了。</p>
<h2 id="jscodeshift">jscodeshift</h2>
<p>让我们来重新读一下 jscodeshift 的<a href="https://github.com/facebook/jscodeshift#jscodeshift-">文档</a>。</p>
<blockquote>
<p>jscodeshift is a toolkit for running codemods over multiple JS files. It provides:</p>
</blockquote>
<ul>
<li>A runner, which executes the provided transform for each file passed to it. It also outputs a summary of how many files have (not) been transformed.</li>
<li>A wrapper around recast, providing a different API. Recast is an AST-to-AST transform tool and also tries to preserve the style of original code as much as possible.</li>
</ul>
<p>那么这里就出现了两个关键的概念：<em>Runner</em> 及 <em>AST</em>。</p>
<ul>
<li><strong>Runner</strong></li>
<li><blockquote>
<p>A runner/worker feature that can apply transforms to thousands of files in parallel.
-- <a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.sg03sd9eq">CPojer Effective JavaScript Codemods</a></p>
</blockquote>
</li>
<li><p><strong>AST</strong>，Abstract Syntax Tree，抽象语法分析树。</p>
</li>
</ul>
<p>为了更好理解以上概念，先来看一下之前运行 jscodeshift 命令过程。
我们先是把一个里面包含了 JS 代码的源文件传给了它，然后它读取了源代码，又根据写好的 <code>transform.js</code> 对源代码进行了相应的变换，最后输出了变换后的 JS 代码，覆盖了原文件。
这个过程简单的说，就是：
<code>SourceCode =&gt; codemod =&gt; ObjectCode</code></p>
<p>那么再详细一点，根据 jscodeshift 作者之一的 CPojer 在一次 JSConf 上对这个工具的介绍，jscodeshift 操作基本是按以下过程：
<code>Parse =&gt; Find =&gt; Create =&gt; Update =&gt; Print</code></p>
<ol>
<li><strong>Parse</strong>: SourceCode =&gt; AST （Tree Nodes)</li>
<li><strong>Find</strong>: Find the Nodes we want to replace         // Transform</li>
<li><strong>Create</strong>: Create the New Nodes we want to insert  // Transform</li>
<li><strong>Update</strong>: Update the AST at the right location    // Transform</li>
<li><strong>Print</strong>: Print it back into JavaScript Source with proper formatting and should like human wrote this.</li>
</ol>
<h3 id="-parse-ast-">第一步，将源代码解析 (parse) 成 AST.</h3>
<p>现在我们先回到语言的本质。</p>
<p>我们知道自然语言（Natural Language)，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。
而在计算机编程语言 (Programming Language)，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。</p>
<p>不同的语言，都会配之不同的<strong>语法分析器</strong>(parser)。</p>
<p>对于自然语言，我们的大脑就是一个 Parser。</p>
<p>对于编程语言，语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。</p>
<p>什么是<strong>语法树</strong>？摘自 Wiki 一段：</p>
<blockquote>
<p>计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>
</blockquote>
<p>这么说其实还是有点抽象，我们先打开 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">wiki</a> 看到 wikipedia 这个图，</p>
<p><img src="../content/images/codemod_ast/ast_tree.png" alt="AST Tree"></p>
<p>前端er 一定会觉得很相似，这里不就是 DOM 语法树的终极抽象版本吗，只是把一个个 DOM Nodes 换成了一个个更加无语义的字符 Token。
FB 有一个很棒的工具 <a href="http://astexplorer.net/">ASTExplorer</a>，可以用来更形象地展示。</p>
<p>比如说，我们现在就只有一个很简单的表达式<code>a+b</code>，这里是 recast Parser 解析后的 AST 结构：</p>
<p><img src="../content/images/codemod_ast/a+b_ast_tree.png" alt="a + b AST Tree"></p>
<p>看上去特别复杂。注意那些蓝色字体 <code>File</code>, <code>Programme</code>,<code>ExpressionStatement</code>,<code>Identifier</code>… 这些都是 AST Nodes，其他的都是和这个 Node 相关的数据。</p>
<p>根据前文可以知道，每种语言的 AST 都是不同的。有专门的 Parser 来生成 AST。</p>
<p>关于 <a href="https://en.wikipedia.org/wiki/Parsing#Parser">Parser</a> 又是一门很深的学问了。</p>
<p>在 ASTExplorer.net 上可以看到有很多 parser，比较著名的有 <a href="https://github.com/jquery/esprima/blob/master/src/parser.ts">Esprima(jQuery)</a>，Uglify-JS, Babylon(Babel), Acorn(Tern / Webpack), 及 jscodeshift 使用的 recast。</p>
<p>虽然有很多 Parser，但是基本上，一个 parser 的结构都差不多，对源代码进行词法分析，生成 Tokens，对 Tokens 进行语法分析，然后生成 AST。</p>
<p><img src="../content/images/codemod_ast/parser.png" alt="Parser"></p>
<p>具体可以参考看下 <a href="http://esprima.org/demo/parse.html#">Esprima Parse Demo</a>。
生成的 AST 都遵循一个统一标准 <a href="https://github.com/estree/estree/blob/master/es5.md">ESTree</a> or <a href="parser API https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API">Mozilla SpiderMonkey</a>，也就是说都会返回一个 ESTree Compatible AST。</p>
<h3 id="-ast-find-nodes-create-new-nodes-update-nodes-">第二三四步，对生成的 AST 进行操作修改 (Find Nodes &amp; Create New Nodes &amp; Update Nodes)</h3>
<p>Wiki 有介绍说，parse AST 的代码基本是使用<code>Visitor Pattern</code>（游客模式），如：</p>
<pre class="hljs"><code><span class="hljs-comment">// recast</span>
<span class="hljs-keyword">var</span> ast = recast.parse(src);
recast.visit(ast, {
visitIdentifier: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(path)</span> </span>{
    <span class="hljs-comment">// do something with path</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
});</code></pre><p>这其实也很容易理解，AST 就是一个树形结构，然后解析它的话就是以一个游客一样遍历这棵树。</p>
<p>但是这个模式在前端中还是用得比较少的，所以 <code>js-codeshift</code> 基于 <a href="https://github.com/facebook/jscodeshift#collections-and-traversal">Collections</a> 概念，很贴心的给这些 Parser API 继续包了一层，提供了一个不一样的前端友好型 API.</p>
<pre class="hljs"><code><span class="hljs-comment">// jscodeshift</span>
<span class="hljs-tag">jscodeshift</span>(src)
    <span class="hljs-class">.find</span>(jscodeshift.Identifier)
      <span class="hljs-class">.forEach</span>(<span class="hljs-function">function</span>(path) {
      <span class="hljs-comment">// do something with path</span>
});

<span class="hljs-comment">// Provide jQuery-likely and F2E-friendly Syntax API</span>
<span class="hljs-comment">// Manipulate AST nodes conveniently.</span></code></pre><p>读这段代码的时候，一下子觉得又似曾相识。这不就和使用 <code>jQuery</code> 操作 DOM 一样嘛。</p>
<p>可以对比下 “普通 Parser” 与 jscodeshift 操纵 AST 的区别：</p>
<p>可以看到如果使用 <a href="http://esprima.org/">esprima</a> ，AST Traverse / Walk 基本是 <code>visitor pattern</code>.
<a href="https://github.intra.douban.com/zhangbinliu/ast_demo/tree/esprima">https://github.intra.douban.com/zhangbinliu/ast_demo/tree/esprima</a></p>
<h3 id="-">第五步，输出转换后的代码</h3>
<p>据 jscodeshift 创造者之一 CPojer 说，根据转换后的 AST，以及一些输出 <a href="https://github.com/benjamn/recast/blob/52a7ec3eaaa37e78436841ed8afc948033a86252/lib/options.js#L61">Options</a>（比如是否单引号、tab 宽度是多少、需不需要去掉尾部分号…），是一个挺困难的过程。
但是最终，jscodeshift 的输出 API 却简洁明了，只要一行代码即可搞定。</p>
<pre class="hljs"><code><span class="hljs-class">.toSource</span>({<span class="hljs-attribute">quote</span>: <span class="hljs-string">&#39;single&#39;</span>}); <span class="hljs-comment">// sets strings to use single quotes in transformed code.</span></code></pre><p>（其实 Recast 在这做了<a href="(https://github.com/benjamn/recast/blob/master/lib/printer.js">大量的工作</a> )）</p>
<p>经过这五个步骤，一次 jscodeshift 的转换过程就算完成啦。</p>
<h2 id="demo-time-write-a-codemod-transform">DEMO TIME!  Write a codemod transform</h2>
<pre class="hljs"><code>jscodeshift -t &lt;transform.js&gt; /<span class="hljs-keyword">to</span>/<span class="hljs-type">file</span>/path</code></pre><p>我们来写<code>transform.js</code>，也就是说，你打算使用 jscodeshift 对源代码进行何种变换，这里面就是变换函数。</p>
<p>现在考虑一个 ES5 -&gt; ES6 的经典问题：</p>
<h4 id="problem-">Problem:</h4>
<p><code>
// Before
&#39;Hello, &#39; + name + &#39;, I am a string.&#39;
// After
<code>Hello, ${name}, I am a string.</code>
</code></p>
<h4 id="solution-">Solution:</h4>
<ol>
<li>Simplify， 考虑一个最简单的情况</li>
</ol>
<p><code>
// Before
a + b
// After
<code>${a}${b}</code>
</code></p>
<p><code>a + b</code> AST:</p>
<p><img src="../content/images/codemod_ast/a+b_ast_tree.png" alt="`a + b` AST"></p>
<p><code>${a}${b}</code> AST:</p>
<p><img src="../content/images/codemod_ast/a+b_tmpl_ast.png" alt="`${a}${b}`"></p>
<p>对比两个 AST 可以发现，我们只需要</p>
<ol>
<li>读入需转换的代码，找到 <code>BinaryExpression</code></li>
<li>保存 <code>BinaryExpression</code> 左右两边的值（node.left &amp; node.right)</li>
<li>生成一个为 <code>TemlateLiteral</code> Node，<code>quasis</code> 是一个包含了三个 <code>TemplateElement</code> 的数组，<code>cookde &amp; raw keys</code> 都是 <code>&#39;&#39;</code>， <code>expressions</code> 是一个包含 node.left, node.right 值的数组。</li>
<li>然后将它返回输出；</li>
</ol>
<p>这里贴下我的 Solution Example:</p>
<ol>
<li><p><a href="http://astexplorer.net/#/gist/33b63b7dc8da6d9ea4936c631adc994d/7905ef5b30dfc0cb3c811af8a8960f11014ef402">http://astexplorer.net/#/gist/33b63b7dc8da6d9ea4936c631adc994d/7905ef5b30dfc0cb3c811af8a8960f11014ef402</a></p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformer</span>(<span class="hljs-params">file, api</span>) </span>{
<span class="hljs-keyword">const</span> j = api.jscodeshift;
<span class="hljs-keyword">const</span> root = j(file.source)

<span class="hljs-keyword">const</span> toTempLiteral = (p) =&gt; {
 <span class="hljs-keyword">const</span> quasis = [
  j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-literal">false</span>),
  j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-literal">false</span>),
  j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-literal">true</span>),
 ]

 <span class="hljs-keyword">const</span> tempLiteral = j.templateLiteral(quasis, [p.node.left, p.node.right])

 <span class="hljs-keyword">return</span> tempLiteral
}

<span class="hljs-keyword">return</span> root
 .find(j.BinaryExpression, {operator : <span class="hljs-string">&#39;+&#39;</span>})
   .replaceWith(toTempLiteral)
 .toSource()
}</code></pre></li>
<li><p><a href="http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/55c4910295973b3a4d09770d94cec73d5096daa4">http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/55c4910295973b3a4d09770d94cec73d5096daa4</a></p>
</li>
</ol>
<pre class="hljs"><code><span class="hljs-literal">export</span> <span class="hljs-keyword">default</span> function transformer(file, api) {
  <span class="hljs-keyword">const</span> j = api.jscodeshift;
  <span class="hljs-keyword">const</span> root = j(file.source)

  <span class="hljs-keyword">const</span> toTempLiteral = (p) =&gt; {
    <span class="hljs-keyword">const</span> quasis = [
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">false</span>),
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">false</span>),
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">true</span>),
    ]

    <span class="hljs-keyword">const</span> extractNodes = (node) =&gt; {
     <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">&#39;BinaryExpression&#39;</span> &amp;&amp; node.<span class="hljs-literal">operator</span> === <span class="hljs-string">&#39;+&#39;</span>) {
         <span class="hljs-keyword">return</span> [...extractNodes(node.left), ...extractNodes(node.right)]
     }
     <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> [node] }
    }

    <span class="hljs-keyword">const</span> tempLiteral = j.templateLiteral(quasis, extractNodes(p.node))

    <span class="hljs-keyword">return</span> tempLiteral
  }

  <span class="hljs-keyword">return</span> root
    .find(j.BinaryExpression, {<span class="hljs-literal">operator</span> : <span class="hljs-string">&#39;+&#39;</span>})
      .replaceWith(toTempLiteral)
    .toSource()
}</code></pre><ol>
<li><a href="http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/cf3c898c5fe494d08a978dd1a3a3e56fc42828a8">http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/cf3c898c5fe494d08a978dd1a3a3e56fc42828a8</a></li>
</ol>
<pre class="hljs"><code><span class="hljs-literal">export</span> <span class="hljs-keyword">default</span> function transformer(file, api) {
  <span class="hljs-keyword">const</span> j = api.jscodeshift;
  <span class="hljs-keyword">const</span> root = j(file.source)

  <span class="hljs-keyword">const</span> toTempLiteral = (p) =&gt; {
    <span class="hljs-keyword">const</span> quasis = [
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">false</span>),
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">false</span>),
     j.templateElement({<span class="hljs-string">&quot;cooked&quot;</span>: <span class="hljs-string">&#39;&#39;</span>, <span class="hljs-string">&quot;raw&quot;</span>: <span class="hljs-string">&#39;&#39;</span>}, <span class="hljs-keyword">true</span>),
    ]

    <span class="hljs-keyword">const</span> extractNodes = (node) =&gt; {
     <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">&#39;BinaryExpression&#39;</span> &amp;&amp; node.<span class="hljs-literal">operator</span> === <span class="hljs-string">&#39;+&#39;</span>) {
         <span class="hljs-keyword">return</span> [...extractNodes(node.left), ...extractNodes(node.right)]
     }
     <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> [node] }
    }

    <span class="hljs-keyword">const</span> tempLiteral = j.templateLiteral(quasis, extractNodes(p.node))

    <span class="hljs-keyword">return</span> tempLiteral
  }

  <span class="hljs-keyword">return</span> root
    .find(j.BinaryExpression, {<span class="hljs-literal">operator</span> : <span class="hljs-string">&#39;+&#39;</span>})
      .replaceWith(toTempLiteral)
    .toSource()
}</code></pre><p>官方没有太详细的 transform 编写指导，可以多谷歌或者学习已编写好的 transform：<code>react-codemod/tranform</code> 或者 <code>js-codemod/transform</code>。</p>
<p>我个人觉得写 JS-Codeshift Transform | Babel-Plugin 本质其实就是对比两棵语法树，像解谜一样，看看如何「又好又快」变换成这样。</p>
<p>剩下的一开始如何读取源 JS 代码并解析成语法树，具体在 AST 上 traverse &amp; find &amp; create &amp; update （这里我猜测其实是一个递归遍历节点树的过程？），及之后如何按一定的 code style 生成我们需要的代码，都是透明且不关心的。</p>
<h2 id="-">总结 &amp; 开脑洞</h2>
<ul>
<li><p>总结下基本处理流程：
<img src="../content/images/codemod_ast/process.png" alt="Process"></p>
</li>
<li><p>AST 是很有用的一个抽象概念。一旦你理解了这些规则，唯一的限制就是解析器和你的想象力。</p>
</li>
<li>纯 AST parse 太过于理论，既然是工程师，还是需要自己动手写点什么来解决自己实际遇到的问题。</li>
<li>可以继续拓展到「语法高亮」、「关键字匹配」、「代码格式化」、「作用域判断」、以及「代码压缩」、「Babel 插件」等等。</li>
<li>渐渐深入底层进行分析，让自己对这门语言有了更多、更深入的了解，可以更好地成为产品「创造者」，而不单纯是「使用者」。</li>
<li><strong>Write JavaScript that writes JavaScript! The best editor is JavaScript. Cool!</strong></li>
</ul>
<h2 id="-">思考</h2>
<ul>
<li>可以在一个 codemod transform 里面同时进行两个变换吗？个人觉得可能会很复杂且效果不太好，因为有些 transform 并不是正交的。🤔</li>
</ul>
<h2 id="refs-">Refs:</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=d0pOgY8__JM">CPojer’s Talk</a></li>
<li><a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.s5kdne4xl">Effective JavaScript Codemods</a></li>
<li><a href="https://survivejs.com/blog/codemod-interview/">Codemod Interview</a></li>
<li><a href="https://vramana.github.io/blog/2015/12/21/codemod-tutorial/">How to write a codemod</a> 结合 CPojer’s Talk, 这个虽很长但很有用！</li>
<li><a href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/">Understanding Babel Plugin</a></li>
<li><a href="http://tech.meituan.com/abstract-syntax-tree.html">AST 在美团的应用</a></li>
<li><a href="http://imweb.io/topic/57b13b4f93d9938132cc8dfd">imweb</a></li>
</ul>
]]></description><link>/2017-02-15-fun-with-codemod-and-ast/index.html</link><guid isPermaLink="true">/2017-02-15-fun-with-codemod-and-ast/index.html</guid><category><![CDATA[tech]]></category><category><![CDATA[programming]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Tue, 14 Feb 2017 17:21:00 GMT</pubDate></item><item><title><![CDATA[移动环境下的 SEO]]></title><description><![CDATA[<p>真的有很久很久没来理这个博客，距离上一篇文章的发布日期是两年前。
毕业工作后来了豆瓣，最近对移动环境（主要是浏览器及微信）的 SEO 相关进行了下研究，正好在这里分享一下。</p>
<p>以下，Enjoy。</p>
<hr>
<h3 id="1-seo-search-engine-optimazition">1. SEO：Search Engine Optimazition</h3>
<p>产品：搜索引擎优化，促进内容网站信息分享／传播，提高目标转化率，留存率</p>
<p>工程：为各类页面实现统一的信息分享、传播，提高搜索排名（search ranking）</p>
<p>个人觉得：</p>
<ul>
<li>豆瓣是一个内容网站，拥有一些 UGC 优质内容，SEO 间接帮助用户分享。
且分享率越高，也会提高搜索排名。</li>
<li>M 站的目前面向<strong> 人（User） </strong>的 UX 比较完善，但是仍需要丰富一些细节，让 <strong>Search Engine</strong> 的 UX 更好，更好地理解 M 站。</li>
</ul>
<h3 id="2-seo-">2. 前端在 SEO 中的位置</h3>
<ul>
<li><strong>帮助产品进行TDK （Title / Description / Keyword）优化</strong></li>
<li><strong>添加一些 Social Meta Tag （Facebook / Twitter / G+ / WeChat / Weibo）</strong></li>
<li>页面内容优化（HTML5 标签语义化、唯一的 H1 标题、img 设置 <code>alt</code> 属性，不需要爬虫跟踪的链接加 <code>nofollow</code>）</li>
<li>URL 优化 (<strong>canonical</strong>，标签表示页面的唯一性)<ul>
<li>在搜索引擎里，<strong>只有链接完全一样，才会认为是同一个链接</strong>，如果链接带上参数，虽然访问到的内容还是一样，但是在搜索引擎看来确是不同的链接，页面抓取也会出现多次，从而导致多个链接，内容一样。</li>
<li>因此 URL 中最好是不要带上查询参数。但为了产品统计数据，总需要 <code>?from=xxx&amp;refer=xxx</code>等参数，所以使用 <code>canonical</code>标签来确保链接唯一性，避免权重分散、流失。</li>
<li>比如 <code>m.douban.com/group/topics[?start=xxx]</code>均视为同一个页面这里的 <code>?start=xxx</code>是一个分页查询参数，所以为了确保这些页面都能继承 m.douban.group/toics 这个 url  的权重，在<code>head</code>中增加了<code>canonical</code>标签</li>
</ul>
</li>
<li>Meta robots</li>
<li>Sitemap</li>
</ul>
<h3 id="3-">3. 具体实现</h3>
<blockquote>
<p><strong>统一 SNS 抓取</strong></p>
<p>提供一个 mako 函数，统一分享的标题、图片、描述</p>
<ul>
<li>Open Graph</li>
<li>Twitter Card</li>
</ul>
<p><strong>实现统一的分享接口</strong></p>
<p>可变的图片、标题、描述</p>
<ul>
<li><p>微信 （iOS、Android 系统分享菜单、微信内置分享）</p>
</li>
<li><ul>
<li>外部调用分享可能会抓取标题、第一个图片地址（Open Graph）</li>
<li>调用内置分享可用第三个链接 (API 跨子域)</li>
</ul>
</li>
<li><p>微博</p>
</li>
</ul>
<p>参考链接：</p>
<p><a href="https://developers.facebook.com/docs/sharing/opengraph">https://developers.facebook.com/docs/sharing/opengraph</a></p>
<p><a href="https://dev.twitter.com/cards/overview">https://dev.twitter.com/cards/overview</a></p>
<p><a href="http://github.intra.douban.com/frodo/Talion/blob/master/views/j/wechat/__init__.py">http://github.intra.douban.com/frodo/Talion/blob/master/views/j/wechat/<strong>init</strong>.py</a> </p>
<p>— From <a href="https://paper.dropbox.com/doc/-SEO-UVIgU3WYPUeiJv3nOPP0N">Douban FE Dropbox</a></p>
</blockquote>
<h3 id="-">实现方案</h3>
<h4 id="1-seo_meta-mako-widget">1. 增加了 <code>seo_meta()</code> Mako widget</h4>
<p> <a href="http://github.intra.douban.com/frodo/Talion/blob/master/templates/card/widgets.html#L527">http://github.intra.douban.com/frodo/Talion/blob/master/templates/card/widgets.html#L527</a></p>
<pre class="hljs"><code><span class="xml"></span>&lt;%<span class="perl">def name=<span class="hljs-string">&quot;seo_meta(title, desc, image=None, url=None, type=None, rating_count=None, rating_val=None, wechat_timeline_title=None,wechat_chat_title=None, wechat_desc=None, wechat_image=None)&quot;</span>&gt;
    &lt;%
        from douban.image.qiniu import qiniu_proxy_url

        default_title = <span class="hljs-string">&#39;豆瓣&#39;</span>
        default_desc = <span class="hljs-string">&#39;读书、看电影、涨知识、学穿搭...，加入兴趣小组，获得达人们的高质量生活经验，找到有相同爱好的小伙伴。&#39;</span>
        default_image = static(<span class="hljs-string">&#39;/pics/icon/m_logo_180.png&#39;</span>)
        default_url = <span class="hljs-string">&#39;<a href="http://m.douban.com/">http://m.douban.com/</a>&#39;</span>
        default_type = <span class="hljs-string">&#39;article&#39;</span>
        image = qiniu_proxy_url(image, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>, mode=<span class="hljs-string">&#39;1&#39;</span>) <span class="hljs-keyword">if</span> image <span class="hljs-keyword">else</span> <span class="hljs-string">&#39;&#39;</span>
    </span>%&gt;<span class="xml">
    <span class="hljs-comment">&lt;!-- Schema.org markup for Google+ --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;name&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ title or default_title }&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ desc or default_desc }&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span>&gt;</span>
</span><span class="perl">    % <span class="hljs-keyword">if</span> rating_count:</span><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;reviewCount&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ rating_count }&quot;</span>&gt;</span>
</span><span class="perl">    % endif</span><span class="xml">
</span><span class="perl">    % <span class="hljs-keyword">if</span> rating_val:</span><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">itemprop</span>=<span class="hljs-value">&quot;ratingValue&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ rating_val }&quot;</span>&gt;</span>
</span><span class="perl">    % endif</span><span class="xml">
    <span class="hljs-comment">&lt;!-- Twitter meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;twitter:card&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;summary&quot;</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- Open Graph meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ title or default_title }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ desc or default_desc }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:site_name&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;豆瓣(手机版)&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:url&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ url or default_url }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:type&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;image/png&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:width&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;300&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:image:height&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;300&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;og:type&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ type or default_type }&quot;</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- Wechat meta --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:timeline_title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_timeline_title or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:chat_title&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_chat_title or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ wechat_desc or &#39;&#39; }&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">property</span>=<span class="hljs-value">&quot;weixin:image&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;${ image or default_image }&quot;</span> /&gt;</span>
    </span>&lt;%<span class="perl">block filter=<span class="hljs-string">&quot;collect_js&quot;</span>&gt;
    ;(function () {
        window.setMeta = function (name, val) {
          var meta = document.querySelectorAll(<span class="hljs-string">&#39;meta[property=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;], meta[name=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;]&#39;</span>)
          <span class="hljs-keyword">if</span> (!meta.<span class="hljs-keyword">length</span>) {
            meta = document.createElement(<span class="hljs-string">&#39;meta&#39;</span>)
            meta.name = name
            document.head.appendChild(meta)
          }
         meta[<span class="hljs-number">0</span>].content = val || <span class="hljs-string">&#39;&#39;</span>
        }
        window.getMeta = function (name) {
          var meta = document.querySelectorAll(<span class="hljs-string">&#39;meta[property=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;], meta[name=&quot;&#39;</span> + name + <span class="hljs-string">&#39;&quot;]&#39;</span>)
          <span class="hljs-keyword">if</span> (!meta.<span class="hljs-keyword">length</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;&#39;</span>
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> meta[<span class="hljs-number">0</span>].content
          }
        }
        setMeta(<span class="hljs-string">&#39;og:url&#39;</span>, location.href)
        !getMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>, document.title)
        !getMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>, document.title)
        !getMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>) &amp;&amp; setMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>, getMeta(<span class="hljs-string">&#39;og:description&#39;</span>))
    })();
    &lt;<span class="hljs-regexp">/%block&gt;
&lt;/</span><span class="hljs-variable">%def</span>&gt;</span></code></pre><h4 id="2-m-seo-meta-tags">2. 给 m 站大部分页面增加了 SEO Meta Tags</h4>
<p>之前分享出去抓不到自定义的 description 和 image ，现默认分享到 weixin 的 title 、 description 、image 值都和 Open Graph 一样，也可以自定义。</p>
<p>默认情况下</p>
<ul>
<li><code>og:title</code>， <code>og:description</code> 和之前的 title, description 一样；</li>
</ul>
<ul>
<li><code>og:url</code> ： 当前页面 url；</li>
<li><code>og:image</code>：<ul>
<li>小组帖子页和单个日记页如有图片，则为第一张图片的 src url，没有的话为现在默认的分享 icon src url；</li>
<li>条目页的均为该条目的 image src url；</li>
<li>相册页为该相册第一张 image src；</li>
<li>豆列、标签页为默认的分享 icon src</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Hashtag 页</strong></p>
<ul>
<li>image: 运营头图 || 豆 icon；</li>
<li>title: { hashtag_name} - 豆瓣；</li>
<li>description: 运营描述 || &#39;有关#{ hashtag_name }#的话题讨论，豆瓣用户参与的精彩话题&#39;；</li>
</ul>
</li>
<li><p><strong>单条广播页</strong></p>
<ul>
<li>微信聊天、朋友圈：image =  广播第一张图 || 豆 icon；</li>
<li>微信聊天页： title = XXX 的豆瓣广播; description = 广播文字内容的前十五个字 || 默认的 m 站描述；</li>
<li>微信朋友圈： title = 广播文字内容前十五个字 || XXX 的豆瓣广播</li>
</ul>
</li>
<li><p>关于 image 图片规格：</p>
<p>为了使抓取的图片更优雅，不被压缩变形，使用「七牛图片服务」进行剪裁。</p>
<p>默认 <code>og:image</code> 等 image 均会被以 <code>width = height = 300</code> 进行处理。</p>
<ul>
<li><a href="http://github.intra.douban.com/frodo/Talion/tree/23fe149cc3186f15195634cca774861d3ce9efca">Talion</a>/<a href="http://github.intra.douban.com/frodo/Talion/tree/23fe149cc3186f15195634cca774861d3ce9efca/libs">libs</a>/<strong>image.py</strong></li>
<li><a href="http://github.intra.douban.com/frodo/Talion/blob/23fe149cc3186f15195634cca774861d3ce9efca/libs/image.py#L11">http://github.intra.douban.com/frodo/Talion/blob/23fe149cc3186f15195634cca774861d3ce9efca/libs/image.py#L11</a></li>
<li><code>from douban.image.qiniu import qiniu_proxy_url</code></li>
</ul>
<p>​</p>
</li>
</ul>
<p>效果截屏：</p>
<p><a href="http://github.intra.douban.com/frodo/Talion/pull/253">http://github.intra.douban.com/frodo/Talion/pull/253</a></p>
<h4 id="3-">3. 统一分享接口（微信重度使用患者）</h4>
<ul>
<li><a href="http://github.intra.douban.com/frodo/Talion/blob/master/static/js/card/weixin.js#L52">weixin.js</a>、 <a href="https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html#.E5.88.86.E4.BA.AB.E6.8E.A5.E5.8F.A3">微信 JSSDK 文档</a></li>
</ul>
<pre class="hljs"><code>
wx.onMenuShareTimeline($.extend({}, shareData,{
    title: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:timeline_title&#39;</span>) || <span class="hljs-built_in">document</span>.title,
    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        wxShareStat.target = <span class="hljs-string">&#39;timeline&#39;</span>;
        $.get(<span class="hljs-string">&#39;/j/wechat/shared&#39;</span>, wxShareStat);
    },
    cancel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
}));

wx.onMenuShareAppMessage($.extend({}, shareData,{
    title: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:chat_title&#39;</span>) || <span class="hljs-built_in">document</span>.title,
    desc: <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;weixin:description&#39;</span>) || <span class="hljs-built_in">window</span>.getMeta(<span class="hljs-string">&#39;og:description&#39;</span>),
    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        wxShareStat.target = <span class="hljs-string">&#39;friend&#39;</span>;
        $.get(<span class="hljs-string">&#39;/j/wechat/shared&#39;</span>, wxShareStat);
    },
    cancel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
}));</code></pre><p>  结合使用 <code>meta[name=&quot;weixin:image&quot;]</code></p>
<pre class="hljs"><code>&lt;meta property=<span class="hljs-string">&quot;weixin:timeline_title&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_timeline_title <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
&lt;meta property=<span class="hljs-string">&quot;weixin:chat_title&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_chat_title <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
&lt;meta property=<span class="hljs-string">&quot;weixin:description&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ wechat_desc <span class="hljs-keyword">or</span> <span class="hljs-string">&#39;&#39;</span> }</span>&quot;</span> /&gt;
&lt;meta property=<span class="hljs-string">&quot;weixin:image&quot;</span> content=<span class="hljs-string">&quot;<span class="hljs-subst">${ image <span class="hljs-keyword">or</span> default_image }</span>&quot;</span> /&gt;</code></pre><ul>
<li><p>自定义微信分享到聊天、朋友圈的显示内容，文案<code>setMeta()</code>, <code>getMeta()</code></p>
</li>
<li><p><strong>Tips:</strong> 如果没有设置 <code>wx.onMenuShareTimeline()</code>/ <code>wx.onMenuShareAppMessage()</code> 中的 title / imgUrl / desc 参数，微信内置浏览器默认抓取对应的<code>og:xxx</code> 相关。</p>
</li>
<li><p><strong>Bugs:</strong> 通过 Safari Extension 分享出来的永远抓的是 <code>apple-touch-icon</code> 😂</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">&quot;<a href="https://img3.doubanio.com/f/talion/315ba4fc82e5cdb5c50ef1d9f88c8aa2c5c0c4ba/pics/icon/m_logo_76.png">https://img3.doubanio.com/f/talion/315ba4fc82e5cdb5c50ef1d9f88c8aa2c5c0c4ba/pics/icon/m_logo_76.png</a>&quot;</span>&gt;</span></code></pre><p>微信分享效果图：
<img src="&#39;/content/images/seo_in_mobile/seo_1.png&#39;" alt="after_seo_1">
<img src="&#39;/content/images/seo_in_mobile/seo_2.png&#39;" alt="after_seo_2">
<img src="&#39;/content/images/seo_in_mobile/seo_3.png&#39;" alt="after_seo_3"></p>
<h3 id="further-reading-resource">Further Reading &amp; Resource</h3>
<ol>
<li>Sitemap &amp; <a href="http://baiduseoguide.com/news/20141128113.html">Deadlink</a></li>
<li>Social Meta Tag Cheatsheet</li>
<li>Google SEO TOP1: Baidu Baike 😂</li>
<li><a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/MetaTags.html">Apple Safari supported meta tags</a></li>
<li><a href="http://static.googleusercontent.com/media/www.google.com/en//webmasters/docs/search-engine-optimization-starter-guide.pdf">Google SEO search-engine-optimization-starter-guide</a></li>
<li>Google 结构化数据标记辅助工具</li>
<li><a href="http://www.hobo-web.co.uk/seo-tutorial/">SEO Tutorial</a></li>
<li><a href="http://www.ghugo.com/jd-seo/">京东 SEO</a></li>
<li>SEO Tools<ul>
<li><a href="https://www.google.com/webmasters/">Google Webmasters Search Console</a></li>
<li><a href="https://varvy.com/tools/">Varvy SEO tool</a></li>
<li><a href="http://keywordtool.io/">Keyword Tool</a></li>
</ul>
</li>
</ol>
]]></description><link>/2016-05-20-seo-in-mobile/index.html</link><guid isPermaLink="true">/2016-05-20-seo-in-mobile/index.html</guid><category><![CDATA[SEO]]></category><category><![CDATA[shares]]></category><category><![CDATA[tech]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Thu, 19 May 2016 18:21:00 GMT</pubDate></item></channel></rss>