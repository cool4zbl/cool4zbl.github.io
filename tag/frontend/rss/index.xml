<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[undefined - ZBL's Doodle]]></title><description><![CDATA[Thoughts, ideas]]></description><link>http://zhangbinliu.me/</link><generator>Ghost</generator><lastBuildDate>Fri, 04 Aug 2017 06:03:47 GMT</lastBuildDate><atom:link href="http://zhangbinliu.me/tag/undefined/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[从十个 React 迷你设计模式谈开去]]></title><description><![CDATA[<p>很早之前就一直在读的一篇文章，<a href="https://hackernoon.com/10-react-mini-patterns-c1da92f068c5">10 个React Mini 设计模式</a>，
一边做 <code>Creator</code> 项目，也一边终于把它精读完。
结合自己的开发时候的项目经验，做了点笔记。
<code>Creator</code> 项目是一个多端（Web + Mobile）React SPA，且有一些表单填写和复杂的交互组件，自己单独封装了一个很简单的基于事件的 <code>Store</code>，开发过程中收获很大，这些细节之后可以细说。</p>
<p>原文作者说你是不是天天写 React, 写着写着发现自己可能经常用来实现需求的，也总是那么几个方法，往大了讲其实就是开发中的 <strong>设计模式</strong>。但是这里我们称为 <strong>Mini Patterns</strong>。</p>
<h2 id="-1-sending-data-down-and-up">#1 Sending data down and up</h2>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*J5XOQh2WKIl0NFTAMvcVbQ.png" alt="Data-flow"></p>
<ul>
<li>React 数据流</li>
<li>ParentComponent  通过 <code>props</code> 传给 ChildComponent 值</li>
<li>ChildComponent 通过 <code>props</code> 传过来的一些 function 回调 parent 的一些方法。</li>
</ul>
<h2 id="-2-fixing-html-s-inputs">#2 Fixing HTML’s inputs</h2>
<blockquote>
<p>If I’m building a site that will have a lot of user inputs, one of the first things I do is fix this.</p>
<p>You don’t need to keep working with the somewhat ass-about nature of HTML’s user input elements.</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/800/1*WTUJjlFOOnetc5NpbykN0w.png" alt="User Inputs"></p>
<ul>
<li><p>如果需要有大量 user inputs，最好是自己实现一套相关组件。</p>
</li>
<li><p>所以在 Creator 中基本自己实现了 <code>input</code>，<code>Select</code> 等组件。需求简单所以实现得也是很简单。所以其实 <code>Select</code> 组件仍然需要优化，比如自定义 <code>option</code> 样式，多选等等。</p>
</li>
<li><p>Inputs should return a value via an <code>onChange</code> method, not a JavaScript <code>Event</code> instance, shouldn’t they?</p>
</li>
<li><p>Input 最好通过 <code>onChange</code> 返回一个值，而不是通过一个 JS <code>Event</code> 实例。</p>
</li>
<li><p>You can go a step further and ensure that the data type returned in <code>onChange</code> matches the type passed in. If the <code>typeof props.value</code> is <code>number</code>, then convert <code>e.target.value</code> back to a number before sending the data out again.</p>
</li>
<li><p>在返回 <code>onChange</code> 的值之前确保一下是不是和输入的类型匹配。比如 <code>typeof props.value === &#39;number&#39;</code> 的话，在返回 <code>e.target.value</code> 前需要确保也是数字类型。</p>
</li>
<li><p>这里项目中有个选择证件类型的 <code>Select</code>，与后端默认 身份证 = 0 / 护照 = 1，但是在 <code>e.target.value</code> 时候忘记 convert 了。所以还是需要记得判断下 <code>option</code> 的值类型。</p>
<pre class="hljs"><code>let {<span class="hljs-keyword">name</span>, <span class="hljs-keyword">value</span>} = e.<span class="hljs-type">target</span>
<span class="hljs-keyword">value</span> = isNaN(<span class="hljs-keyword">Number</span>(<span class="hljs-keyword">value</span>)) ? <span class="hljs-keyword">value</span> : <span class="hljs-keyword">Number</span>(<span class="hljs-keyword">value</span>)</code></pre><p>​</p>
</li>
<li><p>A set of radio buttons is functionally the same thing as a <code>&lt;select&gt;</code>, right? It’s messed up to treat them in a completely different manner when the only difference is the UI. Maybe for your app it makes sense to have a single <code>&lt;PickOneFromMany /&gt;</code> component and pass either <code>ui=&quot;radio&quot;</code> or <code>ui=&quot;dropDown&quot;</code>.</p>
</li>
<li><p>一堆单选按钮在功能上和一个 <code>&lt;select&gt;</code> 组件是一样的。没有必要把它们完全不一样地来对待，因为它们仅仅是 UI 不一样。其实可能只需要一个 <code>&lt;PickOneFromMany /&gt;</code> 组件就好，通过 <code>ui=&quot;radio&quot;</code> 或者<code>ui=&quot;dropdown&quot;</code> 来区分。</p>
</li>
<li><p><strong>React Form 与 HTML 的不同</strong></p>
</li>
<li><p><code>value/checked</code> 设置后用户输入无效，相当于设置了 value -&gt; controlled component.</p>
</li>
<li><p><code>textarea</code> 的值要设置在 value 属性</p>
</li>
<li><p><code>select</code> 的<code>value</code> 属性可以是数组，不建议使用 <code>option</code> 的 <code>selected</code> 属性</p>
</li>
<li><p><code>input/textarea</code> 的 <code>onChange</code> 每次输入都会触发，即使不失去焦点</p>
</li>
<li><p><code>radio/checkbox</code>  点击后触发 `onChange</p>
</li>
</ul>
<h2 id="-3-binding-labels-to-inputs-with-unique-ids">#3 Binding labels to inputs with unique IDs</h2>
<blockquote>
<p>if you care about your users, you’ll bind your <code>&lt;label&gt;</code> elements to your <code>&lt;input&gt;</code>s via an <code>id</code>/<code>for</code> combo.</p>
<p>You <em>could</em> generate a random ID for each input/label pair, but then your client-rendered HTML won’t match your server-rendered HTML. Checksum error! That’s no good.</p>
<p>So, instead you can create a little module that gives an incrementing ID, and use that in an <code>Input</code> component like so:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">// Input Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.id = getNextId();

    <span class="hljs-keyword">this</span>.onChange = <span class="hljs-keyword">this</span>.onChange.bind(<span class="hljs-keyword">this</span>);
  }

  onChange(e) {
    <span class="hljs-keyword">this</span>.props.onChange(e.target.value);
  }

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;label htmlFor={<span class="hljs-keyword">this</span>.id}&gt;
        {<span class="hljs-keyword">this</span>.props.label}

        &lt;input
          id={<span class="hljs-keyword">this</span>.id}
          value={<span class="hljs-keyword">this</span>.props.value}
          onChange={<span class="hljs-keyword">this</span>.onChange}
          /&gt;
      &lt;/label&gt;
    );
  }
}

<span class="hljs-comment">// elementIdCreator.js</span>
let count = <span class="hljs-number">1</span>;

export const resetId = () =&gt; {
  count = <span class="hljs-number">1</span>;
}

export const getNextId = () =&gt; {
  <span class="hljs-keyword">return</span> <code>element-id-${count++}</code>;
}</code></pre><ul>
<li>这里大概是自动给 <code>label</code>/<code>input</code> 加上一对一的 id.</li>
<li>Creator 中好像没有这样使用。</li>
</ul>
<h2 id="-4-controlling-css-with-props">#4 Controlling CSS with props</h2>
<p>Three distinct ways to control the CSS applied to a component.</p>
<ol>
<li><p>Using themes. (Used in Proj Creator)</p>
<p><code>&lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt;</code></p>
<p>Tip: Do your best to only require one theme per component.</p>
<p>这种可能适合页面主题定制化。</p>
<p>Creator 中的 <code>&lt;Button /&gt;</code> 本来是用 theme 做区分，但是好像设计那边看起来就是一个主题，豆瓣绿经典款，所以后来改为了使用下面两种方式。</p>
<p>​</p>
</li>
<li><p>Using flags. (Used too.)</p>
<p><code>&lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt;</code></p>
<p>Creator Project:</p>
<p>```jsx
Button.propTypes = {
  size: PropTypes.oneOf([</p>
<pre class="hljs"><code><span class="hljs-string">&#39;sm&#39;</span>,
<span class="hljs-string">&#39;md&#39;</span>,
<span class="hljs-string">&#39;lg&#39;</span>,
<span class="hljs-string">&#39;row&#39;</span></code></pre><p>  ]),
  status: PropTypes.oneOf(Object.values(BUTTON_STATUS)),
  type: PropTypes.oneOf([</p>
<pre class="hljs"><code><span class="hljs-string">&#39;submit&#39;</span>,
<span class="hljs-string">&#39;save&#39;</span>,
<span class="hljs-string">&#39;cancel&#39;</span>
])</code></pre><p>}</p>
</li>
</ol>
<p>   // use className to control styles</p>
<pre class="hljs"><code> <span class="hljs-keyword">const</span> cls = classNames(<span class="hljs-string">&#39;btn&#39;</span>, {
   [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn</code></span>]: <span class="hljs-literal">true</span>,
   [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${size}&lt;/span&gt;</code></span>]: !!size,
   [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${status}&lt;/span&gt;</code></span>]: !!status,
   [<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${prefixCls}&lt;/span&gt;-btn-&lt;span class=&quot;hljs-subst&quot;&gt;${type}&lt;/span&gt;</code></span>]: !!type
 }, props.className)</code></pre><pre class="hljs"><code>
   ​

<span class="hljs-number">3.</span> Setting values.

   Pass the <span class="hljs-keyword">value</span> of a CSS property directly. (<span class="hljs-keyword">set</span> it <span class="hljs-keyword">as</span> an inline style)

   <code>&amp;lt;Icon width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;25&quot;&lt;/span&gt; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;25&quot;&lt;/span&gt; type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;search&quot;&lt;/span&gt; /&amp;gt;</code>

   <span class="hljs-preprocessor">### An example</span>

   <img src="https:&lt;span class=&quot;hljs-comment&quot;&gt;//cdn-images-1.medium.com/max/800/1*Kx1jOQONhFZPnGe72Fd4tQ.png" alt="creating-a-link-component"></span>

   <code>``jsx
   &lt;span class=&quot;hljs-comment&quot;&gt;// Link.js&lt;/span&gt;
   &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Link = (props) =&amp;gt; {
     &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; className =</code>link link--${props.theme}-theme`;

     <span class="hljs-keyword">if</span> (!props.underline) className += <span class="hljs-string">&#39; link--no-underline&#39;</span>;

     <span class="hljs-keyword">return</span> &lt;a href={props.href} className={className}&gt;{props.children}&lt;/a&gt;;
   };

   Link.propTypes = {
     theme: PropTypes.oneOf([
       <span class="hljs-string">&#39;default&#39;</span>, <span class="hljs-comment">// primary color, no underline</span>
       <span class="hljs-string">&#39;blend&#39;</span>, <span class="hljs-comment">// inherit surrounding styles</span>
       <span class="hljs-string">&#39;primary-button&#39;</span>, <span class="hljs-comment">// primary color, solid block</span>
     ]),
     underline: PropTypes.<span class="hljs-keyword">bool</span>,
     href: PropTypes.<span class="hljs-keyword">string</span>.isRequired,
     children: PropTypes.oneOfType([
       PropTypes.element,
       PropTypes.array,
       PropTypes.<span class="hljs-keyword">string</span>,
     ]).isRequired,
   };

   Link.defaultProps = {
     theme: <span class="hljs-string">&#39;default&#39;</span>,
     underline: <span class="hljs-keyword">false</span>,
   };</code></pre><pre class="hljs"><code>   <span class="hljs-comment">// Link.css</span>
   <span class="hljs-class">.link--default-theme</span>,
   <span class="hljs-class">.link--blend-theme</span><span class="hljs-pseudo">:hover</span> {
     <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#D84315</span>;
   }

   <span class="hljs-class">.link--blend-theme</span> {
     <span class="hljs-attribute">color</span>: inherit;
   }

   <span class="hljs-class">.link--default-theme</span><span class="hljs-pseudo">:hover</span>,
   <span class="hljs-class">.link--blend-theme</span><span class="hljs-pseudo">:hover</span> {
     <span class="hljs-attribute">text-decoration</span>: underline;
   }

   <span class="hljs-class">.link--primary-button-theme</span> {
     <span class="hljs-attribute">display</span>: inline-block;
     <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span> <span class="hljs-number">25px</span>;
     <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;
     <span class="hljs-attribute">background</span>: <span class="hljs-hexcolor">#D84315</span>;
     <span class="hljs-attribute">color</span>: white;
   }

   <span class="hljs-class">.link--no-underline</span> {
     <span class="hljs-attribute">text-decoration</span>: none;
   }</code></pre><p>   ​</p>
<blockquote>
<p>JavaScript is easy, but with CSS you pay for your sins — once you’ve started a mess, it’s not easy to back out of.</p>
<p>True fact: fighting CSS specificity is the number one cause of death among web developers.</p>
</blockquote>
<p>   嗯，这里原文作者用 CSS specificity 优先级举了个例子。比如他说你现在可以去看看 medium 顶端导航上大 Title 的CSS 样式，</p>
<blockquote>
<p>just guess how many CSS rules are combined to make this round circle with a number in it?</p>
<p>Twenty three rules.</p>
<p>That’s <em>not </em>including the styles inherited from eleven other rules.</p>
<p>The line-height alone is overridden nine times.</p>
</blockquote>
<p>   光是 <code>line-height</code> 特么的就重写了九次！！！</p>
<p>   <img src="https://cdn-images-1.medium.com/max/800/1*lQzlIf8PPqeLUS5VOvTH4Q.png" alt="line-height-css-rules"></p>
<p>   ​</p>
<p>   这 line-height 要是一只猫的话，现在也早死了吧。</p>
<p>   React 的话，就好办了。</p>
<ul>
<li>控制组件的 classes ；</li>
<li>移掉所有的全局 resets 然后都把它们扔到 Button.scss 中；</li>
<li>可以用 <code>all: unset</code> 去掉所有浏览器初始样式。</li>
</ul>
<h2 id="-5-the-switching-component">#5 The switching component</h2>
<p>The switching component, rendering one of many components.</p>
<blockquote>
<p>This may be a <code>&lt;Page&gt;</code> component that displays one of many pages. Or tabs in a tab set, or different modals in a modal component.</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">import</span> HomePage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./HomePage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> AboutPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./AboutPage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> UserPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./UserPage.jsx&#39;</span>;
<span class="hljs-keyword">import</span> FourOhFourPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./FourOhFourPage.jsx&#39;</span>;

<span class="hljs-keyword">const</span> PAGES = {
  home: HomePage,
  about: AboutPage,
  user: UserPage,
};

<span class="hljs-keyword">const</span> Page = (props) =&gt; {
  <span class="hljs-keyword">const</span> Handler = PAGES[props.page] || FourOhFourPage;

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Handler</span> {<span class="hljs-attribute">...props</span>} /&gt;</span>
};

Page.propTypes = {
    page: PropTypes.oneOf(Object.keys(PAGES)).isRequired,
};

// Usage

<span class="hljs-tag">&lt;<span class="hljs-title">Page</span> <span class="hljs-attribute">page</span>=<span class="hljs-value">&quot;home&quot;</span> /&gt;</span></span></code></pre><p>If you replace the keys <code>home</code>, <code>about</code> and <code>user</code> with <code>/</code>, <code>/about</code>, and <code>/user</code>, you’ve got yourself half a router.</p>
<p>(Future post idea: removing <code>react-router</code>.)</p>
<p>这里 Creator 中还是使用了 <code>react-router</code> 作为 SPA 路由。</p>
<pre class="hljs"><code><span class="hljs-regexp">//</span> Route.jsx
import React from <span class="hljs-string">&#39;react&#39;</span>
import IntroPage from <span class="hljs-string">&#39;../Page/IntroPage&#39;</span>
import ApplyFormPage from <span class="hljs-string">&#39;../Page/ApplyFormPage&#39;</span>
import AddWorksPage from <span class="hljs-string">&#39;../Page/AddWorksPage&#39;</span>
import ApplyDonePage from <span class="hljs-string">&#39;../Page/ApplyDonePage&#39;</span>
import MyWorksPage from <span class="hljs-string">&#39;../Page/MyWorksPage&#39;</span>

const defaultHeader = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &lt;h1&gt;创作者认证申请&lt;/h1&gt;
const routes = [
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/&#39;</span>,
    <span class="hljs-attribute">exact</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;IntroPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/intro&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;IntroPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step1&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;ApplyFormPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step2&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;AddWorksPage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/apply/step3&#39;</span>,
    <span class="hljs-attribute">header</span>: defaultHeader,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;ApplyDonePage /&gt;)
  },
  { <span class="hljs-attribute">path</span>: <span class="hljs-string">&#39;/myworks&#39;</span>,
    <span class="hljs-attribute">header</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &lt;h1&gt;管理我的作品&lt;/h1&gt;,
    <span class="hljs-attribute">main</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&lt;MyWorksPage /&gt;)
  }
]
export default routes</code></pre><pre class="hljs"><code>// App.js
import {
  HashRouter,
  Route
} from &#39;react-router-dom&#39;
import routes from &#39;./Route&#39;

const App = () =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-title">HashRouter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;App&#39;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">&#39;creator-wrapper&#39;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;header&#39;</span>&gt;</span>
          { routes.map((route, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-title">Route</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{index}</span> <span class="hljs-attribute">path</span>=<span class="hljs-value">{route.path}</span>
              <span class="hljs-attribute">exact</span>=<span class="hljs-value">{route.exact}</span>
              <span class="hljs-attribute">component</span>=<span class="hljs-value">{route.header}</span>
            /&gt;</span>
          )) }
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">&#39;main&#39;</span>&gt;</span>
          { routes.map((route, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-title">Route</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{index}</span> <span class="hljs-attribute">path</span>=<span class="hljs-value">{route.path}</span>
              <span class="hljs-attribute">exact</span>=<span class="hljs-value">{route.exact}</span>
              <span class="hljs-attribute">component</span>=<span class="hljs-value">{route.main}</span> /&gt;</span>
          )) }
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        { isMobile ? Footer() : Sidebar() }
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">HashRouter</span>&gt;</span>
)</code></pre><h2 id="-6-reaching-into-a-component">#6 Reaching into a component</h2>
<h3 id="render">render</h3>
<p>React Virtual DOM ==&gt; render= =&gt; DOM</p>
<pre class="hljs"><code>ReactComponent render(
  ReactElement <span class="hljs-keyword">element</span>,
  DOMElement container,
  [<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>]</span>
)</code></pre><blockquote>
<p>Render a ReactElement into the DOM in the supplied <code>container</code> and return a <a href="more-about-refs.html">reference</a> to the component (or returns <code>null</code> for <a href="reusable-components.html#stateless-functions">stateless components</a>).</p>
<p><code>ReactDOM.render()</code> controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React’s DOM diffing algorithm for efficient updates.</p>
</blockquote>
<ul>
<li><code>ReactElement</code> into DOM.</li>
<li>有状态组件 =&gt; <code>refs</code>，无状态组件 =&gt; <code>null</code></li>
<li>组件初次渲染之后再次更新，会使用 ReactDOM diffing algorithm</li>
<li>装载完后，执行回调 callback</li>
<li><code>ReactDOM.render()</code> 不会影响 container node，只会影响 container node 的 children nodes. （可能是被覆盖替换啊..）</li>
</ul>
<pre class="hljs"><code>const myApp = &lt;App /&gt;   <span class="hljs-comment">// just a ReactElement.(a object)</span>

const myAppInstance = ReactDOM.<span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">(&lt;App /&gt;, document.getElementById(<span class="hljs-string">&#39;root&#39;</span>)</span></span>)
myAppInstance.<span class="hljs-function"><span class="hljs-title">doSth</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// The ref returned from ReactDOM.render</span></code></pre><p>这里利用 <code>render</code> 方法得到了 App 组件的实例，就可以使用它做点什么了。</p>
<p>但是如果在组件内，JSX 并不会返回一个组件的实例。组件内只是一个 ReactElement，告诉 React 加载的组件应该长什么样。</p>
<blockquote>
<p>Keep in mind, however, that the JSX doesn&#39;t return a component instance! It&#39;s just a <strong>ReactElement</strong>: a lightweight representation that tells React what the mounted component should look like.</p>
</blockquote>
<h3 id="ref">ref</h3>
<p>一个神奇的属性。</p>
<h4 id="the-ref-callback-attribute">The ref Callback Attribute</h4>
<ul>
<li>可以给任意 React 组件加上 <code>ref</code> prop. 组件被调用时候会新建一个该组件实例，而 <code>ref</code> 会指向这个实例。</li>
</ul>
<ul>
<li><p>可以是一个 callback function，会在组件加载后立即执行。</p>
<pre class="hljs"><code>// <span class="hljs-type">ES5</span>

render: function() {
  <span class="hljs-keyword">return</span> (
    &lt;<span class="hljs-type">TextInput</span>
      <span class="hljs-keyword">ref</span>={function(input) {
        <span class="hljs-keyword">if</span> (input != null) {
          input.focus();
        }
      }} /&gt;
  );
},

// <span class="hljs-keyword">or</span> <span class="hljs-type">ES6</span> arrow function way:
render() {
  <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">TextInput</span> <span class="hljs-keyword">ref</span>={ c =&gt; this._input = c } /&gt;
}
componentDidMount() {
  this._input.focuse()
}</code></pre><p>​</p>
</li>
</ul>
<blockquote>
<p> When attaching a ref to a DOM component like <code>&lt;div /&gt;</code>, you get the DOM node back; when attaching a ref to a composite component like <code>&lt;TextInput /&gt;</code>, you&#39;ll get the React class instance.</p>
</blockquote>
<ul>
<li><code>refs</code> in <code>ReactComponent</code> =&gt; 得到 ReactComponent 实例，就可以调用相关实例方法了（继续 findDOMNode(refs) 就可以得到 DOM 节点，使用 DOM 方法）。</li>
<li><code>refs</code> in <code>DOM</code>  =&gt; 得到 DOM 节点，就可以使用 DOM 方法。</li>
<li><em>Note:</em> Note that when the referenced component is unmounted and whenever the ref changes, the old ref will be called with <code>null</code> as an argument. This prevents memory leaks in the case that the instance is stored, as in the first example. Also note that when writing refs with inline function expressions as in the examples here, React sees a different function object each time so on every update, ref will be called with <code>null</code> immediately before it&#39;s called with the component instance.</li>
<li>为防止内存泄露，当引用组件被卸载或者 <code>ref</code> 改变的时候，<code>ref = null</code>.</li>
<li>如果用 inline function，因为每次都是一个不同的 function object，所以当组件每次更新的时候，<code>ref</code> 都会被设置为 <code>null</code> 直到组件实例再次调用它。</li>
</ul>
<h4 id="the-ref-string-attribute-legacy">The ref String Attribute *legacy</h4>
<p>要获取一个 React 组件的引用，既可以使用 this 来获取当前 ReactComponent，也可以使用 <code>ref</code> 来获取子组件的引用。</p>
<pre class="hljs"><code>&lt;input <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;myInput&quot;</span> /&gt;

// used <span class="hljs-keyword">in</span> componentDidMount()
<span class="hljs-keyword">var</span> input = this.refs.myInput;
<span class="hljs-keyword">var</span> inputValue = input.value;
<span class="hljs-keyword">var</span> inputRect = input.getBoundingClientRect();</code></pre><h4 id="refs-">refs 使用</h4>
<ul>
<li>DOM 操作</li>
</ul>
<blockquote>
<p>Performing DOM measurements almost always requires reaching out to a &quot;native&quot; component such as <code>&lt;input /&gt;</code> and accessing its underlying DOM node using a ref. Refs are one of the only practical ways of doing this reliably.</p>
</blockquote>
<ul>
<li>对于 <code>stateless component</code>， <code>findDOMNode()</code> &amp; <code>ref</code> 返回的都是 <code>null</code>，因为它只是函数执行，并不返回一个实例 <code>a backing instance</code>。要用的话只能自己去手动包一层 component.</li>
</ul>
<h4 id="an-example">An example</h4>
<p>Like adding <code>autofucus</code> to the input to pease your users in an easy way.</p>
<p>The React Way</p>
<pre class="hljs"><code><span class="hljs-comment">// Child Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Compnent</span> {</span>
  focus() {
    <span class="hljs-keyword">this</span>.input.focus()
  }
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;input ref={(el)=&gt; <span class="hljs-keyword">this</span>.input = el} /&gt;
    )
  }
}

<span class="hljs-comment">// Parent Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SignInModal</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Component</span> {</span>
  componentDidMount() {
    <span class="hljs-keyword">this</span>.<span class="hljs-type">InputComponent</span>.focus(); <span class="hljs-comment">// 拿到 Input 组件的引用，就可以调用 Input 组件方法</span>
  }

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;
        &lt;label&gt;<span class="hljs-type">User</span> name: &lt;/label&gt;
        &lt;<span class="hljs-type">Input</span>
          ref={comp =&gt; { <span class="hljs-keyword">this</span>.<span class="hljs-type">InputComponent</span> = comp; }}
        /&gt;
      &lt;/div&gt;
    )
  }
}</code></pre><h2 id="-7-almost-components">#7 Almost-components</h2>
<blockquote>
<p>Don’t prematurely componentize. Components aren’t like teaspoons; you <em>can </em>have too many.</p>
<p>What I am saying: “take something that you <em>don’t</em> think should be a component, and make it a bit more like its own component (if it can be).”</p>
</blockquote>
<p>让那些你认为不应该成为一个组件的东西，长得更像组件一点（如果它可以的话）。</p>
<h2 id="-8-components-for-formatting-text">#8 Components for formatting text</h2>
<p>用来格式化的组件，也就是组件也可以工具化。</p>
<pre class="hljs"><code><span class="hljs-comment">// Here’s a &lt;Price&gt; component that takes a number and returns a pretty string, with or without decimals and a ‘$’ sign.</span>

<span class="hljs-keyword">const</span> Price = (props) =&gt; {
    <span class="hljs-keyword">const</span> price = props.children.toLocaleString(<span class="hljs-string">&#39;en&#39;</span>, {
      style: props.showSymbol ? <span class="hljs-string">&#39;currency&#39;</span> : undefined,
      currency: props.showSymbol ? <span class="hljs-string">&#39;USD&#39;</span> : undefined,
      maximumFractionDigits: props.showDecimals ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>,
    });

    <span class="hljs-keyword">return</span> &lt;span className={props.className}&gt;{price}&lt;/span&gt;
};

Price.propTypes = {
  className: React.PropTypes.string,
  children: React.PropTypes.number,
  showDecimals: React.PropTypes.<span class="hljs-built_in">bool</span>,
  showSymbol: React.PropTypes.<span class="hljs-built_in">bool</span>,
};

Price.defaultProps = {
  children: <span class="hljs-number">0</span>,
  showDecimals: <span class="hljs-keyword">true</span>,
  showSymbol: <span class="hljs-keyword">true</span>,
};

<span class="hljs-keyword">const</span> Page = () =&gt; {
  <span class="hljs-keyword">const</span> lambPrice = <span class="hljs-number">1234.567</span>;
  <span class="hljs-keyword">const</span> jetPrice = <span class="hljs-number">999999.99</span>;
  <span class="hljs-keyword">const</span> bootPrice = <span class="hljs-number">34.567</span>;

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;p&gt;One lamb <span class="hljs-keyword">is</span> &lt;Price className=<span class="hljs-string">&quot;expensive&quot;</span>&gt;{lambPrice}&lt;/Price&gt;&lt;/p&gt;
      &lt;p&gt;One jet <span class="hljs-keyword">is</span> &lt;Price showDecimals={<span class="hljs-keyword">false</span>}&gt;{jetPrice}&lt;/Price&gt;&lt;/p&gt;
      &lt;p&gt;Those gumboots will <span class="hljs-literal">set</span> ya back &lt;Price showDecimals={<span class="hljs-keyword">false</span>} showSymbol={<span class="hljs-keyword">false</span>}&gt;{bootPrice}&lt;/Price&gt; bucks.&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre><p>这里当然可以很简单的用 less code function 来实现</p>
<pre class="hljs"><code><span class="hljs-comment">// could just easily use a function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberToPrice</span><span class="hljs-params">(num, options = {})</span> </span>{
    <span class="hljs-keyword">const</span> showSymbol = options.showSymbol !== <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">const</span> showDecimals = options.showDecimals !== <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">return</span> num.toLocaleString(<span class="hljs-string">&#39;en&#39;</span>, {
      style: showSymbol ? <span class="hljs-string">&#39;currency&#39;</span> : <span class="hljs-literal">undefined</span>,
      currency: showSymbol ? <span class="hljs-string">&#39;USD&#39;</span> : <span class="hljs-literal">undefined</span>,
      maximumFractionDigits: showDecimals ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>,
    });
}

<span class="hljs-keyword">const</span> Page = () =&gt; {
  <span class="hljs-keyword">const</span> lambPrice = <span class="hljs-number">1234.567</span>;
  <span class="hljs-keyword">const</span> jetPrice = <span class="hljs-number">999999.99</span>;
  <span class="hljs-keyword">const</span> bootPrice = <span class="hljs-number">34.567</span>;

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;p&gt;One lamb <span class="hljs-keyword">is</span> &lt;span className=<span class="hljs-string">&quot;expensive&quot;</span>&gt;{numberToPrice(lambPrice)}&lt;/span&gt;&lt;/p&gt;
      &lt;p&gt;One jet <span class="hljs-keyword">is</span> {numberToPrice(jetPrice, { showDecimals: <span class="hljs-literal">false</span> })}&lt;/p&gt;
      &lt;p&gt;Those gumboots will <span class="hljs-keyword">set</span> ya back {numberToPrice(bootPrice, { showDecimals: <span class="hljs-literal">false</span>, showSymbol: <span class="hljs-literal">false</span> })} bucks.&lt;/p&gt;
    &lt;/div&gt;
  );</code></pre><h2 id="-9-the-store-is-the-component-s-servant">#9 The store is the component’s servant</h2>
<p>用 <code>store</code> 来管理组件复杂度。</p>
<p>My suggestion:</p>
<ol>
<li>Work out the general structure of your components and the data they will require</li>
<li>Design your store to support those requirements</li>
<li>Do whatever you need to do to your incoming data to make it fit into the store.</li>
</ol>
<p>推荐使用单个模块来管理所有 Incoming data，所有的数据处理放在一起做，单元测试什么的也变简单了。</p>
<pre class="hljs"><code><span class="hljs-comment">// react/redux way</span>

<span class="hljs-tag">fetch</span>(<span class="hljs-built_in"><code>/api/search?${queryParams}</code></span>)
<span class="hljs-class">.then</span>(response =&gt; response.<span class="hljs-function">json</span>())
<span class="hljs-class">.then</span>(normalizeSearchResultsApiData) <span class="hljs-comment">// the do-it-all data massager</span>
<span class="hljs-class">.then</span>(normalData =&gt; {
    <span class="hljs-comment">// dispatch normalData to the store here</span>
});</code></pre><p><strong>这里推荐徐飞在 QCon 上分享的 <a href="https://zhuanlan.zhihu.com/p/26426054">单页引用的数据流方案探索</a></strong></p>
<h2 id="-10-importing-components-without-relative-paths">#10 Importing components without relative paths</h2>
<p>Turn</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../../../Button/Button.jsx&#39;</span>;
<span class="hljs-keyword">import</span> Icon <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../../../Icon/Icon.jsx&#39;</span>;
<span class="hljs-keyword">import</span> Footer <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;../../Footer/Footer.jsx&#39;</span>;</code></pre><p>Into</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {Button, Icon, Footer} <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;Components&#39;</span>;</code></pre><p>更灵活方便使用组件。</p>
<p>使用 <code>Webpack2</code> 可以直接配置</p>
<pre class="hljs"><code><span class="hljs-regexp">//</span> exports all components wherever they are
<span class="hljs-regexp">//</span> <span class="hljs-attribute">Ref</span>: Webpack <span class="hljs-built_in">require</span>.context
<span class="hljs-regexp">//</span> <span class="hljs-attribute">https</span>:<span class="hljs-regexp">//</span>webpack.github.io/docs/context.html

<span class="hljs-regexp">//</span> ./{xxx}/yyy/index.js =&gt; import { yyy } from <span class="hljs-string">&#39;components&#39;</span>
const req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#39;.&#39;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/.\/[^/</span>]+\<span class="hljs-regexp">/[^/</span>]+\<span class="hljs-regexp">/index.js$/</span>)

req.keys().forEach(<span class="hljs-function"><span class="hljs-params">(key)</span> =&gt;</span> {
  const componentName = key.replace(<span class="hljs-regexp">/^.+\/([^/</span>]+)\<span class="hljs-regexp">/index.js/</span>, <span class="hljs-string">&#39;$1&#39;</span>)
  <span class="hljs-built_in">module</span>.exports[componentName] = req(key).default
})</code></pre><p>Creator 中因为用的 <code>create-react-app</code> CLI，无法自己配置 Webpack，所以并没有用到...</p>
]]></description><link>/2017-06-28-10-react-mini-patterns-note/index.html</link><guid isPermaLink="true">/2017-06-28-10-react-mini-patterns-note/index.html</guid><category><![CDATA[notes]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Tue, 27 Jun 2017 16:00:00 GMT</pubDate></item><item><title><![CDATA[Fun with Codemod & AST]]></title><description><![CDATA[<h2 id="content">Content</h2>
<ul>
<li>背景</li>
<li>Codemod</li>
<li>jscodeshift</li>
<li>Demo Time</li>
<li>Refs</li>
</ul>
<hr>
<h2 id="-">背景</h2>
<p>作为一个自信而自豪的前端弄潮儿（F2E），我们总是希望能够在这个每天都在飞速迭代的行业，与时渐进。
前端们是一群不安分的人，大家喜爱新框架、新语法，而 JavaScript 也是一门非常灵活的语言，它提供给我们的 API 也在与时渐进。比如，当 <code>ES2015 ES2016 ES2017…</code> 出来的时候，那些新语法糖，简洁漂亮，且更易于理解逻辑，于是我们都想去尝试下。
但是尝试归尝试，对于新项目尝试起来成本很低，只需要把新功能都用新语法编写就好。
而创建新项目的同时，其实我们也在维护着一些已有的旧项目。如果你还并没怎么理它们，可能它们还活得不错。但是一旦 PM 心情好想加个新功能，或者你哪天心情好想去更新下代码库，然后看到自己之前写的那些代码，那些现在其实可以更优雅漂亮的代码，是不是手里特痒痒特想把它们更新了？
执行力强的前端儿可能说干就干了，嗯，就假设我们有个项目 Project，里面使用的是用<code>ES5</code> 版 <code>React</code> 作为 <code>UI View</code>。然后它大概四个页面<code>(Page)</code>，每个页面包含大概四个组件<code>(Component)</code>，然后你从某个看起来比较小、不容易出错的<code>Component</code> 入手，开始一行一行改写代码，嗯，<code>var React = require(&#39;react’)</code> 改为 <code>import React from &#39;react’</code>， <code>var API = ‘/j/app/xxx’</code> 改为 <code>const API = ‘/j/app/xxx’</code>，<code>var foo</code> 改为 <code>let foo</code>，<code>function () {…}</code> 改为 <code>() =&gt; {…}</code>，<code>module.exports = React.createClass({…})</code> 改为 <code>export default class MyComponent extends React.Component {…}</code> … 
天哪，有完没完，一个组件改完下来，你已经感到身体被掏空，望了望 <code>Components</code> 列表，更不用说，重新 <code>build</code> 过的测试还没过。你陷入了绝望...</p>
<p>那么有没有更快一点的办法呢？
稍微有点经验的前端儿可能想到「正则表达式匹配替换」。Bash <code>Awk | Sed</code> 命令，或者 Vim <code>:%s/var/let/g</code>。可是如果需要有些变量是 <code>const</code> 类型，有些是 <code>let</code>，而有些保持 <code>var</code> 不变怎么办？再比如说 </p>
<pre class="hljs"><code><span class="hljs-tag">merge</span>(a, {<span class="hljs-attribute">b</span>: <span class="hljs-number">1</span>}, c);  <span class="hljs-comment">// Old</span>

需要变为

({..<span class="hljs-class">.a</span>, <span class="hljs-tag">b</span>: <span class="hljs-tag">1</span>, ..<span class="hljs-class">.c</span>});  <span class="hljs-comment">// New</span></code></pre><p>这里光是这个函数的 <code>arguments</code> 就可能有多种形式，比如 <code>variable</code>，一个匿名函数返回的 Object 或者 <code>Plain Object</code> 那种。
这里相当于是一个 <code>Context-non-free</code> 的问题，也就是上下文语义很重要。
这样的话，无论再怎么强大的<code>RegExp</code> 也无能为力。因为正则的本质，其实是根据一定的 <code>Pattern</code> 来匹配字符串，但是在真正的代码里面，所有的字符串都有语义，都有上下文，这里的正则表达式会既复杂又无用。
所以，我们得换一个维度思考问题。</p>
<hr>
<h2 id="codemod">Codemod</h2>
<p>对「代码库的批量迁移更新」，其实也是程序员的一个需求，所以也感激地，已经有一群懒惰又聪明的程序员造出了工具：<code>Codemod</code>，将「大型仓库代码的批量迁移」自动化，省时省力。</p>
<p>好吧，所以 Codemod 到底是什么呢？
官方文档这样写着：</p>
<blockquote>
<p>Codemod is a tool/library to assist you with large-scale codebase refactors that can be partially automated but still require human oversight and occasional intervention.</p>
</blockquote>
<p>这样看来，可以很好的解决我们的需求了。
基于 Codemod，又出现了针对 JavaScript 代码迁移的工具 <a href="https://github.com/facebook/jscodeshift">Facebook jscoodeshift</a>，
基于 jscodeshift，又构建了迁移一般 JavaScript 代码（比如 ES5 -&gt; ES2015) 的工具 <a href="https://github.com/cpojer/js-codemod">js-codemod</a> 和迁移 React 相关项目的 <a href="https://github.com/reactjs/react-codemod">react-codemod</a>。</p>
<p>嗯，这么看来，我们的事情就变得容易多了。
根据上面那些工具的官方文档，我们只需要按顺序执行以下命令：</p>
<pre class="hljs"><code>&gt; npm i -g jscodeshift
&gt; git clone https:<span class="hljs-comment">//github.com/reactjs/react-codemod.git</span>
&gt; git clone https:<span class="hljs-comment">//github.com/cpojer/js-codemod.git</span>
&gt; jscodeshift -t react-codemod/transforms/<span class="hljs-keyword">class</span>.js --<span class="hljs-keyword">mixin</span>-<span class="hljs-keyword">module</span>-name=react-addons-<span class="hljs-keyword">pure</span>-render-<span class="hljs-keyword">mixin</span> --flow=<span class="hljs-literal">true</span> --<span class="hljs-keyword">pure</span>-component=<span class="hljs-literal">true</span> --remove-runtime-proptypes=<span class="hljs-literal">false</span> src/register/component/myComponent.jsx
&gt; jscodeshift -t js-codemod/transforms/no-vars.js ./src/register/component/myComponent.jsx</code></pre><p>然后，再次 <code>git status</code> 一下或者直接打开刚才 transform 的 <code>myComponent.jsx</code> 文件查看，你会发现，神奇般，你的代码都成为了它们应该成为的样子。</p>
<p>这里暂时以我之前做的 Accounts 项目为例：
<a href="https://github.intra.douban.com/accounts/accounts/pull/553/files#diff-b2286efdea6a62288250264e82bd948b">https://github.intra.douban.com/accounts/accounts/pull/553/files#diff-b2286efdea6a62288250264e82bd948b</a></p>
<ul>
<li>基本步骤如下：</li>
<li>因为是第一次使用 <code>codemod</code>，所以比较谨慎，一个一个 <code>component</code> 来；</li>
<li>先用 <code>react-codemod</code> 转，把大部头代码迁移；</li>
<li>然后 <code>js-codemod</code> 小步更新整理；</li>
<li>然后再根据一些自己的 Code Style 做些细节上的修改。比如使用 <code>standard-format</code> 工具格式化代码，符合我个人写的代码风格。</li>
<li>毕竟 JS 太过于灵活，每个人写代码时候风格和结构都是各异的，有时候的转换还是会出现一些与想象中不一致的结果，官方文档也是说仍然需要人工干预，所以会手动修改下代码细节；</li>
<li>一切组件迁移就绪，<code>npm run test</code> 测试通过以后，重新 <code>build</code> 运行</li>
</ul>
<p>这里我把已有的十几个组件和页面文件，全部使用上面的工具进行了更新。
然后当你重新 <code>build</code> 后，你会发现测试仍然通过，组件功能仍然 work，但是代码库却是使用新语法糖进行了大规模彻彻底底地更新！简直太神奇了！
那么，它是怎么做到的呢？</p>
<hr>
<h2 id="jscodeshift">jscodeshift</h2>
<p>让我们来重新读一下 jscodeshift 的<a href="https://github.com/facebook/jscodeshift#jscodeshift-">文档</a>。</p>
<blockquote>
<p>jscodeshift is a toolkit for running codemods over multiple JS files. It provides:</p>
</blockquote>
<ul>
<li>A runner, which executes the provided transform for each file passed to it. It also outputs a summary of how many files have (not) been transformed.</li>
<li>A wrapper around recast, providing a different API. Recast is an AST-to-AST transform tool and also tries to preserve the style of original code as much as possible.</li>
</ul>
<p>那么这里就出现了两个关键的概念：<em>Runner</em> 及 <em>AST</em>。</p>
<ul>
<li>Runner，</li>
<li><blockquote>
<p>A runner/worker feature that can apply transforms to thousands of files in parallel.
-- <a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.sg03sd9eq">CPojer Effective JavaScript Codemods</a></p>
</blockquote>
</li>
<li><p>AST，Abstract Syntax Tree，抽象语法分析树。</p>
</li>
</ul>
<p>为了更好理解以上概念，先来看一下之前运行 jscodeshift 命令过程。
我们先是把一个里面包含了 JS 代码的源文件传给了它，然后它读取了源代码，又根据写好的 <code>transform.js</code> 对源代码进行了相应的变换，最后输出了变换后的 JS 代码，覆盖了原文件。
简单的说，就是 
<code>SourceCode =&gt; codemod =&gt; ObjectCode</code></p>
<p>那么再详细一点，根据 jscodeshift 作者之一的 CPojer 在一次 JSConf 上对这个工具的介绍，jscodeshift 操作基本是按以下过程：
<code>Parse =&gt; Find =&gt; Create =&gt; Update =&gt; Print</code></p>
<ol>
<li>Parse: SourceCode =&gt; AST （Tree Nodes)</li>
<li>Find: Find the Nodes we want to replace         // Transform</li>
<li>Create: Create the New Nodes we want to insert  // Transform</li>
<li>Update: Update the AST at the right location    // Transform</li>
<li>Print: Print it back into JavaScript Source with proper formatting and should like human wrote this.</li>
</ol>
<h3 id="-parse-ast-">第一步，将源代码解析 (parse) 成 AST.</h3>
<p>我们知道自然语言（Natural Language)，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。
而在计算机编程语言 (Programming Language)，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。
不同的语言，都会配之不同的语法分析器(parser)。
对于自然语言，我们的大脑就是一个 Parser。对于编程语言，语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。</p>
<p>什么是语法树？摘自 Wiki 一段：</p>
<blockquote>
<p>计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>
</blockquote>
<p>这么说其实还是有点抽象，我们先打开 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">wiki</a> 看到 wikipedia 这个图，</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/9d7500be-f370-11e6-972f-f5ede1c448f8" alt="image"></p>
<p>前端er 一定会觉得很相似，这里不就是 DOM 语法树的终极抽象版本吗，只是把一个个 DOM Nodes 换成了一个个更加无语义的字符 Token。
FB 有一个很棒的工具 <a href="http://astexplorer.net/">ASTExplorer</a>，可以用来更形象地展示。</p>
<p>比如说，我们现在就只有一个很简单的表达式<code>a+b</code>，这里是 recast Parser 解析后的 AST 结构：</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/758a6076-f370-11e6-97e4-f6152c3814bf" alt="image"></p>
<p>看上去特别复杂。注意那些蓝色字体 <code>File</code>, <code>Programme</code>,<code>ExpressionStatement</code>,<code>Identifier</code>… 这些都是 AST Nodes，其他的都是和这个 Node 相关的数据。</p>
<p>根据前文可以知道，每种语言的 AST 都是不同的。有专门的 Parser 来生成 AST。</p>
<p>关于 <a href="https://en.wikipedia.org/wiki/Parsing#Parser">Parser</a> 又是一门很深的学问了。
在 ASTExplorer.net 上可以看到有很多 parser，比较著名的有 <a href="https://github.com/jquery/esprima/blob/master/src/parser.ts">Esprima(jQuery)</a>，Uglify-JS, Babylon(Babel), Acorn(Tern / Webpack), 及 jscodeshift 使用的 recast. 虽然有很多 Parser，但是基本上，一个 parser 的结构都差不多，对源代码进行词法分析，生成 Tokens，对 Tokens 进行语法分析，然后生成 AST。</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/5751ac04-f370-11e6-849e-692ab4b47bbf" alt="image"></p>
<p>具体可以参考看下 <a href="http://esprima.org/demo/parse.html#">Esprima Parse Demo</a>。
生成的 AST 都遵循一个统一标准 <a href="https://github.com/estree/estree/blob/master/es5.md">ESTree</a> or <a href="parser API https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API">Mozilla SpiderMonkey</a>，也就是说都会返回 ESTree Compatible AST.</p>
<h3 id="-ast-find-nodes-create-new-nodes-update-nodes-">第二三四步，对生成的 AST 进行操作修改 (Find Nodes &amp; Create New Nodes &amp; Update Nodes)</h3>
<p>Wiki 有介绍说，parse AST 的代码基本是使用<code>Visitor Pattern</code>，如：</p>
<pre class="hljs"><code><span class="hljs-comment">// recast</span>
<span class="hljs-keyword">var</span> ast = recast.parse(src);
recast.visit(ast, {
visitIdentifier: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(path)</span> </span>{
<span class="hljs-comment">// do something with path</span>
<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
});</code></pre><p>但是 js-codeshift 基于 <a href="https://github.com/facebook/jscodeshift#collections-and-traversal"><code>Collections</code></a> 概念，很贴心的给这些 Parser API 继续包了一层，提供了一个不一样的前端友好型 API.</p>
<pre class="hljs"><code><span class="hljs-comment">// jscodeshift</span>
  <span class="hljs-tag">jscodeshift</span>(src)
<span class="hljs-class">.find</span>(jscodeshift.Identifier)
  <span class="hljs-class">.forEach</span>(<span class="hljs-function">function</span>(path) {
      <span class="hljs-comment">// do something with path</span>
      });

<span class="hljs-comment">// Provide jQuery-likely and F2E-friendly Syntax API</span>
<span class="hljs-comment">// Manipulate AST nodes conveniently.</span></code></pre><p>读这段代码的时候，一下子觉得又似曾相识。这不就和使用 <code>jQuery</code> 操作 DOM 一样嘛。
可以对比下 “普通 Parser” 与 jscodeshift 操纵 AST 的区别：
可以看到如果使用 <a href="http://esprima.org/">esprima</a> ，AST Traverse / Walk 基本是 <code>visitor pattern</code>.
<a href="https://github.intra.douban.com/zhangbinliu/ast_demo/tree/esprima">https://github.intra.douban.com/zhangbinliu/ast_demo/tree/esprima</a></p>
<h3 id="-">第五步，输出转换后的代码</h3>
<p>这个据 CPojer 说，根据转换后的 AST，以及一些输出 <a href="https://github.com/benjamn/recast/blob/52a7ec3eaaa37e78436841ed8afc948033a86252/lib/options.js#L61">Options</a>（比如是否单引号、tab 宽度是多少、需不需要去掉尾部分号…）是一个挺困难的过程。
但最终，jscodeshift 的 print API 语法却是只要一行代码即可。</p>
<pre class="hljs"><code><span class="hljs-class">.toSource</span>({<span class="hljs-attribute">quote</span>: <span class="hljs-string">&#39;single&#39;</span>}); <span class="hljs-comment">// sets strings to use single quotes in transformed code.</span></code></pre><p>其实 Recast 在这做了<a href="(https://github.com/benjamn/recast/blob/master/lib/printer.js">大量的工作</a> )。</p>
<p>经过这五个步骤，一次 jscodeshift 的转换过程就算完成了。</p>
<hr>
<h2 id="demo-time-">DEMO TIME!</h2>
<h3 id="write-a-codemod-transform">Write a codemod transform</h3>
<p><code>jscodeshift -t &lt;transform.js&gt; /to/file/path</code> 的 <code>transform.js</code>，也就是说，你打算使用 jscodeshift 对源文件进行何种变换，这里面就是变换函数；</p>
<h4 id="problem-">Problem:</h4>
<pre class="hljs"><code><span class="hljs-comment">// Before</span>
<span class="hljs-string">&#39;Hello, &#39;</span> + name + <span class="hljs-string">&#39;, this is a string.&#39;</span>
<span class="hljs-comment">// After</span>
<code>Hello, ${name}, &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;.</code></code></pre><h4 id="solution-">Solution:</h4>
<ol>
<li>Simplify:</li>
</ol>
<pre class="hljs"><code><span class="hljs-comment">// Before</span>
a + b
<span class="hljs-comment">// After</span>
<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${a}&lt;/span&gt;&lt;span class=&quot;hljs-subst&quot;&gt;${b}&lt;/span&gt;</code></span></code></pre><p><code>a + b</code> AST:</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/e4d3c126-f36f-11e6-98aa-382c3afd9bcf" alt="image"></p>
<p><code>${a}${b}</code> AST:</p>
<p><img src="https://media.github.intra.douban.com/user/62/files/ea450a52-f36f-11e6-9a28-f715785d13a2" alt="image"></p>
<p>对比两个 AST 可以发现
我们只需要 </p>
<ol>
<li>读入需转换的代码，找到 <code>BinaryExpression</code></li>
<li>保存 <code>BinaryExpression</code> 左右两边的值（node.left &amp; node.right)</li>
<li>生成一个为 <code>TemlateLiteral</code> Node，<code>quasis</code> 是一个包含了三个 <code>TemplateElement</code> 的数组，<code>cookde &amp; raw keys</code> 都是 <code>&#39;&#39;</code>， <code>expressions</code> 是一个包含 node.left, node.right 值的数组。</li>
<li>然后将它返回输出；</li>
</ol>
<p>Solution Example:</p>
<ol>
<li><a href="http://astexplorer.net/#/gist/33b63b7dc8da6d9ea4936c631adc994d/7905ef5b30dfc0cb3c811af8a8960f11014ef402">http://astexplorer.net/#/gist/33b63b7dc8da6d9ea4936c631adc994d/7905ef5b30dfc0cb3c811af8a8960f11014ef402</a></li>
<li><a href="http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/55c4910295973b3a4d09770d94cec73d5096daa4">http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/55c4910295973b3a4d09770d94cec73d5096daa4</a></li>
<li><a href="http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/cf3c898c5fe494d08a978dd1a3a3e56fc42828a8">http://astexplorer.net/#/gist/a71957902ec1fd79f199eb37e5e6801a/cf3c898c5fe494d08a978dd1a3a3e56fc42828a8</a></li>
</ol>
<p>官方没有太详细的 transform 编写指导，可以多谷歌或者学习 react-codemod/tranform or js-codemod/transform，
个人觉得写 JS-codeshift Transform | Babel-Plugin 本质其实就是对比两棵语法树，像解谜一样，看看如何「又好又快」变换成这样。
剩下的一开始如何读取源 JS 代码并解析成语法树，具体在 AST 上 traverse &amp; find &amp; create &amp; update （这里我猜测其实是一个递归遍历节点树的过程？），及之后如何按一定的 code style 生成我们需要的代码，都是透明且不关心的。</p>
<hr>
<h2 id="-">总结 &amp; 开脑洞</h2>
<ul>
<li><p>基本处理流程：
<img src="https://media.github.intra.douban.com/user/62/files/7fe54aa4-f370-11e6-90d8-9f191a40a5cc" alt="image"></p>
</li>
<li><p>AST 是很有用的一个抽象概念。一旦你理解了这些规则，唯一的限制就是解析器和你的想象力。</p>
</li>
<li>纯 AST parse 太过于理论，既然是工程师，还是需要自己动手写点什么来解决自己实际遇到的问题。</li>
<li>可以继续拓展到「语法高亮」、「关键字匹配」、「代码格式化」、「作用域判断」、以及「代码压缩」、「Babel 插件」等等。</li>
<li>渐渐深入底层进行分析，让自己对这门语言有了更多、更深入的了解，可以更好地成为产品「创造者」，而不单纯是「使用者」。</li>
<li>Write JavaScript that write JavaScript! The best editor is JavaScript. Cool!</li>
</ul>
<hr>
<h2 id="-">思考</h2>
<ul>
<li>可以在一个 codemod transform 里面同时进行两个变换吗？个人觉得可能会很复杂且效果不太好，因为有些 transform 并不是正交的。🤔</li>
</ul>
<hr>
<h2 id="refs-">Refs:</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=d0pOgY8__JM">CPojer’s Talk</a></li>
<li><a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.s5kdne4xl">Effective JavaScript Codemods</a></li>
<li><a href="https://survivejs.com/blog/codemod-interview/">Codemod Interview</a></li>
<li><a href="https://vramana.github.io/blog/2015/12/21/codemod-tutorial/">How to write a codemod</a> 结合 CPojer’s Talk, 这个虽很长但很有用！</li>
<li><a href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/">Understanding Babel Plugin</a></li>
<li><a href="http://tech.meituan.com/abstract-syntax-tree.html">AST 在美团的应用</a></li>
<li><a href="http://imweb.io/topic/57b13b4f93d9938132cc8dfd">imweb</a></li>
</ul>
]]></description><link>/2017-02-15-fun-with-codemod-and-ast/index.html</link><guid isPermaLink="true">/2017-02-15-fun-with-codemod-and-ast/index.html</guid><category><![CDATA[tech]]></category><category><![CDATA[programming]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Tue, 14 Feb 2017 17:21:00 GMT</pubDate></item><item><title><![CDATA[[译]前端指南]]></title><description><![CDATA[<p><strong>Update</strong>
以下大概写于两年前，亟待更新。</p>
<hr>
<p>几天前从Github上看到了这篇<a href="https://github.com/bendc/frontend-guidelines">前端编码最佳实践</a>，Star数已破4K，觉得应该是篇不错的小指南，花了点时间将它稍作翻译，也当是复习复习 <code>HTML&amp;CSS&amp;JS</code>。
翻译时随手参照了《CSS设计指南》、《精通CSS-2ndEdition》、老道的《JavaScript语言精粹》、NZ大神的《JavaScript高级程序设计》，在学习了一些专有名词表达同时，也学到了许多有用的代码和思想。
不过原作者好像是<code>CoffeeScript</code>爱好者，且广泛使用了<code>ES6</code>特性，所以有些名词和表达我暂未理解透彻，还需斟酌。故现将原文译文参照排版，还待之后的更新。</p>
<hr>
<h2 id="html">HTML</h2>
<p>###语义化（Semantics）
HTML5 provides us with lots of semantic elements aimed to describe precisely the content. Make sure you benefit from its rich vocabulary.
HTML5 给我们提供了大量的语义化元素标签去准确的描述元素内容。确保你从它的丰富的词汇中获益。</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">&quot;main&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;article&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;header&quot;</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Blog post<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Published: <span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>21st Feb, 2015<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>…<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">article</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">header</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Blog post<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Published: <span class="hljs-tag">&lt;<span class="hljs-title">time</span> <span class="hljs-attribute">datetime</span>=<span class="hljs-value">&quot;2015-02-21&quot;</span>&gt;</span>21st Feb, 2015<span class="hljs-tag">&lt;/<span class="hljs-title">time</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-title">header</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>…<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">article</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">main</span>&gt;</span></code></pre><p>Make sure you understand the semantic of the elements you&#39;re using. It&#39;s worse to use a semantic element in a wrong way than staying neutral.
确保你理解你正在使用的元素的语义。错误的使用一个语义化标签元素比保持中立更糟糕。</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">figure</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">Company</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">logo.png</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">figure</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>

<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">Company</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">logo.png</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span></code></pre><p>简洁（Brevity）
Keep your code terse. Forget about your old XHTML habits.
保持你代码的简洁精练。把你的老掉牙XHTML习惯忘掉吧。</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">en</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">Content-Type</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">stylesheet</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">style.css</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">text</span>/<span class="hljs-attribute">css</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Contact me<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
      Email address:
      <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">email</span> <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">you@email.com</span> <span class="hljs-attribute">required</span>=<span class="hljs-value">required</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">main.js</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">text</span>/<span class="hljs-attribute">javascript</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>

<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">en</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">stylesheet</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">style.css</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Contact me<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
    Email address:
    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">email</span> <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">you@email.com</span> <span class="hljs-attribute">required</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">main.js</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre><p> 容易理解（Accessibility）
 Accessibility shouldn&#39;t be an afterthought. You don&#39;t have to be a WCAG expert to improve your website, you can start immediately by fixing the little things that make a huge difference, such as:
容易理解不应该是一个附加品。你没必要成为一名WCAG专家再来改善你的网站，你马上就能通过修复一些小事情来make a huge difference。</p>
<ul>
<li>learning to use the alt attribute properly</li>
<li>学会正确使用<code>alt</code>属性</li>
<li>making sure your links and buttons are marked as such (no <div class=button> atrocities)</li>
<li>确保你的链接和按钮都这样被标记（不要<code>&lt;div class=button&gt;</code>残暴）</li>
<li>not relying exclusively on colors to communicate information</li>
<li>交流信息时不仅仅依赖颜色</li>
<li>explicitly labelling form controls</li>
<li><p>明确地标签表单控制</p>
<pre class="hljs"><code>  <span class="hljs-comment">&lt;!-- bad --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">&quot;Logo&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">&quot;logo.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- good --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">&quot;My Company, Inc.&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">&quot;logo.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span></code></pre></li>
</ul>
<p>语言（Language）
While defining the language and character encoding is optional, it&#39;s recommended to always declare both at document level, even if they&#39;re specified in your HTTP headers. Favor UTF-8 over any other character encoding.
当界定的编码语言和字符是可选择的话，建议你永远都在文档级别（document level）申明，即使它们已在你的HTTP头部规定好。喜欢<code>UTF-8</code>胜过其他类型字符编码一万倍~</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Hello, world.<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>

<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">en</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Hello, world.<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre><p>性能（Performance）
Unless there&#39;s a valid reason for loading your scripts before your content, don&#39;t block the rendering of your page. If your style sheet is heavy, isolate the styles that are absolutely required initially and defer the loading of the secondary declarations in a separate style sheet. Two HTTP requests is significantly slower than one, but the perception of speed is the most important factor.
除非在内容加载之前先载入脚本有个合理的理由，那么就别阻塞你页面的渲染。
如果CSS文件很大，就页面初始时必要的样式分离出来，然后再延迟加载独立样式表中的次要声明。两次HTTP请求会显著地慢于一次，但是（用户对页面加载）速度的感觉才是最重要的因素。</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- bad --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">analytics.js</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Hello, world.<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

<span class="hljs-comment">&lt;!-- good --&gt;</span>
<span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">utf-8</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Hello, world.<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">analytics.js</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre><h2 id="css">CSS</h2>
<p> 分号（Semicolons）
While the semicolon is technically a separator in CSS, always treat it as a terminator.
虽然从技术上说，分号在CSS中是一个分离器，但永远把它当一个终止器来看待。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red
</span></span></span>}

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
}</span></code></pre><p>盒模型（Box Model）
The box model should ideally be the same for the entire document. A global <em> { box-sizing: border-box; } is fine, but don&#39;t change the default box model on specific elements if you can avoid it.
理想状况下，整个文档的盒模型应该保持一样。 全局的 `</em> { box-sizing: border-box; }` 是很好，但尽量别去改变特定元素的默认盒模型。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">10px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">box-sizing</span>:<span class="hljs-value"> border-box</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">10px</span></span></span>;
}</span></code></pre><p>  流（Flow）
Don&#39;t change the default behavior of an element if you can avoid it. Keep elements in the natural document flow as much as you can. For example, removing the white-space below an image shouldn&#39;t make you change its default display:
尽量不要去改变一个元素的默认行为。尽你所能让标签元素都待在正常文档流里。比如说，移除一张图片下方空白不应改变它的默认显示：</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">img</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> block</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">img</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">vertical-align</span>:<span class="hljs-value"> middle</span></span>;
}</span></code></pre><p> Similarly, don&#39;t take an element off the flow if you can avoid it.
 同样地，尽量别把一个元素从文档流中拿出来。</p>
<pre class="hljs"><code>  <span class="hljs-comment">/<em> bad </em>/</span>
  <span class="hljs-tag">div</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100px</span></span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value"> absolute</span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">right</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
  }</span>

   <span class="hljs-comment">/<em> good </em>/</span>
   <span class="hljs-tag">div</span> <span class="hljs-rules">{
       <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100px</span></span></span>;
       <span class="hljs-rule"><span class="hljs-attribute">margin-left</span>:<span class="hljs-value"> auto</span></span>;
   }</span></code></pre><p>定位（Positioning）
There are many ways to position elements in CSS but try to restrict yourself to the properties/values below. By order of preference:
在CSS中有许多方法来定位元素，但尽量限制自己来使用以下的属性/值。通过偏好排序：</p>
<pre class="hljs"><code><span class="hljs-attribute">display</span>: <span class="hljs-string">block;</span>
<span class="hljs-attribute">display</span>: <span class="hljs-string">flex;</span>
<span class="hljs-attribute">position</span>: <span class="hljs-string">relative;</span>
<span class="hljs-attribute">position</span>: <span class="hljs-string">sticky;</span>
<span class="hljs-attribute">position</span>: <span class="hljs-string">absolute;</span>
<span class="hljs-attribute">position</span>: <span class="hljs-string">fixed;</span></code></pre><p>选择符（Selectors）
Minimize selectors tightly coupled to the DOM. Consider adding a class to the elements you want to match when your selector exceeds 3 structural pseudo-classes, descendant or sibling combinators.
最小化和DOM紧密耦合的选择符。当选择符超出三个结构伪类（structural pseudo-classes）、后代（descendant）或同胞（ sibling）选择符组合的话，考虑为你希望匹配的元素标签加一个类。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-operator">div</span>:<span class="hljs-keyword">first</span>-<span class="hljs-operator">of</span>-type :<span class="hljs-keyword">last</span>-child &gt; p ~ <em>

<span class="hljs-comment">/</em> good */</span>
<span class="hljs-operator">div</span>:<span class="hljs-keyword">first</span>-<span class="hljs-operator">of</span>-type .info</code></pre><p>Avoid overloading your selectors when you don&#39;t need to.  不必要的时候避免选择符过载。（<strong>译注：CSS选择符过载是什么？只知道 override。</strong>）</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">img</span><span class="hljs-attr_selector">[src$=svg]</span>, <span class="hljs-tag">ul</span> &gt; <span class="hljs-tag">li</span><span class="hljs-pseudo">:first-child</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">opacity</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-attr_selector">[src$=svg]</span>, <span class="hljs-tag">ul</span> &gt; <span class="hljs-pseudo">:first-child</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">opacity</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
}</span></code></pre><p>特指度（Specificity）
Don&#39;t make values and selectors hard to override. Minimize the use of id&#39;s and avoid !important.
别让值和选择符难以重载。减少ID的使用，避免使用<code>!important</code>。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-class">.bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green <span class="hljs-important">!important</span></span></span>;
}</span>
<span class="hljs-class">.foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-class">.foo</span><span class="hljs-class">.bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> green</span></span>;
}</span>
<span class="hljs-class">.foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> red</span></span>;
}</span></code></pre><p> 层叠（Overriding）
 Overriding styles makes selectors and debugging harder. Avoid it when possible.
 层叠样式会使选择符和调试更加复杂困难。尽可能避免使用。</p>
<pre class="hljs"><code> <span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">li</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">visibility</span>:<span class="hljs-value"> hidden</span></span>;
}</span>
<span class="hljs-tag">li</span><span class="hljs-pseudo">:first-child</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">visibility</span>:<span class="hljs-value"> visible</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">li</span> + <span class="hljs-tag">li</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">visibility</span>:<span class="hljs-value"> hidden</span></span>;
}</span></code></pre><p>继承（Inheritance）
Don&#39;t duplicate style declarations that can be inherited.
能继承的样式声明就别复制。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-tag">h1</span>, <span class="hljs-tag">div</span> <span class="hljs-tag">p</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">text-shadow</span>:<span class="hljs-value"> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span> <span class="hljs-hexcolor">#fff</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">text-shadow</span>:<span class="hljs-value"> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span> <span class="hljs-hexcolor">#fff</span></span></span>;
}</span></code></pre><p>简洁（Brevity）
Keep your code terse. Use shorthand properties and avoid using multiple properties when it&#39;s not needed.
保持代码的简洁。使用简写的属性，不必要时避免使用多重属性。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> all <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">top</span>:<span class="hljs-value"> <span class="hljs-number">50%</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin-top</span>:<span class="hljs-value"> -<span class="hljs-number">10px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding-top</span>:<span class="hljs-value"> <span class="hljs-number">5px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding-right</span>:<span class="hljs-value"> <span class="hljs-number">10px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding-bottom</span>:<span class="hljs-value"> <span class="hljs-number">20px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding-left</span>:<span class="hljs-value"> <span class="hljs-number">10px</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">top</span>:<span class="hljs-value"> <span class="hljs-function">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">10px</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">5px</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span></span></span>;
}</span></code></pre><p>语言（Language）
Prefer English over math.</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-pseudo">:nth-child(2n</span> + 1) <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">rotate</span>(<span class="hljs-number">360deg</span>)</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-pseudo">:nth-child(odd)</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">rotate</span>(<span class="hljs-number">1turn</span>)</span></span>;
}</span></code></pre><p>浏览器前缀（Vendor prefixes）
Kill obsolete vendor prefixes aggressively. If you need to use them, insert them before the standard property.
竭力地干掉过时的浏览器前缀吧！必须使用的话，把它们写在标准属性前。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-webkit-transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-moz-transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-ms-transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-webkit-transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-moz-transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">-ms-transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">-webkit-transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> <span class="hljs-number">1s</span></span></span>;
}</span></code></pre><p>动画（Animation）
Favor transitions over animations. Avoid animating other properties than opacity and transform.
除了<code>opacity</code> 和 <code>transform</code>，其他尽量使用<code>transition</code>，而不是<code>animation</code>。</p>
<p>单位（Units）
能不带单位就不带单位。相对单位多用<code>rem</code>。多用<code>s</code>而不是<code>ms</code>。（<strong>why?</strong>）</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> .<span class="hljs-number">9em</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"> <span class="hljs-number">22px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> <span class="hljs-number">500ms</span></span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> .<span class="hljs-number">9rem</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"> <span class="hljs-number">1.5</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">transition</span>:<span class="hljs-value"> .<span class="hljs-number">5s</span></span></span>;
}</span></code></pre><p>颜色（Colors）
需要改变透明度（transparency）时，使用<code>rgba</code>。否则永远使用十六进制值（hexadecimal format）。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-function">hsl</span>(<span class="hljs-number">103</span>, <span class="hljs-number">54%</span>, <span class="hljs-number">43%</span>)</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#5a3</span></span></span>;
}</span></code></pre><p>绘图（Drawing）
资源使用CSS绘图替代的话可以避免HTTP请求。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span><span class="hljs-pseudo">::before</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"> <span class="hljs-function">url</span>(white-circle.svg)</span></span>;
}</span>

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span><span class="hljs-pseudo">::before</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"> <span class="hljs-string">&quot;&quot;</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> block</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">20px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">20px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border-radius</span>:<span class="hljs-value"> <span class="hljs-number">50%</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#fff</span></span></span>;
}</span></code></pre><p>技巧（Hacks）
别用。</p>
<pre class="hljs"><code><span class="hljs-comment">/<em> bad </em>/</span>
<span class="hljs-tag">div</span> {
  <span class="hljs-comment">// position: relative;</span>
  <span class="hljs-attribute">transform</span>: <span class="hljs-function">translateZ</span>(<span class="hljs-number">0</span>);
}

<span class="hljs-comment">/<em> good </em>/</span>
<span class="hljs-tag">div</span> {
  <span class="hljs-comment">/<em> position: relative; </em>/</span>
  <span class="hljs-attribute">will-change</span>: transform;
}</code></pre><h2 id="javascript">JavaScript</h2>
<p>性能（Performance）
Favor readability, correctness and expressiveness over performance. JavaScript will basically never be your performance bottleneck. Optimize things like image compression, network access and DOM reflows instead. If you remember just one guideline from this document, choose this one.
易读性、正确性、富有表现性比性能更重要。从根本上来说，JavaScript绝对不会成为性能瓶颈，应该优化图像压缩、网络连接和DOM刷新。如果你只记得这篇文档的一条规则，那就选择这条吧。</p>
<pre class="hljs"><code>// bad (albeit way faster)
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> len = arr.length;
<span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> <span class="hljs-literal">result</span> = [];
<span class="hljs-keyword">while</span> (++i &lt; len) {
  <span class="hljs-keyword">var</span> n = arr[i];
  <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
  <span class="hljs-literal">result</span>.push(n <em> n);
}

// good
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> isEven = n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> square = n =&gt; n </em> n;

<span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = arr.filter(isEven).map(square);</code></pre><p>无国籍？（Statelessness）
Try to keep your functions pure. All functions should ideally produce no side-effects, use no outside data and return new objects instead of mutating existing ones.
尽量使函数纯粹。理想情况下，所有的函数都不会产生副作用，不使用外部的数据，返回新的对象而不是在现有对象上作修改。</p>
<pre class="hljs"><code>// bad
const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);
merge({ foo: <span class="hljs-string">&quot;foo&quot;</span> }, { bar: <span class="hljs-string">&quot;bar&quot;</span> }); // =&gt; { foo: <span class="hljs-string">&quot;foo&quot;</span>, bar: <span class="hljs-string">&quot;bar&quot;</span> }

// good
const merge = (...sources) =&gt; Object.assign({}, ...sources);
merge({ foo: <span class="hljs-string">&quot;foo&quot;</span> }, { bar: <span class="hljs-string">&quot;bar&quot;</span> }); // =&gt; { foo: <span class="hljs-string">&quot;foo&quot;</span>, bar: <span class="hljs-string">&quot;bar&quot;</span> }</code></pre><p>原生（Natives）
尽可能使用原生方法。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
const <span class="hljs-built_in">toArray</span> = obj =&gt; [].slice.<span class="hljs-built_in">call</span>(obj);

<span class="hljs-comment">// good</span>
const <span class="hljs-built_in">toArray</span> = (() =&gt;
  <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span> ? <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span> : obj =&gt; [].slice.<span class="hljs-built_in">call</span>(obj)
)();</code></pre><p>强制转换（Coercion）
有意义的时候就欣然使用「隐式类型转换」（imolicit coercion）吧，不然就避免它。Don&#39;t cargo-cult. （别太草包，要灵活变通？）</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-tag">if</span> (x === undefined || x === null) { ... }

<span class="hljs-comment">// good</span>
<span class="hljs-tag">if</span> (x == undefined) { ... }</code></pre><p>循环（Loops）
Don&#39;t use loops as they force you to use mutable objects. Rely on <code>array.prototype</code> methods.
不要使用循环因为它强制你使用可变的对象。使用<code>array.prototype</code>方法。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">sum</span> = arr =&gt; {
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">sum</span> = 0;
  <span class="hljs-keyword">var</span> i = -1;
  <span class="hljs-keyword">for</span> (;arr[++i];) {
    <span class="hljs-keyword">sum</span> += arr[i];
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;
};

<span class="hljs-literal">sum</span>([1, 2, 3]); <span class="hljs-comment">// =&gt; 6</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">sum</span> = arr =&gt;
  arr.reduce((x, y) =&gt; x + y);

<span class="hljs-literal">sum</span>([1, 2, 3]); <span class="hljs-comment">// =&gt; 6</span></code></pre><p>If you can&#39;t, or if using <code>array.prototype</code> methods is arguably abusive, use recursion.
不能的话，或者可以说 <code>array.prototype</code> 被滥用，就使用递归（recursion）。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> createDivs = howMany =&gt; {
  <span class="hljs-keyword">while</span> (howMany--) {
    <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(<span class="hljs-string">&quot;beforeend&quot;</span>, <span class="hljs-string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>);
  }
};
createDivs(<span class="hljs-number">5</span>);

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> createDivs = howMany =&gt;
  [...Array(howMany)].forEach(() =&gt;
    <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(<span class="hljs-string">&quot;beforeend&quot;</span>, <span class="hljs-string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>)
  );
createDivs(<span class="hljs-number">5</span>);

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> createDivs = howMany =&gt; {
  <span class="hljs-keyword">if</span> (!howMany) <span class="hljs-keyword">return</span>;
  <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(<span class="hljs-string">&quot;beforeend&quot;</span>, <span class="hljs-string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>);
  <span class="hljs-keyword">return</span> createDivs(howMany - <span class="hljs-number">1</span>);
};
createDivs(<span class="hljs-number">5</span>);</code></pre><p>参数（Arguments）
Forget about the <code>arguments</code> object. The rest parameter is always a better option because:</p>
<ol>
<li>it&#39;s named, so it gives you a better idea of the arguments the function is expecting</li>
<li>it&#39;s a real array, which makes it easier to use.
忘掉 <code>arguments</code> 对象吧。参数名（rest parameter）总是个更好的选择。原因如下：</li>
<li>命名的参数能让你更好理解这个函数期待输入的参数；</li>
<li><p>命名的参数是一个真正的数组，这样使用它更容易。</p>
<pre class="hljs"><code> <span class="hljs-comment">// bad</span>
 <span class="hljs-keyword">const</span> sortNumbers = () =&gt;
       <span class="hljs-keyword">Array</span>.prototype.slice.call(arguments).sort();

 <span class="hljs-comment">// good</span>
 <span class="hljs-keyword">const</span> sortNumbers = (...numbers) =&gt; numbers.sort();</code></pre></li>
</ol>
<p>Apply
忘掉<code>apply()</code>吧，使用更广泛的操作符（spread operator）。</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> greet = (first, last) =&gt; <span class="hljs-string"><code>Hi &lt;span class=&quot;hljs-subst&quot;&gt;${first}&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;${last}&lt;/span&gt;</code></span>;
<span class="hljs-keyword">const</span> person = [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>];

<span class="hljs-comment">// bad</span>
greet.apply(<span class="hljs-literal">null</span>, person);

<span class="hljs-comment">// good</span>
greet(...person);</code></pre><p>Bind
Don&#39;t <code>bind()</code> when there&#39;s a more idiomatic  approach.
有更符合语言习惯的方法的时候，不要用<code>bind()</code>。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
[<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>].forEach(func.bind(<span class="hljs-keyword">this</span>));

<span class="hljs-comment">// good</span>
[<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>].forEach(func, <span class="hljs-keyword">this</span>);

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> person = {
  first: <span class="hljs-string">&quot;John&quot;</span>,
  last: <span class="hljs-string">&quot;Doe&quot;</span>,
  greet() {
    <span class="hljs-keyword">const</span> full = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${this.first}&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;${this.last}&lt;/span&gt;</code></span>;
    }.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string"><code>Hello &lt;span class=&quot;hljs-subst&quot;&gt;${full()}&lt;/span&gt;</code></span>;
  }
}

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> person = {
  first: <span class="hljs-string">&quot;John&quot;</span>,
  last: <span class="hljs-string">&quot;Doe&quot;</span>,
  greet() {
    <span class="hljs-keyword">const</span> full = () =&gt; <span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${this.first}&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;${this.last}&lt;/span&gt;</code></span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string"><code>Hello &lt;span class=&quot;hljs-subst&quot;&gt;${full()}&lt;/span&gt;</code></span>;
  }
}</code></pre><p>高阶函数（Higher-order functions）
尽量不要嵌套函数（nesting functions）。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-built_in">map</span>(num =&gt; String(num));

<span class="hljs-comment">// good</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-built_in">map</span>(String);</code></pre><p>组合（Composition）
Avoid multiple nested function calls. Use composition instead.
 避免多重嵌套的函数调用。改用<code>composition</code>。</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> plus1 = a =&gt; a + <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> mult2 = a =&gt; a * <span class="hljs-number">2</span>;

<span class="hljs-comment">// bad</span>
mult2(plus1(<span class="hljs-number">5</span>)); <span class="hljs-comment">// =&gt; 12</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);
<span class="hljs-keyword">const</span> addThenMult = pipeline(plus1, mult2);
addThenMult(<span class="hljs-number">5</span>); <span class="hljs-comment">// =&gt; 12</span></code></pre><p>缓存（Caching）
Cache feature tests, large data structures and any expensive operation.
将重要的测试、大块的数据结构或者任何高代价的运算操作都缓存起来。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> contains = (arr, value) =&gt;
  <span class="hljs-keyword">Array</span>.prototype.includes
    ? arr.includes(value)
    : arr.some(el =&gt; el === value);
contains([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>], <span class="hljs-string">&quot;baz&quot;</span>); <span class="hljs-comment">// =&gt; false</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> contains = (() =&gt;
  <span class="hljs-keyword">Array</span>.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)
)();
contains([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>], <span class="hljs-string">&quot;baz&quot;</span>); <span class="hljs-comment">// =&gt; false</span></code></pre><p>变量（Variables）
Favor const over let and let over var.
优先级：<code>const</code> &gt; <code>let</code> &gt; <code>var</code></p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> obj = {};
obj[<span class="hljs-string">&quot;foo&quot;</span> + <span class="hljs-string">&quot;bar&quot;</span>] = <span class="hljs-string">&quot;baz&quot;</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> obj = {
  [<span class="hljs-string">&quot;foo&quot;</span> + <span class="hljs-string">&quot;bar&quot;</span>]: <span class="hljs-string">&quot;baz&quot;</span>
};</code></pre><p>条件（Conditions）
Favor IIFE&#39;s and return statements over if, else if, else and switch statements.
优先级：<code>IIFE</code>+ <code>return</code> &gt; <code>if</code> + <code>else if</code> + <code>switch</code>
译注：<code>IIFE</code>： Immediately-invoked function expression，立即调用的函数表达式；</p>
<pre class="hljs"><code>// bad
<span class="hljs-keyword">var</span> grade;
<span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> &lt; <span class="hljs-number">50</span>)
  grade = <span class="hljs-string">&quot;bad&quot;</span>;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> &lt; <span class="hljs-number">90</span>)
  grade = <span class="hljs-string">&quot;good&quot;</span>;
<span class="hljs-keyword">else</span>
  grade = <span class="hljs-string">&quot;excellent&quot;</span>;

// good
<span class="hljs-keyword">const</span> grade = (() =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> &lt; <span class="hljs-number">50</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bad&quot;</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> &lt; <span class="hljs-number">90</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;good&quot;</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;excellent&quot;</span>;
})();</code></pre><p>对象迭代（Object iteration）
Avoid for...in when you can.
避免使用<code>for-in</code></p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> shared = { foo: <span class="hljs-string">&quot;foo&quot;</span> };
<span class="hljs-keyword">const</span> obj = Object.create(shared, {
  bar: {
    value: <span class="hljs-string">&quot;bar&quot;</span>,
    enumerable: true
  }
});

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">prop</span> <span class="hljs-keyword">in</span> obj) {
  <span class="hljs-keyword">if</span> (obj.hasOwnProperty(<span class="hljs-keyword">prop</span>))
    console.<span class="hljs-literal">log</span>(<span class="hljs-keyword">prop</span>);
}

<span class="hljs-comment">// good</span>
Object.keys(obj).<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">prop</span> =&gt; console.<span class="hljs-literal">log</span>(<span class="hljs-keyword">prop</span>));</code></pre><p>Objects as Maps
While objects have legitimate use cases, maps are usually a better, more powerful choice. When in doubt, use a Map.
尽管<code>objects</code>有些好的使用案例，但<code>maps</code>通常是一种更好更强大的选择。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> me = {
  name: <span class="hljs-string">&quot;Ben&quot;</span>,
  age: <span class="hljs-number">30</span>
};
<span class="hljs-keyword">var</span> meSize = <span class="hljs-built_in">Object</span>.keys(me).length;
meSize; <span class="hljs-comment">// =&gt; 2</span>
me.country = <span class="hljs-string">&quot;Belgium&quot;</span>;
meSize++;
meSize; <span class="hljs-comment">// =&gt; 3</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> me = <span class="hljs-built_in">Map</span>();
me.<span class="hljs-literal">set</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ben&quot;</span>);
me.<span class="hljs-literal">set</span>(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">30</span>);
me.size; <span class="hljs-comment">// =&gt; 2</span>
me.<span class="hljs-literal">set</span>(<span class="hljs-string">&quot;country&quot;</span>, <span class="hljs-string">&quot;Belgium&quot;</span>);
me.size; <span class="hljs-comment">// =&gt; 3</span></code></pre><p>柯里化（Curry）
Currying might have its place in other languages, but avoid it in JavaScript. It makes your code harder to read by introducing a foreign paradigm while the appropriate use cases are extremely unusual.
在其他语言中，柯里化可能有它的一席之地，但是不要在 JavaScript 中使用它。因为它引入了很少能见到正确使用的非自身范例（foreign paradigm），这会让你的代码阅读困难。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> sum = a =&gt; b =&gt; a + b;
sum(<span class="hljs-number">5</span>)(<span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; 8</span>

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> sum = (a, b) =&gt; a + b;
sum(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; 8</span></code></pre><p>可读性（Readability）
Don&#39;t obfuscate the intent of your code by using seemingly smart tricks.
别用些自作聪明的小把戏混淆了你代码真正的意图。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
foo || doSomething();

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">if</span> (!foo) doSomething();


<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/<em> IIFE </em>/</span> }();

<span class="hljs-comment">// good</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/<em> IIFE </em>/</span> }());

<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> n = ~~<span class="hljs-number">3.14</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">3.14</span>);</code></pre><p>代码复用（Code reuse）
Don&#39;t be afraid of creating lots of small, highly composable and reusable functions.
尽管去写些短小精悍、组件化、高度复用的函数。</p>
<pre class="hljs"><code><span class="hljs-comment">// bad</span>
arr[arr.length - <span class="hljs-number">1</span>];

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> first = arr =&gt; arr[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> last = arr =&gt; first(arr.slice(-<span class="hljs-number">1</span>));
last(arr);


<span class="hljs-comment">// bad</span>
<span class="hljs-keyword">const</span> product = (a, b) =&gt; a <em> b;
<span class="hljs-keyword">const</span> triple = n =&gt; n </em> <span class="hljs-number">3</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> product = (a, b) =&gt; a * b;
<span class="hljs-keyword">const</span> triple = product.bind(<span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>);</code></pre><p>依赖（Dependencies）
Minimize dependencies. Third-party is code you don&#39;t know. Don&#39;t load an entire library for just a couple of methods easily replicable:
精简依赖。你都不知道第三方有些什么代码。
能自己写些简单方法替代就别载入整个库。</p>
<pre class="hljs"><code>// <span class="hljs-atom">bad</span>
<span class="hljs-atom">var</span> <span class="hljs-name"><em></span> = <span class="hljs-atom">require</span>(<span class="hljs-string">&quot;underscore&quot;</span>);
<span class="hljs-name"></em></span>.<span class="hljs-atom">compact</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">0</span>]));
<span class="hljs-name"><em></span>.<span class="hljs-atom">unique</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>]);
<span class="hljs-name"></em></span>.<span class="hljs-atom">union</span>([<span class="hljs-string">&quot;foo&quot;</span>], [<span class="hljs-string">&quot;bar&quot;</span>], [<span class="hljs-string">&quot;foo&quot;</span>]);

// <span class="hljs-atom">good</span>
<span class="hljs-atom">const</span> <span class="hljs-atom">compact</span> = <span class="hljs-atom">arr</span> =&gt; <span class="hljs-atom">arr</span>.<span class="hljs-atom">filter</span>(<span class="hljs-atom">el</span> =&gt; <span class="hljs-atom">el</span>);
<span class="hljs-atom">const</span> <span class="hljs-atom">unique</span> = <span class="hljs-atom">arr</span> =&gt; [...<span class="hljs-name">Set</span>(<span class="hljs-atom">arr</span>)];
<span class="hljs-atom">const</span> <span class="hljs-atom">union</span> = (...<span class="hljs-atom">arr</span>) =&gt; <span class="hljs-atom">unique</span>([].<span class="hljs-atom">concat</span>(...<span class="hljs-atom">arr</span>));

<span class="hljs-atom">compact</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">0</span>]);
<span class="hljs-atom">unique</span>([<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>]);
<span class="hljs-atom">union</span>([<span class="hljs-string">&quot;foo&quot;</span>], [<span class="hljs-string">&quot;bar&quot;</span>], [<span class="hljs-string">&quot;foo&quot;</span>]);</code></pre>]]></description><link>/2015-03-14-frontend-guidelines/index.html</link><guid isPermaLink="true">/2015-03-14-frontend-guidelines/index.html</guid><category><![CDATA[translate]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Sat, 14 Mar 2015 15:51:00 GMT</pubDate></item><item><title><![CDATA[CSS 中那些大大小小的坑]]></title><description><![CDATA[<h1 id="css-">CSS 中那些大大小小的坑</h1>
<blockquote>
<p>中国读者不是不善于交流，而是对基础知识掌握不够牢固，不敢交流。就如同有人提到用英文写作时所说的，最难的不是怎么写，而是写什么。英文语法错误其实是别人最容易纠正的，但你到底想要表达什么则是别人无法知道的。具体到CSS，虽然不难学，但真正彻底把原理和基本概念全搞通也不是一件容易的事。 —— 李松峰</p>
</blockquote>
<p>最近读完了Charles Wyke-Smith的《CSS设计指南》，上面那段话是节选的译者李松峰的序（在这多说一句，觉得李松峰翻译的书质量都很高，现在的我基本在遍历）。越来越觉得只读书不思考是毫无用处的，于是把笔记整理出来，并加上了自己思考过的感悟。</p>
<hr>
<p>###CHAPTER 1 HTML标记与文档结构
用HTML标记内容的目的是为了赋予网页语义（semantic）。换句话说，就是要给你的网页内容赋予某些用户代理（user agent）能够理解的含义。 浏览器、屏幕阅读器，以及搜索引擎放出的web爬虫都是用户代理，它们需要显示、朗读和分析网页。</p>
<ul>
<li><mark>文本用闭合标签，引用内容用自闭合标签。</mark><ul>
<li>闭合标签与自闭合标签的区别在于，闭合标签包含的是会显示的实际内容，而自闭合标签只是给浏览器提供一个对要显示内容的<strong>引用</strong>。浏览器会在HTML页面加载时候，<strong>额外向服务器发送请求</strong>，以取得自闭合标签引用的内容。</li>
</ul>
</li>
<li>属性alt(alternative)，定义的是在图片因故未能加载成功时候在屏幕上显示的文本。视障用户的屏幕阅读器会大声读出alt属性的内容，因此一定要给<code>&lt;img&gt;</code>标签的<code>alt</code>属性添加让人一听（或一看）就能明白的内容。</li>
<li><code>&lt;h1&gt;</code>被搜索引擎视为仅次于<code>&lt;tittle&gt;</code>标签的另一个搜索关键词重要来源。</li>
<li>只要有不适合放在其他文本标签中的文本，都可以把它放在一个段落里。</li>
<li>某些标签，如<code>&lt;ol&gt;</code>要求其他标签，如<code>&lt;li&gt;</code>与之共同出现。</li>
<li><code>&lt;!DOCTYPE html&gt;</code>是DTD（文档类型定义），声明：“以下是一个HTML文档。”</li>
<li><code>&lt;html&gt;</code>只有两个直接的子标签：<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>。帮助浏览器理解页面的信息都包含在<code>&lt;head&gt;</code>标签中。</li>
<li>块级标签：标题、段落、列表、独立引用等，如文档流一般上下堆叠显示；行内标签：链接、图片、字体样式、简写<code>&lt;abbr&gt;</code>、引证<code>&lt;cite&gt;</code>、文本内引用<code>&lt;q&gt;</code>相互并列显示，只有在空间不足以并列的情况下才会折到下一行。</li>
<li><strong>块级元素盒子会拓展到与父元素同宽。</strong></li>
<li><strong>行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧。</strong></li>
<li>DOM（文档对象模型）是从浏览器的视角来观察页面中的元素及每个元素的属性，由此得出这些元素的一个家族树。通过DOM，可以确定元素之间的相互关系。在CSS中引用DOM中特定的位置，就可以选中相应的HTML元素，并修改其样式属性。CSS修改了元素后，这些变化会立即在DOM中发生，并体现在页面上。</li>
</ul>
<hr>
<p>###CHAPTER 2 CSS工作原理
当元素的同一个样式属性有多种样式值的时候，CSS靠层叠机制来决定最终应用哪种样式。</p>
<ul>
<li>为文档添加样式的三种方法：<ul>
<li>行内样式 ：  <code>&lt;p style=&quot;font-size: 12px; font-weight: bold;&quot;&gt;Adding inline CSS styling&lt;/p&gt;</code> 作用范围：只影响它所在的标签，而且总会覆盖嵌入样式和链接样式。</li>
<li>嵌入样式： 嵌在<code>head</code>元素中。如
<code>&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;...&lt;/style&gt;&lt;/head&gt;</code>
作用范围仅限于当前页面。会覆盖外部样式表，但被行内样式覆盖。</li>
<li>链接样式：把样式集中在一个单独文件——样式表（一个拓展名为.css的文本文件）。
在多个HTML中连接同一个样式表：
<code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code>
作用范围：有<code>&lt;link&gt;</code>标签的页面。</li>
<li><strong>@import指令</strong>：一种@规则，可以在样式表中链接其他样式表。
<code>import url(css/style2.css)</code>
注意：@import必须出现在样式表其他样式之前，否则不会被加载。<em>（见link css与@import css 的区别）</em></li>
</ul>
</li>
<li>一般上下文选择符。 基于祖先或同胞元素选择一个元素。
  <code>tag1 tag2 {statements}</code>  <strong>只要tag2在整个结构层次中有个tag1的祖先元素，无论上下文之间隔着多少层次没有关系</strong>。</li>
<li>子选择符<code>&gt;</code> <code>tag1 &gt; tag2</code>   标签2必须是标签1的子元素。</li>
<li>紧邻同胞选择符<code>+</code> <code>tag1 + tag2</code>   标签2必须紧跟在其同胞标签1后面。</li>
<li>一般同胞选择符<code>~</code> <code>tag1 ~ tag2</code>  标签2必须跟（不一定紧跟）在其同胞标签1后面。</li>
<li>通用选择符<code>*</code> 匹配任何元素。<code>* {color: green;}</code> <strong><code>color</code> 属性设定的是前景色，前景色既影响文本也影响边框，但一般用来设定文本颜色。</strong>
  故<code>p * {color: red;}</code>改变p包含的所有元素的文本变成红色。
  构成非子选择符：<code>section * a {font-size: 1.3em}</code> 任何是section孙子元素，而非子元素的a标签都会被选中。</li>
<li><strong>多类选择符</strong>。 <code>&lt;p class=&quot;specialtext featured&quot;&gt;...&lt;/p&gt;</code>
  选择同时存在这两个类名的元素：<code>.specialtext.featured {statements}</code>  注意两个类名之间没有空格，因为选择同时具有这个类名的那个元素。</li>
<li><strong>ID属性</strong>：ID用于页内导航链接。<ul>
<li><code>&lt;a href=&quot;#bio&quot;&gt;Biography&lt;/a&gt;
  &lt;h3 id=&quot;bio&quot;&gt;Biography&lt;/h3&gt;
  &lt;p&gt;....&lt;/p&gt;</code>
<code>href</code>属性值开头的<code>#</code>表示链接的目标在当前页面中，因而不会触发浏览器加载页面（如果没有#，浏览器会尝试加载bio目录下的默认页面）。会跳到h3元素的位置。
<code>&lt;a href=&quot;#&quot;&gt;Back to Top&lt;/a&gt;</code> 点击该链接返回页面顶部。
另外，如果不知道href放什么URL，可以用#作为占位符，但不能留空，因为href属性值为空的链接行为跟正常链接不一样。</li>
</ul>
</li>
<li><strong>ID</strong>是为了唯一的标识一个元素。每个ID名在页面中只能用一次。给页面中每个顶级区域都添加一个ID，得到明确的上下文。</li>
<li><strong>类</strong>是为了标识一组具有相同特征的元素。</li>
<li><strong>属性名选择符</strong> <code>标签名[属性名]</code>，选择任何带有属性名的标签名。
  什么时候使用？一般经常给alt和title属性设定相同的值。alt属性中的文本会在图片因故未能加载时显示，或者由屏幕朗读器朗读出来。而title属性会在用户鼠标移动到图片上时，显示一个包含相应文本的提示。</li>
<li><strong>属性值选择符</strong> <code>标签名[属性名=&quot;属性值&quot;]</code>，选择任何带有值为属性值的属性名的标签名。</li>
<li><strong>UI伪类</strong>在HTML元素处于某种状态时应用CSS。<ul>
<li>链接伪类。<code>::link/::visited / ::hover / ::active</code></li>
<li><code>:focus</code>伪类。<code>e:focus</code>在单击它获得焦点时候改变CSS。</li>
<li><strong><code>:target</code>伪类</strong>。 <code>e:target</code>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target伪类选中它。<pre class="hljs"><code>&lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">&quot;#more_info&quot;</span>&gt;More Information&lt;/a&gt;
&lt;<span class="hljs-tag">h2</span> id=<span class="hljs-string">&quot;more_info&quot;</span>&gt;This is the information you are looking <span class="hljs-keyword">for</span>.&lt;/h2&gt;</code></pre>那么规则<code>#more_info:target {background: #eee;}</code>会在用户单击链接转向ID为more_info的元素时候，为该元素（h2）添加浅灰色背景，以便在一大堆引证中识别。（实例见Wikipedia）</li>
</ul>
</li>
<li>结构伪类<ul>
<li><code>li:frist-child</code>&amp;<code>li:last-child</code>代表一组同胞元素中第一个或最后一个元素。</li>
<li><code>e:nth-child(n)</code> e为元素名，n表示一个数值（也可以使用odd或even）。用于提高表格的可读性，对表格的所有行交替应用不同颜色。</li>
</ul>
</li>
<li>伪元素（CSS3 new）<ul>
<li><code>e::first-letter</code> 首字符。</li>
<li><code>e::first-line</code>文本段落第一行，长度会随着浏览器窗口大小变换而改变。</li>
<li><code>::before</code>和<code>::after</code>伪元素，可用在特定元素前后添加特殊内容。<a href="#">（见用CSS伪类绘制各种图形 CSS trick）</a></li>
</ul>
</li>
<li>继承：文本样式（颜色）及字体（字号）。不继承元素盒子的定位和显示方式（边距、边框等）。<strong>所以使用相对字体单位（em和百分比）要格外小心！</strong></li>
<li>层叠：样式在文档层次中逐层叠加。<ul>
<li>层叠顺序：浏览器默认CSS-&gt;用户CSS-&gt;作者链接CSS(按照它们链接到页面的先后顺序)-&gt;作者嵌入CSS-&gt;作者行内CSS。</li>
<li>层叠规则：<ol>
<li>找到应用给每个元素和属性的所有声明。</li>
<li>按顺序和权重排序。 <code>!important;</code>用于加重声明的权重。</li>
<li>按特指度（specificity）排序。ID&gt;类&gt;标签名。但设定的样式胜过继承的样式。</li>
<li>顺序决定权重。位置靠下或者后声明的规则胜出。</li>
</ol>
</li>
</ul>
</li>
<li>em和ex都是字体大小的单位。但它们作为长度单位适用于任何元素。<ul>
<li>em表示一种字体中字母M的宽度，因此它的具体大小取决于你使用的字体。</li>
<li>ex等于给定字体中字母x的高度（小写字母x代表一种字体的字母中间部分的高度，不包括字母上下突出的部分——如d、p上下出头）。</li>
</ul>
</li>
<li>百分比非常适合设定被包含元素的宽度，此时的百分比是相对于宽度而言。<strong>可以把HTML结构元素宽度设定为body宽度的百分比，“流式”设计的关键，可以根据浏览器窗口大小而成比例伸缩。</strong></li>
<li>饱和度设定有多少颜色，灰色的饱和度低，而强烈色彩饱和度高。亮度设定颜色的明暗，0%就是黑色，100%就是白色。</li>
</ul>
<hr>
<p>###CHAPTER 3 定位元素
要掌握CSS，核心就是要掌握元素定位！
可见页面的版式 主要由三个属性控制：position 属性、display 属性和 float 属性。 position：控制页面上元素间的位置关系；display：控制元素是堆叠、并排还是根本不在页面上出现；float：提供控制的方式，以便把元素组成多栏布局。</p>
<p><strong>！！此处添加一张描述盒模型的图！！</strong></p>
<ul>
<li>HTML页面实际由一堆盒子组成。默认情况下，每个盒子的边框不可见，背景也是透明。</li>
<li>三组属性：<ul>
<li>边框（border）：宽窄、样式和颜色。</li>
<li>内边距（padding）：盒子内容区与边框的间距。</li>
<li>外边距（margin）：盒子与相邻元素的间距。
如何理解？<strong>外边距是边框向外推其他元素，内边距是边框向内推元素的内容。</strong></li>
</ul>
</li>
<li>简写样式：<code>margin{top, right, bottom, left}</code></li>
<li>边框（border）3个属性：<ul>
<li><code>border-width</code>：thin, medium, thick等文本值，也可以用除百分比和负值之外的任何绝对值；</li>
<li><code>border-style</code>：none,  hidden, dotted, dashed, solid, double, groove, ridge, inset, outset文本值；</li>
<li><code>border-color</code>：使用任意颜色值，包括RGB、HSL、十六进制值和颜色关键字。
默认情况下，边框三个相关属性的值分别为<code>border-width: medium; border-style: none; border-color: black;</code>。调试的时候设置<code>border: 1px solid;</code>，1px可以把边框对布局宽度和高度的影响降到最低。</li>
</ul>
</li>
<li>盒子外边距：<ul>
<li>使用<code>* {margin: 0; padding: 0;}</code>中和默认值，再根据需要添加，就会在各浏览器上获得一致的效果。</li>
<li>叠加外边距：<strong>垂直方向上的外边距会叠加，水平外边距不叠加。</strong>上下外边距相遇时，它们会相互重叠，直至一个外边距碰到另一个元素的边框，且较宽的外边距决定两个元素最终距离。而水平相邻的元素，水平间距是相邻外边距之和。</li>
<li>设置外边距时需要混合使用不同的单位。比如一个段落的左右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间距，不受字号变大或变小的影响。而对于上下外边距，以em为单位则可以让段间距随字号变化而相应增大或缩小（按比例变化，整体布局就会依旧协调）。</li>
</ul>
</li>
<li>盒子到底有多大<ul>
<li>没有宽度的盒子：如果不设置块级元素的width属性，那么这个属性的默认值为auto，结果会让元素的宽度拓展到与父元素同宽。sum(添加水平边框、内边距和外边距) = 内容宽度减少量。</li>
<li>为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的<code>width</code>属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。</li>
</ul>
</li>
<li><p>浮动与清除
浮动可以实现：1. 传统出版物的文字绕排图片的效果。2. 可以让原来上下堆叠的块级元素变成左右并列，从而实现布局中的分栏。</p>
<ul>
<li><p>浮动元素会脱离常规文档流，在原来紧跟其后的元素就会在空间的允许下，向上提升到与浮动元素平起平坐。</p>
<blockquote>
<p>尽量把这个元素往上放，能放多高放多高，直到碰到某个元素的边界为止。  -- Eric Meyer</p>
</blockquote>
</li>
<li><p>浮动非图片元素时，必须给它设定宽度，否则后果难料。</p>
</li>
<li>浮动元素脱离文档流，父元素也不会再包围它。三种围住浮动元素：<ol>
<li>为父元素添加<code>overflow: hidden</code>。实际上<code>overflow: hidden</code>声明的真正用途是防止包含元素被超大内容撑大，包含元素依然保持其设定的宽度，而超大的子内容则会被容器剪切掉（之前有在下拉菜单的顶级元素上应用这个声明，结果作为其子元素的下拉菜单没有被显示，就是因为其被父元素剪切了），除此之外，它能可靠地迫使父元素包含其浮动的子元素。</li>
<li>同时浮动父元素。浮动父元素后，不管其子元素是否浮动，它总是会紧紧包围（也称收缩包裹）住它的子元素。</li>
<li>添加非浮动的清除元素。原理：给父元素的最后添加一个非浮动的子元素，然后清除该子元素。由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）浮动元素的下方，因此包含元素一定会包含这个子元素——以及前面的浮动元素。此种方法一共有两种方式：</li>
</ol>
</li>
<li>在HTML标记中添加一个子元素div，且给它应用clear属性。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-title">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">&quot;images/...&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>It&#39;s fun to float.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;clear-me&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">section</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">footer</span>&gt;</span>Here is the footer.<span class="hljs-tag">&lt;/<span class="hljs-title">footer</span>&gt;</span>
.clear_me { clear: left; }</code></pre><ul>
<li>用CSS来添加消除元素的方法。</li>
</ul>
<pre class="hljs"><code><span class="hljs-variable">&lt;section class = &quot;clearfix&quot;&gt;</span>
    <span class="hljs-variable">&lt;imag src=&quot;images/... /&gt;</span>
    <span class="hljs-variable">&lt;p&gt;</span>It&#39;s fun <span class="hljs-keyword">to</span> float.<span class="hljs-variable">&lt;/p&gt;</span>
<span class="hljs-variable">&lt;/section&gt;</span>
<span class="hljs-variable">&lt;footer&gt;</span>Here is the footer.<span class="hljs-variable">&lt;/footer&gt;</span></code></pre><pre class="hljs"><code><span class="hljs-class">.clearfix</span><span class="hljs-pseudo">:after</span> <span class="hljs-rules">{
    <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"> <span class="hljs-string">&quot;.&quot;</span></span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value">block</span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">visibility</span>:<span class="hljs-value"> hidden</span></span>;
    <span class="hljs-rule"><span class="hljs-attribute">clear</span>:<span class="hljs-value"> both</span></span>;
}</span></code></pre><p><code>clear: both</code> 意味这section中新增的子元素会清除左右浮动元素。</p>
<p>####定位
<code>position</code>有4个属性：static、relative、absolute、fixed，默认为static。
<strong>static（静态定位）</strong>：块级元素在常规文档流中自上而下的堆叠。
<strong>relative（相对定位）</strong>：到底相对哪里定位？相对的是它原来在文档流中的位置（或者默认位置）。
<code>p{ position: relative; top:25px; left:30px;}</code>
注意：top,left为正（负）值意味着把元素向下（上）、向右（左）移动。
<strong>absolute(绝对定位)</strong>：绝对定位会把元素彻底从文档流中拿出来。
<code>p{ position: absolute; top:25px; left:30px;}</code>
绝对定位元素默认的<em>定位上下文</em>是body。但绝对定位元素的任何祖先元素都可以成为它的定位上下文，只要你把相应的祖先元素<code>position：relative;</code>
<strong>fixed（固定定位）</strong>：固定定位元素也被完全移除了文档流，但固定定位的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面而移动。一般情况下，常用来创建位于顶部或左右侧，不随页面滚动而移动的导航元素。</p>
<p>####显示属性
display 把块级元素变成行内元素（或相反），可以使原先的行内元素填满其父元素。
<code>display: none</code>：该元素及所有包含在其中的元素，都不会在页面中显示。它们原先占据的所有空间也都会被“回收”，就好像相关的标记根本不存在一样。
<code>visibility</code>默认为visible，若设置为<code>hidden</code>，元素会隐藏，但它占据的页面空间仍然在（也就是只在页面上隐形了而已咯）。</p>
<p>####背景
<strong>！！此处添加盒模型三维透视图！！</strong>
CSS每个元素盒子可以想象成两个图层组成。
<strong>背景颜色</strong>
元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用实色填充（background-color属性），也可以包含任意多个背景图片（使用background-image属性），背景图片叠加在背景颜色之上。
<em>注意</em> 关于<code>color</code>属性：前景色属性，作用范围是元素的内容和边框。影响边框的前提是border没有设定边框颜色（或者<code>border-color</code>没有设定），边框就会使用color属性设定的字体颜色。默认为黑色。
<strong>背景图片</strong>
指定背景图片来源：<code>background-image: url(images/path);</code>
默认情况下，比元素小的背景图片以元素左上角为起点，水平和垂直方向上重复出现，直至填满整个背景空间。所以元素盒子底部和右侧的圆形图案都只显示了一部分。
<strong>背景重复</strong>
<code>background-repeat</code>：
<code>repeat</code>：默认值， 水平与垂直方向均重复；
<code>repeat-x</code>：只在水平方向重复；
 <code>repeat-y</code>：只在垂直方向重复；
 <code>no-repeat</code>：在任何方向上均不重复，即只让背景图片显示一次。
 <strong>CSS3背景</strong>
 <code>background-repeat: round</code> ：通过调整图片大小来适应背景区来确保图片不被剪切；
 <code>background-repeat: space</code>： 通过在图片间添加空白来适应背景区域。
<strong>背景位置</strong>
<code>background-position</code>：该属性有五个关键字值。<code>top、left、bottom、right和center</code>。 关键字中任意两个组合起来都可以作为该属性值。
<strong>注意</strong>，<code>background-position</code>属性会同时设定元素和图片的原点。原点决定了元素和图片中某一点的水平和垂直坐标。默认情况下。<code>background-position</code>的原点位于左上角，即元素左上角和图片的左上角是对齐的。
但是当把起点位置改为center center（50% 50% 也是一样的效果），如
<code>p#center {background-position: center;}</code>
若只设一个关键字值（不是数值），则另一个也会取相同的值。
设定了图片中心点与元素中心点重合，然后向水平和垂直方向重复。
如再设置<code>background-repeat: no-repeat</code> 则会实现图片在背景区域内居中的效果。
<strong>比较设置背景位置三个值：关键字、百分比、绝对或相对单位的数值。</strong>
<strong>关键字</strong>：顺序不重要。
<strong>数值</strong>：第一个值表示水平位置，第二个值表示垂直位置。要是只设定一个值，则将其用来设定水平位置，垂直位置被设为<code>center</code>。
使用关键字和百分比，设定的值同时应用于元素和图片。
<strong>像素等绝对单位数值</strong>：设定图片的左上角会被放在距离元素左上角指定位置的地方。
有趣的是，还可以设置负值，或者足够大的正值，实现显示部分图片。
<strong>背景尺寸</strong>
<code>background-size</code>：
50%：缩放图片，使其填充背景区的一半。
100px 50px：把图片调整到100px宽，50px高。
cover：拉大图片，使其完全填满背景区；保持宽高比。
contain：缩放图片，使其恰好适合背景区；保持宽高比。
<strong>背景粘附</strong>
<code>background-attachment</code>：控制滚动元素内的背景图片是否随元素滚动而移动。
<code>scroll</code>：属性默认值，即背景图片随元素移动。
<code>fixed</code>： 背景图片不随元素滚动而移动。
<code>inherit</code> ：继承初始值。
<strong>附</strong>：原书关于<code>background-attachment</code>属性设置并没有讲太多内容，但是在制作现代网页设计常见的<strong>视差滚动效果</strong>时候，是个重要属性。当然，在实现更amazing的效果时候会较复杂，需要结合CSS3的多背景图片属性，还有JavaScript(jQuery)来对页面进行控制。感兴趣请戳 <a href="http://isux.tencent.com/parallax-scrolling.html">Tencent ISUX「视“差”滚动浅析」</a>。
<strong>其他CSS3背景属性</strong>
<code>background-clip</code>： 控制背景绘制区域的范围。如让背景颜色和背景图片只出现在内容区，而不出现在内边距区域。
<code>background-origin</code>：控制背景定位区域的原点，可以设定盒子左上角以外的位置。
<code>background-break</code>：控制分离元素（比如跨越多行的行内盒子）的显示效果。</p>
<p>####多背景图片
CSS3中可以给元素添加多个背景图片，使用简写属性<code>background</code>如下：</p>
<pre class="hljs"><code>    <span class="hljs-tag">p</span> <span class="hljs-rules">{
        <span class="hljs-rule"><span class="hljs-attribute">text-align</span>:<span class="hljs-value"> center</span></span>;
        <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value">
        <span class="hljs-function">url</span>(images/<span class="hljs-number">01</span>.png) <span class="hljs-number">30px</span> -<span class="hljs-number">10px</span> no-repeat,
        <span class="hljs-function">url</span>(images/<span class="hljs-number">02</span>.png) <span class="hljs-number">145px</span> <span class="hljs-number">0px</span> no-repeat,
        <span class="hljs-function">url</span>(images/<span class="hljs-number">03</span>.png) <span class="hljs-number">140px</span> -<span class="hljs-number">30px</span> no-repeat <span class="hljs-hexcolor">#ffbd75</span></span></span>;
    }</span></code></pre><p><strong>注意</strong>：CSS规则中先列出的图片显示在上层，更接近前景。</p>
<p>####背景渐变
<code>linear-gradient</code>:
<code>radial-gradient</code>:</p>
<hr>
<p>###Chapter 4 字体和文本</p>
<blockquote>
<p>一个网站的品质如何，有时候只要看看它用的字体就能一目了然。如果说图片是蛋糕上的糖衣，那么排版才是卓越设计的根本。</p>
</blockquote>
<p>接触CSS这么久后，发现字体与排版是门大学问（也就是说，是个深坑…），只有经验丰富的设计师，才能创造出专业水准的网页排版吧。</p>
<p><strong>难道字体和文本不是一回事？</strong>
啊哈，当然不是。
<strong>字体</strong>是“文字的不同体式”，或“字的形体结构”。根据外观，字体可以分为不同<em>类别</em>（font collection），包括衬线字体（serif）、无衬线字体（sans-serif）和等宽字体（monospace）。每一类字体可以继续分为不同的<em>字体族</em>（font family），比如 Times 和 Helvetica。而字体族中又可以包含不同的<em>字形</em>（font face），反应了相应字体族基本设计的不同变化，例如 Times Roman、Times Bold、Helvetica Condensed、Bodoni italic。
<strong>文本</strong>就是一组字或者字符，比如章标题、段落正文等，跟使用什么字体无关。
CSS为字体和文本分别定义了属性。字体属性主要用于描述一类字体的大小和外观（什么字体族，多大字号，粗体还是斜体）。文本属性描述对文本的处理方式（行高或者字符间距，有没有下划线和缩进）。</p>
<p>####字体族
一般应该给整个页面<code>body</code>设定一种主字体，然后只对那些需要使用不同字体的元素再应用font-family。
有些字体在用户机器上不支持，那么就应该设置字体栈来指定本地字体。为了保险，字体栈的后面应补上大多数操作系统都内置的字体。
<strong>注意</strong>如果字体名像 Trebuchet MS 一样多于一个单词（有空格），应该加上引号：&quot;Trebuchet MS &quot;。</p>
<p>####字体大小
浏览器样式表默认为每个HTML元素都设定了font-size，所以你在设定 font-size 的时候，其实就是在修改默认值。</p>
]]></description><link>/2014-11-10-css-design-guide-notes/index.html</link><guid isPermaLink="true">/2014-11-10-css-design-guide-notes/index.html</guid><category><![CDATA[frontend]]></category><category><![CDATA[notes]]></category><dc:creator><![CDATA[ZBL]]></dc:creator><pubDate>Mon, 10 Nov 2014 09:08:00 GMT</pubDate></item></channel></rss>